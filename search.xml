<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>buildbot实战</title>
    <url>/2014/11/buildbot-in-action/</url>
    <content><![CDATA[<p><a href="http://buildbot.net/" target="_blank" rel="noopener">Buildbot</a>是一套基于python的的持续集成系统，可方便的进行自动化构建、部署、测试和发布。类似于Jenkins，但更轻量化且易于直接使用python进行扩展。Chrome社区就使用的buildbot作为其CI系统。<br>类似于Jenkins，buildbot在一个CI系统中扮演的更多是一个任务执行者的角色，其工作流程如下：</p>
<ul>
<li>监控代码仓库</li>
<li>代码仓库有变化后，立即拉取代码</li>
<li>执行build、部署、测试及发布工作</li>
<li>反馈结果</li>
</ul>
<p>我们对这样一个工具的一般要求为：</p>
<ul>
<li>轻量级，安装、配置简单，本身耗费资源较少</li>
<li>高效率，较快的完成自动化任务</li>
<li>通用性强，在不同的操作系统，甚至与不同的代码系统兼容</li>
<li>易扩展、配置及管理，能较简单的配置自动化任务</li>
</ul>
<p>Buildbot和Jenkins都能很好的满足我们这些要求。但相比Jenkins，buildbot更轻量级，部署配置更为简单。<br>Web界面也更简单美观一些。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>buildbot架构比较简单，主要分为三部分：</p>
<ul>
<li>版本控制层<br>外部版本控制，通过插件或主动触发的方式触发buildbot执行任务。</li>
<li>任务执行层<br>master接收任务后，调度其slave执行任务，并获取到返回的结果</li>
<li>通知层<br>master获取结果后，可通过邮件、IRC等方式进行通知。</li>
</ul>
<p>其中重要的主体是master和slave，其主要采用星形拓扑结构，一个集群中可以多个master、多个slave。master主要负责任务接收、调度并通知任务，slave负责具体的任务执行。各节点本身无状态，横向扩展性很好。<br><a id="more"></a><br><img src="/img/buildbot-overview.png" alt="buildbot架构"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>建议使用pip安装，避免麻烦的依赖问题。<br>同时当前对python3版本支持不太好，建议使用python2.7版本：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install gcc python-devel </span><br><span class="line">yum install python-dateutil15 git expect</span><br><span class="line"><span class="comment"># master安装</span></span><br><span class="line">pip install buildbot</span><br><span class="line"><span class="comment"># salve安装</span></span><br><span class="line">pip install buildbot-slave</span><br></pre></td></tr></table></figure></p>
<p>如果是python2.6的话，因为最新版本的Twisted需要python2.7，所以需要提前指定版本安装：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install Twisted==15.1.0</span><br></pre></td></tr></table></figure></p>
<p>为充分利用资源，同一台机器可配置为多个master、slave：可使用不同用户或virtualenv，每个用户或virtualenv环境部署为一个节点。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure></p>
<h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><p>最近看到<a href="http://docs.buildbot.net/current/tutorial/docker.html" target="_blank" rel="noopener">buildbot官方</a>给出了Dockerfile(但Dockerfile地址是错的，可以自行在github代码中查找)，可下载后自行构建镜像使用，运行后即可使用：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Download Buildbot Dockerfile.</span></span><br><span class="line">wget https://raw.githubusercontent.com/buildbot/buildbot/master/master/Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build the Buildbot container (it will take a few minutes to download packages)</span></span><br><span class="line">docker build -t buildbot - &lt; Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run buildbot</span></span><br><span class="line">CONTAINER_ID=$(docker run -d -p 8010:8010 -p 22 buildbot)</span><br></pre></td></tr></table></figure></p>
<p>然后打开<a href="http://localhost:8010" target="_blank" rel="noopener">http://localhost:8010</a>即可。</p>
<h2 id="创建及运行"><a href="#创建及运行" class="headerlink" title="创建及运行"></a>创建及运行</h2><h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">buildbot create-master master</span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">mv master/master.cfg.sample master/master.cfg</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">buildbot start master</span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">tail -f master/twistd.log</span><br></pre></td></tr></table></figure>
<p>buildbot会在当前目录下创建master名称的目录，以上为<code>master</code>。<br>看到最后显示<code>BuildMaster is running</code>即为启动成功，此时可通过<a href="http://localhost:8010" target="_blank" rel="noopener">http://localhost:8010</a>访问，默认用户名密码都是<code>pyflakes</code>。</p>
<h3 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h3><p>创建slave时需要指定mater的地址，或者修改配置文件指定。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">buildslave create-slave slave1 localhost:9989 slave1 pass</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">buildslave start slave</span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">tail -f slave/twistd.log</span><br></pre></td></tr></table></figure></p>
<p>create-slave的参数分布是：slave目录、master、名字、密码。其中master默认都采用9989与slave通信。名字、密码必须与master的master.cfg中配置的一致：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c[<span class="string">'slaves'</span>] = [buildslave.BuildSlave(<span class="string">"example-slave"</span>, <span class="string">"pass"</span>)]</span><br></pre></td></tr></table></figure></p>
<h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p>此时打开<a href="http://localhost:8010" target="_blank" rel="noopener">http://localhost:8010</a>即可看到如下页面：<br><img src="/img/buildbot-index.png" alt="buildbot预览"><br>其中Buildslaves页面可查看到我们新添加的example-slave，且状态为<code>Idle</code>。<br>而Waterfall页面可查看到当前的builder，目前只有runtest，点进去点击forcebuild即可进行测试build。成功后记录显示为绿色。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Buildbot的配置文件为<code>.cfg</code>后缀的python脚本，使用python语法。如上文slave的定义就是一个python list的定义。</p>
<h3 id="master配置"><a href="#master配置" class="headerlink" title="master配置"></a>master配置</h3><p>主要配置如下。</p>
<ul>
<li>BUILDSLAVES<br>slave的定义，以list的形式呈现。需要主要名字和密码与slave一致。<br>其中protocols可定义与slave的通信方式，包括端口等。</li>
<li><p>CHANGESOURCES<br>指定需要监控的源代码地址。格式如下，其中可指定git地址、工作目录、分支、监控周期等。可定义多个，每个append进list即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c[&apos;change_source&apos;] = []</span><br><span class="line">c[&apos;change_source&apos;].append(changes.GitPoller(</span><br><span class="line">        &apos;git://github.com/buildbot/pyflakes.git&apos;,</span><br><span class="line">        workdir=&apos;gitpoller-workdir&apos;, branch=&apos;master&apos;,</span><br><span class="line">        pollinterval=300))</span><br></pre></td></tr></table></figure>
</li>
<li><p>SCHEDULERS<br>scheduler指定何时、如何触发执行builder，其中builder在BUILDERS中定义。下文定义了两个scheduler：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c[<span class="string">'schedulers'</span>] = []</span><br><span class="line"><span class="comment"># 定义每小时运行的scheduler</span></span><br><span class="line">hourlyscheduler = Periodic(name = <span class="string">"hourly"</span>,</span><br><span class="line">                           builderNames = [<span class="string">"simplebuild"</span>],</span><br><span class="line">                           periodicBuildTimer = <span class="number">3600</span>)</span><br><span class="line"><span class="comment"># 定义手动触发的scheduler</span></span><br><span class="line">c[<span class="string">'schedulers'</span>].append(schedulers.ForceScheduler(</span><br><span class="line">                            name=<span class="string">"force"</span>,</span><br><span class="line">                            builderNames=[<span class="string">"master"</span>]))</span><br></pre></td></tr></table></figure>
</li>
<li><p>BUILDERS<br>builder定义具体执行的任务内容，由一系列的步骤组成。每个步骤定义在step中，factory包含一系列的step，builder通过指定factory等参数创建。可定义多个builder。<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义factory</span></span><br><span class="line">factory = util.BuildFactory()</span><br><span class="line"><span class="comment"># 定义具体step</span></span><br><span class="line">factory.addStep(steps.Git(repourl=<span class="string">'git://github.com/buildbot/pyflakes.git'</span>, mode=<span class="string">'incremental'</span>))</span><br><span class="line">factory.addStep(steps.ShellCommand(command=[<span class="string">"trial"</span>, <span class="string">"pyflakes"</span>]))</span><br><span class="line"><span class="comment"># 创建builder</span></span><br><span class="line">c[<span class="string">'builders'</span>] = []</span><br><span class="line"><span class="comment"># 指定名称、使用的slave、factory</span></span><br><span class="line">c[<span class="string">'builders'</span>].append(</span><br><span class="line">    util.BuilderConfig(name=<span class="string">"master"</span>,</span><br><span class="line">      slavenames=[<span class="string">"master"</span>],</span><br><span class="line">      factory=factory))</span><br></pre></td></tr></table></figure>
</li>
<li><p>STATUS TARGETS<br>此处定义buildbot对外通知build信息的方式。最基本的方式就是显示在页面中，因此此处同时定义了页面的认证方式，即登录使用的用户名、密码在此处修改。同时可定义IRC、邮件等通知方式。</p>
</li>
<li>PROJECT IDENTITY<br>此处主要为buildbot的基本信息，如title、超链接、url等。</li>
<li>DB URL<br>此处定义使用的数据库，默认使用sqlite，地址为本地文件路径。</li>
</ul>
<h3 id="配置slave"><a href="#配置slave" class="headerlink" title="配置slave"></a>配置slave</h3><p>slave的定义主要在<code>buildbot.tac</code>文件中，可用于定义使用的master及slave基本信息。</p>
<h2 id="启动及使用"><a href="#启动及使用" class="headerlink" title="启动及使用"></a>启动及使用</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul>
<li>启动<br>master、slave的启动上文已提及，子命令为start，参数为路径。</li>
<li>停止、重启<br>stop和restart，其余同start</li>
<li>master重新加载配置<br><code>buildbot reconfig master</code>即可重新加载配置。</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>平时比较常用手动触发build，即forcebuild：web页面登录-&gt;Builders-&gt;选择builder-&gt;Force Build-&gt;在Waterfall查看打包结果及详细日志。<br><img src="/img/buildbot-waterfall.png" alt="buildbot waterfall"><br>注意：只有登录后才有build权限。</p>
<h3 id="各页面介绍"><a href="#各页面介绍" class="headerlink" title="各页面介绍"></a>各页面介绍</h3><p>Buildbot比较方便的一点是全部通过页面来进行操作。主要页面介绍如下：</p>
<ul>
<li>Waterfall，以瀑布流的方式显示build任务，可点击任务查看详情、执行操作等</li>
<li>Grid/T-Grid，以对应的方式显示build任务</li>
<li>Console，还在开发中，当前主要显示revision信息</li>
<li>Builders，定义的所有builder</li>
<li>Recent Builds，最近的build</li>
<li>Buildslaves，定义的所有slave</li>
<li>Changesources，定义的所有代码仓库</li>
<li>JSON API，对外提供的JSON API文档</li>
</ul>
<h2 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h2><h3 id="多分支build"><a href="#多分支build" class="headerlink" title="多分支build"></a>多分支build</h3><p>定义一个Changesource。<br>定义多个schedulers，分别对应不同分支。<br>定义多个factory，其中的step除branch不同外，其余step通用。通用的step可一次定义，多次使用。<br>builder分别指定分支和factory。</p>
<h3 id="多项目build"><a href="#多项目build" class="headerlink" title="多项目build"></a>多项目build</h3><p>新版本可使用此功能，但不太推荐。buildbot的一个master还是更多的擅长对一个项目的管理。<br>需要定义多个Changesource，然后在其它定义时通过<code>project</code>和<code>repository</code>参数指定项目。</p>
<h3 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h3><p>通过检查step的返回结果判断是否执行成功，规则同shell：0为成功，其它失败。<br>因此如果step中调用了自己的脚本，需要保证按上述规则返回结果。</p>
<h3 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h3><p>使用<code>util.Property</code>获得网页上指定的参数，可设置默认值：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">factory.addStep(steps.ShellCommand(command=[<span class="string">"bash"</span>, <span class="string">"autorpm.sh"</span>, util.Property(<span class="string">'project'</span>, default=<span class="string">''</span>)]))</span><br></pre></td></tr></table></figure></p>
<p>在build页面通过name/value指定，如：<br><img src="/img/buildbot-param.png" alt="buildbot指定参数"></p>
<h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><p>实际使用中发现，buildslave所创建的文件，权限都为600或700。<br>这样会造成如cp到apache目录时，apache无法读取文件。<br>通过官方文档查看到slave启动时有umask选项：</p>
<blockquote>
<p>–umask<br>This is a string (generally an octal representation of an integer) which will cause the buildslave process’ umask value to be set shortly after initialization.<br>The twistddaemonization utility forces the umask to 077 at startup (which means that all files created by the buildslave or its child processes will be unreadable by any user other than the buildslave account).<br>If you want build products to be readable by other accounts, you can add –umask=022 to tell the buildslave to fix the umask after twistd clobbers it.<br>If you want build products to be writable by other accounts too, use –umask=000, but this is likely to be a security problem.</p>
</blockquote>
<p>通过修改slave目录下的buildbot.tac，修改：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umask = 022</span><br></pre></td></tr></table></figure></p>
<p>然后重启slave解决此问题:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">buildbot stop slave1</span><br><span class="line">buildbot stop slave2</span><br></pre></td></tr></table></figure></p>
<h2 id="参考索引"><a href="#参考索引" class="headerlink" title="参考索引"></a>参考索引</h2><ul>
<li><a href="https://build.chromium.org/p/chromium/console" target="_blank" rel="noopener">chromium buildbot</a></li>
<li><a href="http://docs.buildbot.net/current/tutorial/docker.html" target="_blank" rel="noopener">docker安装buildbot</a></li>
<li><a href="http://docs.buildbot.net/current/tutorial/tour.html" target="_blank" rel="noopener">quick tour of buildbot</a></li>
<li><a href="http://docs.buildbot.net/current/tutorial/fiveminutes.html" target="_blank" rel="noopener">Buildbot in 5 minutes</a></li>
</ul>
]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>openstack</tag>
        <tag>ci</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之三：curl基本使用</title>
    <url>/2012/08/linux-curl-basic-usage/</url>
    <content><![CDATA[<p>在介绍完<a href="http://stackeye.com/2012/07/linux-curl-description/" target="_blank" rel="noopener">cURL简介</a>和需要的<a href="http://stackeye.com/2012/07/linux-curl-http-protocol/" target="_blank" rel="noopener">HTTP协议概述</a>之后。终于可以回归正题，进入curl的使用方法。</p>
<h2 id="curl命令格式"><a href="#curl命令格式" class="headerlink" title="curl命令格式"></a>curl命令格式</h2><p>基本的使用用法如下：<br><code>curl [选项] [URL...]</code></p>
<h2 id="GET一个网页"><a href="#GET一个网页" class="headerlink" title="GET一个网页"></a>GET一个网页</h2><p><code>curl http://www.baidu.com</code><br>网页源码将被打印出来。</p>
<h3 id="o-output-lt-file-gt-指定保存目录"><a href="#o-output-lt-file-gt-指定保存目录" class="headerlink" title="-o/--output &lt;file&gt;指定保存目录"></a><code>-o/--output &lt;file&gt;</code>指定保存目录</h3><p>为便于后续处理，我们将网页内容保存在文件中：<br><code>curl -o stackeye.html http://www.stackeye.com</code><br>此时仍会显示进度条等信息。</p>
<h3 id="s-silent静默模式"><a href="#s-silent静默模式" class="headerlink" title="-s/--silent静默模式"></a><code>-s/--silent</code>静默模式</h3><p>通过脚本结合curl可以实现很复杂的功能，而在脚本中调用curl，我们不需要进度条等信息。如执行：<br><code>curl -s -o stackeye.html http://www.stackeye.com</code><br>将不会显示任何信息。<br><a id="more"></a></p>
<h2 id="v-–verbose查看通信过程、调试。"><a href="#v-–verbose查看通信过程、调试。" class="headerlink" title="-v/–verbose查看通信过程、调试。"></a>-v/–verbose查看通信过程、调试。</h2><p>这个参数可以清晰的查看到curl的通信过程，以便于调试，如执行：<br><code>curl -v http://www.baidu.com</code><br>返回结果如下，可以清晰的看到curl发出的HTTP请求及服务器返回的HTTP响应：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* About to connect() to www.baidu.com port 80 (#0)</span><br><span class="line">*   Trying 119.75.218.77... connected</span><br><span class="line">* Connected to www.baidu.com (119.75.218.77) port 80 (#0)</span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; User-Agent: curl/7.21.0 (i686-pc-linux-gnu) libcurl/7.21.0 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18</span><br><span class="line">&gt; Host: www.baidu.com</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Date: Wed, 01 Aug 2012 12:39:15 GMT</span><br><span class="line">&lt; Server: BWS/1.0</span><br><span class="line">&lt; Content-Length: 8216</span><br><span class="line">&lt; Content-Type: text/html;charset=gbk</span><br><span class="line">&lt; Cache-Control: private</span><br><span class="line">&lt; Expires: Wed, 01 Aug 2012 12:39:15 GMT</span><br><span class="line">&lt; Set-Cookie: BAIDUID=AF0E3C36DBB60C0D7C29DE11705028D7:FG=1; expires=Wed, 01-Aug-42 12:39:15 GMT; path=/; domain=.baidu.com</span><br><span class="line">&lt; P3P: CP=&quot; OTI DSP COR IVA OUR IND COM &quot;</span><br><span class="line">&lt; Connection: Keep-Alive</span><br><span class="line">&lt;</span><br><span class="line">&lt;!doctype html&gt;以下为HTML内容，略</span><br></pre></td></tr></table></figure></p>
<p>以下所有命令都可以通过加入-v选项，查看具体通信过程。<br>更详细的调试信息可以使用–trace-ascii选项，如：<br><code>curl --trace-ascii debug.txt http://www.baidu.com</code></p>
<h2 id="A-–user-agent指定User-Agent字段"><a href="#A-–user-agent指定User-Agent字段" class="headerlink" title="-A/–user-agent指定User-Agent字段"></a>-A/–user-agent指定User-Agent字段</h2><p>此选项字段用于指定HTTP请求头的User-Agent字段，即客户端（如浏览器）类型。<br>很多网站为了防止自动化程序采集，仅允许浏览器访问，最简单的办法就是通过User-Agent字段识别客户端类型做出处理。而如下命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span></span><br><span class="line"> http://www.stackeye.com</span><br></pre></td></tr></table></figure></p>
<p><code>&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)&quot;</code>为firefox的UserAgent值。<br>通过-A指定User-Agent字段，使curl伪装成Firefox，从而绕过网站的检测。<br>User-Agent字段可以通过抓包分析得到，或者通过chrome的Developer Tools、Firefox的Firebug等工具得到。<br>而如果一个网站对浏览器的限制也很严格的话，那我们甚至可以通过修改User-Agent伪装成百度蜘蛛或者googlebot突破限制，因为基于SEO的考虑，网站对搜索引擎蜘蛛的限制很小。</p>
<h2 id="e-–referer-设置Referer"><a href="#e-–referer-设置Referer" class="headerlink" title="-e/–referer 设置Referer"></a>-e/–referer <url>设置Referer</url></h2><p>此选项字段用于指定HTTP请求头中的Referer字段，即来源网页。<br>为了防盗链，很多网页尤其是图片等可下载资源会检测Referer字段，对于非自己站内的来源全部屏蔽掉，此时我们就需要这个参数。<br>通过执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span></span><br><span class="line"> -e http://www.baidu.com http://www.stackeye.com</span><br><span class="line">http://www.stackeye.com将检测到来源网站为http://www.baidu.com</span><br></pre></td></tr></table></figure></p>
<h2 id="cookie使用"><a href="#cookie使用" class="headerlink" title="cookie使用"></a>cookie使用</h2><p>cookie的介绍参考上一篇。<br>我们登录网站后，为保持登录状态，需要使用cookie信息。</p>
<h3 id="D-–dump-header-保存协议头部信息"><a href="#D-–dump-header-保存协议头部信息" class="headerlink" title="-D/–dump-header 保存协议头部信息"></a>-D/–dump-header 保存协议头部信息</h3><p><code>-D/--dump-header &lt;file&gt;</code>保存协议头部信息<br>头部信息中包含最常使用的cookie信息，如执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span></span><br><span class="line"> -e http://www.baidu.com -D stackeyecookie.txt http://www.stackeye.com</span><br></pre></td></tr></table></figure></p>
<p>会将头部信息保存至stackeyecookie.txt中。</p>
<h3 id="b-–cookie-指定cookie"><a href="#b-–cookie-指定cookie" class="headerlink" title="-b/–cookie 指定cookie"></a>-b/–cookie 指定cookie</h3><p><code>-b/--cookie &lt;name=data&gt;/&lt;file&gt;</code>指定cookie<br>-b后可直接加-D保存的文件，curl会自动从中读取出cookie值，而且-b选项不会修改此文件。如执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span></span><br><span class="line"> -e http://www.baidu.com -b stackeyecookie.txt http://www.stackeye.com</span><br></pre></td></tr></table></figure></p>
<p>会自动将stackeyecookie.txt中cookie信息附加至HTTP请求头中。</p>
<p>结合-D和-b参数，即可完成cookie的保存和后续使用。</p>
<p>cookie的形式就是“属性:值”对形式，-b后可直接以“属性=值”的形式给出cookie，当有多个属性时以分号间隔且包含在双引号中。如执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span></span><br><span class="line"> -b <span class="string">"user=Adeploy;pass=password"</span> http://www.stackeye.com</span><br></pre></td></tr></table></figure></p>
<p>会将cookie信息<code>user=Adeploy;pass=password</code>附加在HTTP请求头中。</p>
<h2 id="Redirects重定向"><a href="#Redirects重定向" class="headerlink" title="Redirects重定向"></a>Redirects重定向</h2><p>打开某些网页，网页会显示“ 3XX Moved Permanently ”，即网页被移动到其他位置，新位置一般由HTTP响应头中的Location字段给出。<br>重定向一般是因为网站结构调整后，避免用户访问原来页面出现404错误。<br>而另一类常见的用法就是在登陆成功后，网页显示成功信息，然后将用户重定向至内容页面。<br><code>-L/--location</code>选项可以自动跟踪重定向。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇只介绍简单的curl使用选项，下篇将结合实例具体说明。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之一：cURL简介</title>
    <url>/2012/07/linux-curl-description/</url>
    <content><![CDATA[<p>随着网络应用的盛行，HTTP脚本编程成为一项流行的技术：<br>你可能需要到某个web页面自动的下载一些信息（采集）或请求某个接口；<br>可能还需要模仿成一个正常浏览器的样子，或者使用代理；<br>甚至需要上传或POST数据。</p>
<p>而cURL就是HTTP脚本编程的利器。</p>
<h2 id="什么是cURL"><a href="#什么是cURL" class="headerlink" title="什么是cURL"></a>什么是cURL</h2><p>cURL的官方网站上这样解释：“The name is a play on ‘Client for URLs’”。意思为“访问URL的客户端”。<br>“cURL is a command line tool for doing all sorts of URL manipulations and transfers”，cURL是用于进行各种对URL的操作和访问传输的命令行工具。<br>而在Linux man手册里这样解释：“cURL - transfer a URL”，意思是对URL的访问传输。<br>今天我们要讲的curl是Linux下一个强大的对URL进行操作的命令行工具。<br>而cURL的写法，URL突出大写，也正是强调对URL的操作。<br><a id="more"></a></p>
<h2 id="cURL主要特点"><a href="#cURL主要特点" class="headerlink" title="cURL主要特点"></a>cURL主要特点</h2><ol>
<li>支持多协议<br>URL的定义为“统一资源定位符”（详见RFC 3986），是不局限于HTTP协议的。<br>因此cURL支持多种协议，如DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS,IMAP, IMAPS,LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, TELNET and TFTP等。</li>
<li>命令行操作，简单强大<br>CURL是无GUI界面的，全部基于命令行操作，这无疑使它可以很方便的集成在像Linux脚本等程序中，<br>而通过我们进一步编程处理，就可以完成非常强大的功能。</li>
<li>开源跨平台<br>cURL工具是由<a href="http://curl.haxx.se/" target="_blank" rel="noopener">libcurl开源项目组</a>提供，此项目组提供开源的libcurl库，此库是由C语言实现客户端URL操作库，提供对URL的访问等操作功能，cURL工具就是采用libcurl实现。<br>而因为libcurl库是适用于多个平台的，因此cURL也适用于多个平台，如Win、Linux、OS/400、TPF等平台。<br>这成为cURL比GNU官方的wget更强大的原因之一。</li>
</ol>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之二：HTTP协议概述</title>
    <url>/2012/07/linux-curl-http-protocol/</url>
    <content><![CDATA[<p>虽然cURL支持多种协议，但日常我们最常用的还是HTTP协议，下文中着重介绍HTTP的相关使用方法，因此我们要对HTTP协议有所了解。</p>
<blockquote>
<p>HTTP，超文本传送协议，通过因特网传送万维网文档的数据传送协议。</p>
</blockquote>
<p>我们访问一个网页的实际过程如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端C===HTTP请求===&gt;服务端S：GET index.html http/1.1</span><br><span class="line">客户端C&lt;==HTTP响应====服务端S：HTTP/1.1 200 OK HTML文件内容</span><br></pre></td></tr></table></figure></p>
<p>HTTP协议本身是个无状态协议，它不像其他基于会话的协议那样去不断追踪、记忆事务处理过程。而它要做的就只是简单的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">连接=&gt;发起HTTP请求(HTTP Request)=&gt;得到HTTP响应(HTTP Response)=&gt;断开连接</span><br></pre></td></tr></table></figure></p>
<p>而平常我们通过浏览器浏览网页这个过程，浏览器自动完成发送HTTP请求及对服务端应答的数据进行解析的工作，从而将网页呈现给我们。</p>
<p>我们使用cURL要做的就是模仿浏览器的动作，因此要对HTTP请求的格式进行进一步的解析。</p>
<h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p>在你向HTTP服务器请求一个资源（比如简单的使用浏览器打开一个网页），TCP三次握手建立连接后，HTTP请求发出。<br>HTTP请求信息由3部分组成：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l 请求行(Request Line)</span><br><span class="line">l 请求头(Request Header)</span><br><span class="line">l 请求正文(Message Body)</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="HTTP请求行"><a href="#HTTP请求行" class="headerlink" title="HTTP请求行"></a>HTTP请求行</h3><p>典型的HTTP请求行格式为：<br><code>HTTP命令 请求资源的URI HTTP版本号</code><br>HTTP请求行例子如下：<br><code>GET / HTTP/1.1\r\n</code></p>
<p>这个请求行的意思是：请求得到（GET）/路径下的默认主页文件，使用HTTP协议1.1版本。</p>
<p>根据HTTP标准，HTTP请求可以使用多种请求方法。例如：HTTP1.1支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE和TARCE。而服务器也可以自定义请求命令供客户端使用。具体请参考HTTP的RFC文档。而我们最常用的是GET和POST命令：</p>
<h4 id="GET命令"><a href="#GET命令" class="headerlink" title="GET命令"></a>GET命令</h4><p>GET主要用于取得URL指定的资源信息，也可用来提交表单。GET提交的信息实际上是附加在url之后作为URL的一部分。<br>当年盛行一时的SQL注入，最常见的检测手段就是在GET提交的链接后加单引号来检测是否存在注入漏洞。<br>如提交username和password两个字段，正常的GET网址如下：<br><code>http://www.xxx.com/login.php?username=user&amp;password=pass</code><br>网站后台就会在_GET数组中取得username和password的值，从而组建SQL语句：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> user_table <span class="keyword">where</span> username=<span class="keyword">user</span> <span class="keyword">and</span> <span class="keyword">password</span>=pass</span><br></pre></td></tr></table></figure></p>
<p>如果返回的count值大于0即为用户名密码正确。<br>而添加单引号后：<br><code>http://www.xxx.com/login.php?username=user&amp;password=pass&#39;</code><br>组建的SQL语句为<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> user_table <span class="keyword">where</span> username=<span class="keyword">user</span> <span class="keyword">and</span> <span class="keyword">password</span>=pass<span class="string">'</span></span><br></pre></td></tr></table></figure></p>
<p>这个SQL语句执行出错，网页显示错误信息，黑客从而得知网页有SQL注入漏洞。<br>因此使用GET提交表单是不安全的，只进行了简单的编码无法加密，可以很容易的从网址猜出各字段的意思。而且受限于URL长度限制，GET提交表单能携带的数据也有限。</p>
<h4 id="POST命令"><a href="#POST命令" class="headerlink" title="POST命令"></a>POST命令</h4><p>POST主要用于提交表单，尤其是提交大批量的表单数据。<br>POST方法克服了GET方法的一些缺点。通过POST方法提交表单数据时，数据不是作为URL请求的一部分而是作为标准数据传送给Web服务器，这就克服了GET方法中的信息无法加密和数据量太小的缺点。</p>
<p>HTTP请求的下一段数据为HTTP请求头。</p>
<h3 id="HTTP请求头"><a href="#HTTP请求头" class="headerlink" title="HTTP请求头"></a>HTTP请求头</h3><p>HTTP请求头中主要包含关于请求本身或者客户端的有用信息，比如浏览器的类型、浏览器语言、编码、压缩算法等信息。服务器上的动态脚本如PHP等可以利用请求头信息生成动态的网页内容。</p>
<p>典型的HTTP请求头例子如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.168 Safari/535.19 QIHU 360EE</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Referer: http://www.adeploy.com/</span><br><span class="line">Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3</span><br></pre></td></tr></table></figure></p>
<p><code>\r\n</code>表示换行。由此可以看到HTTP请求头是由几行“属性:值”对组成的，例如属性Accept的值为<code>*/*\r\n</code> ，表示客户端可以接受任意数据类型。<br>而我们最常用的是<code>User-Agent</code>字段和<code>Referer</code>字段，分别用于指定客户端类型和来源页面。<br>最末行额外多出的一对<code>\r\n</code>表示一个空白行，此空白行表示HTTP请求头结束，以下部分为请求正文。</p>
<h3 id="HTTP请求正文"><a href="#HTTP请求正文" class="headerlink" title="HTTP请求正文"></a>HTTP请求正文</h3><p>HTTP请求正文经常为空，除非需要向服务端提交信息，如在使用POST向网站提交表单的时候。<br>例如如下是一个完整的HTTP请求的例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.adeploy.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.168 Safari/535.19 QIHU 360EE</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Referer: http://www.adeploy.com/</span><br><span class="line">Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3</span><br></pre></td></tr></table></figure></p>
<h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>当收到HTTP请求之后，HTTP服务器会进行处理然后返回一个HTTP响应给客户端（典型的客户端为浏览器）。HTTP响应中包含几乎与HTTP请求同样类型的数据。<br>HTTP响应信息也由3部分组成：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l 响应行(Response Status Line)</span><br><span class="line">l 响应头(Response Header)</span><br><span class="line">l 响应正文(Message Body)</span><br></pre></td></tr></table></figure></p>
<p>响应行以服务端使用的HTTP协议版本号开始，后加响应状态码，表示请求结果状态，例如：<br><code>HTTP/1.1 200 OK</code><br>状态码200表示请求成功。</p>
<p>紧接着的是响应头。响应头与请求头十分相似，也是由几行“属性:值”对组成。其中包含关于服务器的有用信息、响应数据等。典型响应头如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Expires: Fri, 01 Jan 1990 00:00:00 GMT</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Date: Tue, 31 Jul 2012 07:20:31 GMT</span><br><span class="line">Server: Google Frontend</span><br><span class="line">Content-Length: 10387</span><br></pre></td></tr></table></figure></p>
<p>如果请求成功，响应正文中将包含请求的数据，如图片文件的二进制数据、HTML文件等。一旦响应正文传输完毕，服务端又没有使用HTTP 1.1/2版本的Keep-Alive请求，HTTP连接将会断开。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie是服务器为了辨别用户身份、进行session跟踪用户识别，而储存在客户端的数据。用以判断在HTTP传输中的状态，从而弥补HTTP协议无状态的缺陷。</p>
<p>比如我们登录一个网站后，关闭网页后重新打开网页，服务端就可以通过cookie信息判断我们曾经登录过，从而跳过重新登录的过程，让用户感觉到亲切、方便、人性化。</p>
<p>当客户端向服务端发起请求时，浏览器会自动将cookie信息添加在HTTP请求头中。例子如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cookie: __utmc=90639562; __utma=90639562.1273157993.1343361841.1343361841.1343718828.2; __utmb=90639562.1.10.1343718828; __utmz=90639562.1343361841.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none)</span><br></pre></td></tr></table></figure></p>
<p>在我们使用cURL时，每次访问网页都相当于浏览器打开关闭一次，因此cookie会起到很大的作用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇介绍后续会使用的HTTP协议知识，只做简要概括，具体请参考RFC文档。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>http协议</tag>
      </tags>
  </entry>
  <entry>
    <title>解密Redis持久化</title>
    <url>/2017/04/redis-persistence-demystified/</url>
    <content><![CDATA[<p>本文主要是对<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html" target="_blank" rel="noopener">antirez博客</a>的翻译。其实<a href="http://blog.nosqlfan.com/html/3813.html" target="_blank" rel="noopener"></a>nosqlfan已经有一篇译文，但不知道为什么省略了很多重要的细节，因此完整翻译了本篇。</p>
<p>首先antirez感觉到，他看到的所有针对Redis的文章和讨论中，对Redis持久化的误解是最大的。因此在这篇文章中，他将尝试真正的公正一些：不做Redis的广告，不尝试跳过任何细节以避免使Redis模糊不清。作者想做的仅是提供一个清晰易懂的描绘，介绍Redis持久化的工作原理，Redis的持久化如何可靠，以及与其它数据库的对比。</p>
<h2 id="操作系统和磁盘"><a href="#操作系统和磁盘" class="headerlink" title="操作系统和磁盘"></a>操作系统和磁盘</h2><h3 id="写操作的流程"><a href="#写操作的流程" class="headerlink" title="写操作的流程"></a>写操作的流程</h3><p>我们应该考虑的第一件事是对于数据库的持久化，我们的期望是什么。因此我们将一个简单的写操作中发生的事情可视化：</p>
<ol>
<li>客户端发送写命令到数据库（数据库在客户端内存中）</li>
<li>数据库接收到写操作（数据在服务器内存中）</li>
<li>数据库调用系统调用，将数据写入磁盘（数据在内核缓冲区中）</li>
<li>操作系统将写缓冲区的数据转移到磁盘控制器上（数据在磁盘缓存中）</li>
<li>磁盘控制器真正将数据写入到物理介质（数据真正落在磁盘上）<a id="more"></a>
<blockquote>
<p>注意：以上是一个各方面简单化的版本，因为实际有更多的cache和buffer。<br>步骤2经常被实现为数据库内部的一个复杂缓存系统。写操作也经常被不同的线程或进程处理。然而数据库或早或晚要将数据写入磁盘，而这就是我们关心的。也就是说，内存中的数据在某个节点必须要被传输到内核（步骤3）。<br>另外一个大的细节省略在步骤3.现实要更复杂，因为大多数高级操作系统内核实现了不同级别的缓存，其中通常包含文件系统级别的chache和一个略小一些的buffer cache。</p>
</blockquote>
</li>
</ol>
<h3 id="故障分析"><a href="#故障分析" class="headerlink" title="故障分析"></a>故障分析</h3><p>在这个流程中什么时候我们的写操作才是安全的呢？</p>
<p>如果我们考虑一个仅涉及数据库软件的失效（例如进程被管理员杀掉或崩溃），而不涉及操作系统内核，那成功执行完成步骤3的写操作就被认为是安全的。也就是在write这个系统调用（或其它用于将数据转移到内核的系统调用）返回成功后。在此步骤之后，即使数据库进程崩溃，内核仍然会负责将数据转移到磁盘控制器。</p>
<p>如果我们考虑一个更灾难性的事件，如电力中断，只有在步骤5执行完成后我们才是安全的。也就是在数据真正被转移到物理设备中时。</p>
<p>我们可以总结为，数据安全的重要阶段位于步骤3、4、5：</p>
<h3 id="POSIX-API"><a href="#POSIX-API" class="headerlink" title="POSIX API"></a>POSIX API</h3><h3 id="我们无法控制的部分"><a href="#我们无法控制的部分" class="headerlink" title="我们无法控制的部分"></a>我们无法控制的部分</h3><h3 id="数据损坏"><a href="#数据损坏" class="headerlink" title="数据损坏"></a>数据损坏</h3><h2 id="Redis持久化实现"><a href="#Redis持久化实现" class="headerlink" title="Redis持久化实现"></a>Redis持久化实现</h2><h3 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h3><h3 id="AOF文件"><a href="#AOF文件" class="headerlink" title="AOF文件"></a>AOF文件</h3><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>appendfsync no<br>appendfsync everysec<br>appendfsync always<br>为什么pipeline不同<br>AOF和Redis事务</p>
<h3 id="与PostgreSQL和MySQL的对比"><a href="#与PostgreSQL和MySQL的对比" class="headerlink" title="与PostgreSQL和MySQL的对比"></a>与PostgreSQL和MySQL的对比</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h2><h2 id="附录：关于重启阶段的笔记"><a href="#附录：关于重启阶段的笔记" class="headerlink" title="附录：关于重启阶段的笔记"></a>附录：关于重启阶段的笔记</h2>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>nosql</tag>
        <tag>aof</tag>
        <tag>rdb</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLAlchemy简介及在OpenStack中的使用</title>
    <url>/2015/07/sqlalchemy-intro/</url>
    <content><![CDATA[<p>SQLAlchemy是Python编程语言下的一款开源软件，提供了SQL工具包及对象关系映射(ORM)工具。</p>
<h2 id="web编程之orm"><a href="#web编程之orm" class="headerlink" title="web编程之orm"></a>web编程之orm</h2><p>在编写web服务时，我们通常使用orm，而不是直接使用SQL与数据库进行交互。<br>如果使用Django等比较全面的框架，可以选择默认的ORM。但如果选择flask等轻量级框架，则需要自己选择ORM。同时，自己选择使用ORM也带来了更大的灵活性。<br><a id="more"></a></p>
<h3 id="orm是什么"><a href="#orm是什么" class="headerlink" title="orm是什么"></a>orm是什么</h3><p>以下节选自wikipeida：</p>
<blockquote>
<p>Object-relational mapping (ORM, O/RM, and O/R mapping tool) in computer science is a programming technique for converting data between incompatible type systems in object-oriented programming languages.</p>
</blockquote>
<p>以下节选自百度百科：</p>
<blockquote>
<p>对象关系映射（英语：Object Relation Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。</p>
</blockquote>
<p>实际项目中，我们主要使用orm作为与数据库等进行实际交互的工具。</p>
<h3 id="为什么使用orm"><a href="#为什么使用orm" class="headerlink" title="为什么使用orm"></a>为什么使用orm</h3><p>与直接使用sql访问数据库相比，其有以下好处：</p>
<ul>
<li>代码的简洁性，对存储层的通用封装<br>使用orm，操作数据库往往仅需要简单的几条语句，使代码变得简洁。</li>
<li>数据源的兼容性<br>orm往往对多种数据库、数据源进行通用的封装，从而使得编写一套代码，适用于不同的数据源变得可能。</li>
<li>操作的安全性<br>直接使用sql操作数据库，往往会因为开发人员疏忽引入sql注入等安全问题。而使用orm，能避免此问题。</li>
<li>操作语句的高效性<br>orm的封装是众多开发人员智慧的结晶，其中往往已经对生成的sql语句进行了优化，使得一般语句的性能比较高效，而开发人员不需要再去考虑性能问题。但orm一般是通用的解决方案，无法针对所有场景进行优化，特殊场景下其生成的sql语句可能会非常低效，因此需要在实际使用时进行监控并酌情优化。</li>
</ul>
<h2 id="简介及特性"><a href="#简介及特性" class="headerlink" title="简介及特性"></a>简介及特性</h2><p>SQLAlchemy的特性主要如下：</p>
<ul>
<li>Mature, High Performing Architecture DBA Approved</li>
<li>Non-Opinionated</li>
<li>Unit Of Work</li>
<li>Function-based query construction Modular and Extensible</li>
<li>Separate mapping and class design …</li>
</ul>
<p>See: <a href="http://www.sqlalchemy.org/features.html" target="_blank" rel="noopener">http://www.sqlalchemy.org/features.html</a></p>
<h2 id="安装及使用"><a href="#安装及使用" class="headerlink" title="安装及使用"></a>安装及使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>开发环境推荐使用pip安装，同时注意版本问题。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install sqlalchemy</span><br></pre></td></tr></table></figure></p>
<p>生产环境推荐使用rpm/deb安装，同时注意版本问题。<br>rpm - 版本兼容问题<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install SQLAlchemy</span><br><span class="line">apt-get install SQLAlchemy</span><br></pre></td></tr></table></figure></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>支持的2种方式:</p>
<ul>
<li>SQL Expression Language (core)</li>
<li>Object Relational Mapper (orm)</li>
</ul>
<h2 id="Core方式"><a href="#Core方式" class="headerlink" title="Core方式"></a>Core方式</h2><p>(raw sql、sql expression)<br>对于绝大多数应用, 推荐使用SqlAlchemy. 即使是使用raw sql,<br>SqlAlchemy 也可以带来如下好处:</p>
<ul>
<li>内建数据库连接池</li>
<li>强大的log功能</li>
</ul>
<p>SqlAlchemy的sql expression和raw sql的比较:</p>
<ul>
<li>sql expression 写法是纯python代码, 阅读性更好</li>
<li>raw sql 比 sql expression 更灵活, 如果SQL很复杂, 更有优势了</li>
</ul>
<h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">engine_str = <span class="string">"mysql:mysql://root:root@localhost/django_sqla"</span></span><br><span class="line">engine = create_engine(engine_str, echo=<span class="literal">True</span>)</span><br><span class="line">conn = engine.connect()</span><br></pre></td></tr></table></figure>
<h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Table objects <span class="keyword">and</span> its children <span class="keyword">as</span> metadata Table Column(String, Integer…)</span><br><span class="line">Create tables within the engine</span><br></pre></td></tr></table></figure>
<h3 id="Insert-expression"><a href="#Insert-expression" class="headerlink" title="Insert expression"></a>Insert expression</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ins2=users.insert() <span class="comment">#anexpression</span></span><br><span class="line">result2 = conn.execute(ins2, id=<span class="number">2</span>, name=’wendy’, fullname=’Wendy Williams’) <span class="comment"># execute</span></span><br><span class="line">Multiple inserts: conn.execute(ins2, a_list)</span><br></pre></td></tr></table></figure>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">users.update().values(&#123;…&#125;).where(…)</span><br></pre></td></tr></table></figure>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>同上</p>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = select([users]) <span class="keyword">or</span> s = users.select()</span><br><span class="line">result = conn.execute(s)</span><br><span class="line">result.fetchone()</span><br><span class="line">result.close()</span><br></pre></td></tr></table></figure>
<h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sqlalchemy allows using string</span><br><span class="line">s = text(“””Hello”””)</span><br></pre></td></tr></table></figure>
<h2 id="orm方式"><a href="#orm方式" class="headerlink" title="orm方式"></a>orm方式</h2><h3 id="Declare-a-Mapping"><a href="#Declare-a-Mapping" class="headerlink" title="Declare a Mapping"></a>Declare a Mapping</h3><p>declarative_base: define classes and mapping to tables<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Base = declarative_base()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = ‘users’</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<h3 id="MetaData"><a href="#MetaData" class="headerlink" title="MetaData"></a>MetaData</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Base.metadata.create_all(engine)</span><br></pre></td></tr></table></figure>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>事务<br>using session to handle orm’s action<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Session = sessionmaker(bind=engine)</span><br><span class="line">session = Session()</span><br></pre></td></tr></table></figure></p>
<h3 id="Connection-pool"><a href="#Connection-pool" class="headerlink" title="Connection pool"></a>Connection pool</h3><h3 id="Add-insert"><a href="#Add-insert" class="headerlink" title="Add(insert)"></a>Add(insert)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ed_user = User(<span class="string">'ed'</span>, <span class="string">'Ed Jones'</span>, <span class="string">'edspassword'</span>)</span><br><span class="line">session.add(ed_user)</span><br><span class="line">session.add_all([...])</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>
<h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = session.query(User).filter(User.name==‘ed<span class="string">')</span></span><br><span class="line"><span class="string">result[0].name, result[0][0]</span></span><br></pre></td></tr></table></figure>
<h3 id="Relationship"><a href="#Relationship" class="headerlink" title="Relationship"></a>Relationship</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span><span class="params">(Base)</span></span></span><br><span class="line">__tablename__ = ‘addresses’</span><br><span class="line">...</span><br><span class="line">user_id = Column(Integer, ForeignKey(<span class="string">'users.id'</span>)) user = relationship(<span class="string">"User"</span>,</span><br><span class="line">backref=backref(<span class="string">'addresses'</span>, order_by=id))</span><br></pre></td></tr></table></figure>
<h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>Alembic<br><a href="http://blog.csdn.net/ying_593254979/article/details/10189799" target="_blank" rel="noopener">参考</a></p>
<h2 id="OpenStack中的使用"><a href="#OpenStack中的使用" class="headerlink" title="OpenStack中的使用"></a>OpenStack中的使用</h2><p>wsgi框架+SQLAlchemy</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>版本兼容问题<br>rpmbuild</p>
<h2 id="参考索引"><a href="#参考索引" class="headerlink" title="参考索引"></a>参考索引</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Object-relational_mapping" target="_blank" rel="noopener">orm in wiki</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>web</tag>
        <tag>orm</tag>
        <tag>sqlalchemy</tag>
      </tags>
  </entry>
</search>
