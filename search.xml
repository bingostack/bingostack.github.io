<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>buildbot实战</title>
    <url>/2014/11/buildbot-in-action/</url>
    <content><![CDATA[<p><a href="http://buildbot.net/" target="_blank" rel="noopener">Buildbot</a>是一套基于python的的持续集成系统，可方便的进行自动化构建、部署、测试和发布。类似于Jenkins，但更轻量化且易于直接使用python进行扩展。Chrome社区就使用的buildbot作为其CI系统。<br>类似于Jenkins，buildbot在一个CI系统中扮演的更多是一个任务执行者的角色，其工作流程如下：</p>
<ul>
<li>监控代码仓库</li>
<li>代码仓库有变化后，立即拉取代码</li>
<li>执行build、部署、测试及发布工作</li>
<li>反馈结果</li>
</ul>
<p>我们对这样一个工具的一般要求为：</p>
<ul>
<li>轻量级，安装、配置简单，本身耗费资源较少</li>
<li>高效率，较快的完成自动化任务</li>
<li>通用性强，在不同的操作系统，甚至与不同的代码系统兼容</li>
<li>易扩展、配置及管理，能较简单的配置自动化任务</li>
</ul>
<p>Buildbot和Jenkins都能很好的满足我们这些要求。但相比Jenkins，buildbot更轻量级，部署配置更为简单。<br>Web界面也更简单美观一些。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>buildbot架构比较简单，主要分为三部分：</p>
<ul>
<li>版本控制层<br>外部版本控制，通过插件或主动触发的方式触发buildbot执行任务。</li>
<li>任务执行层<br>master接收任务后，调度其slave执行任务，并获取到返回的结果</li>
<li>通知层<br>master获取结果后，可通过邮件、IRC等方式进行通知。</li>
</ul>
<p>其中重要的主体是master和slave，其主要采用星形拓扑结构，一个集群中可以多个master、多个slave。master主要负责任务接收、调度并通知任务，slave负责具体的任务执行。各节点本身无状态，横向扩展性很好。<br><a id="more"></a><br><img src="/img/buildbot-overview.png" alt="buildbot架构"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>建议使用pip安装，避免麻烦的依赖问题。<br>同时当前对python3版本支持不太好，建议使用python2.7版本：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install gcc python-devel </span><br><span class="line">yum install python-dateutil15 git expect</span><br><span class="line"><span class="comment"># master安装</span></span><br><span class="line">pip install buildbot</span><br><span class="line"><span class="comment"># salve安装</span></span><br><span class="line">pip install buildbot-slave</span><br></pre></td></tr></table></figure></p>
<p>如果是python2.6的话，因为最新版本的Twisted需要python2.7，所以需要提前指定版本安装：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install Twisted==15.1.0</span><br></pre></td></tr></table></figure></p>
<p>为充分利用资源，同一台机器可配置为多个master、slave：可使用不同用户或virtualenv，每个用户或virtualenv环境部署为一个节点。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure></p>
<h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><p>最近看到<a href="http://docs.buildbot.net/current/tutorial/docker.html" target="_blank" rel="noopener">buildbot官方</a>给出了Dockerfile(但Dockerfile地址是错的，可以自行在github代码中查找)，可下载后自行构建镜像使用，运行后即可使用：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Download Buildbot Dockerfile.</span></span><br><span class="line">wget https://raw.githubusercontent.com/buildbot/buildbot/master/master/Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build the Buildbot container (it will take a few minutes to download packages)</span></span><br><span class="line">docker build -t buildbot - &lt; Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run buildbot</span></span><br><span class="line">CONTAINER_ID=$(docker run -d -p 8010:8010 -p 22 buildbot)</span><br></pre></td></tr></table></figure></p>
<p>然后打开<a href="http://localhost:8010" target="_blank" rel="noopener">http://localhost:8010</a>即可。</p>
<h2 id="创建及运行"><a href="#创建及运行" class="headerlink" title="创建及运行"></a>创建及运行</h2><h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">buildbot create-master master</span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">mv master/master.cfg.sample master/master.cfg</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">buildbot start master</span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">tail -f master/twistd.log</span><br></pre></td></tr></table></figure>
<p>buildbot会在当前目录下创建master名称的目录，以上为<code>master</code>。<br>看到最后显示<code>BuildMaster is running</code>即为启动成功，此时可通过<a href="http://localhost:8010" target="_blank" rel="noopener">http://localhost:8010</a>访问，默认用户名密码都是<code>pyflakes</code>。</p>
<h3 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h3><p>创建slave时需要指定mater的地址，或者修改配置文件指定。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">buildslave create-slave slave1 localhost:9989 slave1 pass</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">buildslave start slave</span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">tail -f slave/twistd.log</span><br></pre></td></tr></table></figure></p>
<p>create-slave的参数分布是：slave目录、master、名字、密码。其中master默认都采用9989与slave通信。名字、密码必须与master的master.cfg中配置的一致：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c[<span class="string">'slaves'</span>] = [buildslave.BuildSlave(<span class="string">"example-slave"</span>, <span class="string">"pass"</span>)]</span><br></pre></td></tr></table></figure></p>
<h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p>此时打开<a href="http://localhost:8010" target="_blank" rel="noopener">http://localhost:8010</a>即可看到如下页面：<br><img src="/img/buildbot-index.png" alt="buildbot预览"><br>其中Buildslaves页面可查看到我们新添加的example-slave，且状态为<code>Idle</code>。<br>而Waterfall页面可查看到当前的builder，目前只有runtest，点进去点击forcebuild即可进行测试build。成功后记录显示为绿色。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Buildbot的配置文件为<code>.cfg</code>后缀的python脚本，使用python语法。如上文slave的定义就是一个python list的定义。</p>
<h3 id="master配置"><a href="#master配置" class="headerlink" title="master配置"></a>master配置</h3><p>主要配置如下。</p>
<ul>
<li>BUILDSLAVES<br>slave的定义，以list的形式呈现。需要主要名字和密码与slave一致。<br>其中protocols可定义与slave的通信方式，包括端口等。</li>
<li><p>CHANGESOURCES<br>指定需要监控的源代码地址。格式如下，其中可指定git地址、工作目录、分支、监控周期等。可定义多个，每个append进list即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c[&apos;change_source&apos;] = []</span><br><span class="line">c[&apos;change_source&apos;].append(changes.GitPoller(</span><br><span class="line">        &apos;git://github.com/buildbot/pyflakes.git&apos;,</span><br><span class="line">        workdir=&apos;gitpoller-workdir&apos;, branch=&apos;master&apos;,</span><br><span class="line">        pollinterval=300))</span><br></pre></td></tr></table></figure>
</li>
<li><p>SCHEDULERS<br>scheduler指定何时、如何触发执行builder，其中builder在BUILDERS中定义。下文定义了两个scheduler：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c[<span class="string">'schedulers'</span>] = []</span><br><span class="line"><span class="comment"># 定义每小时运行的scheduler</span></span><br><span class="line">hourlyscheduler = Periodic(name = <span class="string">"hourly"</span>,</span><br><span class="line">                           builderNames = [<span class="string">"simplebuild"</span>],</span><br><span class="line">                           periodicBuildTimer = <span class="number">3600</span>)</span><br><span class="line"><span class="comment"># 定义手动触发的scheduler</span></span><br><span class="line">c[<span class="string">'schedulers'</span>].append(schedulers.ForceScheduler(</span><br><span class="line">                            name=<span class="string">"force"</span>,</span><br><span class="line">                            builderNames=[<span class="string">"master"</span>]))</span><br></pre></td></tr></table></figure>
</li>
<li><p>BUILDERS<br>builder定义具体执行的任务内容，由一系列的步骤组成。每个步骤定义在step中，factory包含一系列的step，builder通过指定factory等参数创建。可定义多个builder。<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义factory</span></span><br><span class="line">factory = util.BuildFactory()</span><br><span class="line"><span class="comment"># 定义具体step</span></span><br><span class="line">factory.addStep(steps.Git(repourl=<span class="string">'git://github.com/buildbot/pyflakes.git'</span>, mode=<span class="string">'incremental'</span>))</span><br><span class="line">factory.addStep(steps.ShellCommand(command=[<span class="string">"trial"</span>, <span class="string">"pyflakes"</span>]))</span><br><span class="line"><span class="comment"># 创建builder</span></span><br><span class="line">c[<span class="string">'builders'</span>] = []</span><br><span class="line"><span class="comment"># 指定名称、使用的slave、factory</span></span><br><span class="line">c[<span class="string">'builders'</span>].append(</span><br><span class="line">    util.BuilderConfig(name=<span class="string">"master"</span>,</span><br><span class="line">      slavenames=[<span class="string">"master"</span>],</span><br><span class="line">      factory=factory))</span><br></pre></td></tr></table></figure>
</li>
<li><p>STATUS TARGETS<br>此处定义buildbot对外通知build信息的方式。最基本的方式就是显示在页面中，因此此处同时定义了页面的认证方式，即登录使用的用户名、密码在此处修改。同时可定义IRC、邮件等通知方式。</p>
</li>
<li>PROJECT IDENTITY<br>此处主要为buildbot的基本信息，如title、超链接、url等。</li>
<li>DB URL<br>此处定义使用的数据库，默认使用sqlite，地址为本地文件路径。</li>
</ul>
<h3 id="配置slave"><a href="#配置slave" class="headerlink" title="配置slave"></a>配置slave</h3><p>slave的定义主要在<code>buildbot.tac</code>文件中，可用于定义使用的master及slave基本信息。</p>
<h2 id="启动及使用"><a href="#启动及使用" class="headerlink" title="启动及使用"></a>启动及使用</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul>
<li>启动<br>master、slave的启动上文已提及，子命令为start，参数为路径。</li>
<li>停止、重启<br>stop和restart，其余同start</li>
<li>master重新加载配置<br><code>buildbot reconfig master</code>即可重新加载配置。</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>平时比较常用手动触发build，即forcebuild：web页面登录-&gt;Builders-&gt;选择builder-&gt;Force Build-&gt;在Waterfall查看打包结果及详细日志。<br><img src="/img/buildbot-waterfall.png" alt="buildbot waterfall"><br>注意：只有登录后才有build权限。</p>
<h3 id="各页面介绍"><a href="#各页面介绍" class="headerlink" title="各页面介绍"></a>各页面介绍</h3><p>Buildbot比较方便的一点是全部通过页面来进行操作。主要页面介绍如下：</p>
<ul>
<li>Waterfall，以瀑布流的方式显示build任务，可点击任务查看详情、执行操作等</li>
<li>Grid/T-Grid，以对应的方式显示build任务</li>
<li>Console，还在开发中，当前主要显示revision信息</li>
<li>Builders，定义的所有builder</li>
<li>Recent Builds，最近的build</li>
<li>Buildslaves，定义的所有slave</li>
<li>Changesources，定义的所有代码仓库</li>
<li>JSON API，对外提供的JSON API文档</li>
</ul>
<h2 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h2><h3 id="多分支build"><a href="#多分支build" class="headerlink" title="多分支build"></a>多分支build</h3><p>定义一个Changesource。<br>定义多个schedulers，分别对应不同分支。<br>定义多个factory，其中的step除branch不同外，其余step通用。通用的step可一次定义，多次使用。<br>builder分别指定分支和factory。</p>
<h3 id="多项目build"><a href="#多项目build" class="headerlink" title="多项目build"></a>多项目build</h3><p>新版本可使用此功能，但不太推荐。buildbot的一个master还是更多的擅长对一个项目的管理。<br>需要定义多个Changesource，然后在其它定义时通过<code>project</code>和<code>repository</code>参数指定项目。</p>
<h3 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h3><p>通过检查step的返回结果判断是否执行成功，规则同shell：0为成功，其它失败。<br>因此如果step中调用了自己的脚本，需要保证按上述规则返回结果。</p>
<h3 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h3><p>使用<code>util.Property</code>获得网页上指定的参数，可设置默认值：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">factory.addStep(steps.ShellCommand(command=[<span class="string">"bash"</span>, <span class="string">"autorpm.sh"</span>, util.Property(<span class="string">'project'</span>, default=<span class="string">''</span>)]))</span><br></pre></td></tr></table></figure></p>
<p>在build页面通过name/value指定，如：<br><img src="/img/buildbot-param.png" alt="buildbot指定参数"></p>
<h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><p>实际使用中发现，buildslave所创建的文件，权限都为600或700。<br>这样会造成如cp到apache目录时，apache无法读取文件。<br>通过官方文档查看到slave启动时有umask选项：</p>
<blockquote>
<p>–umask<br>This is a string (generally an octal representation of an integer) which will cause the buildslave process’ umask value to be set shortly after initialization.<br>The twistddaemonization utility forces the umask to 077 at startup (which means that all files created by the buildslave or its child processes will be unreadable by any user other than the buildslave account).<br>If you want build products to be readable by other accounts, you can add –umask=022 to tell the buildslave to fix the umask after twistd clobbers it.<br>If you want build products to be writable by other accounts too, use –umask=000, but this is likely to be a security problem.</p>
</blockquote>
<p>通过修改slave目录下的buildbot.tac，修改：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umask = 022</span><br></pre></td></tr></table></figure></p>
<p>然后重启slave解决此问题:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">buildbot stop slave1</span><br><span class="line">buildbot stop slave2</span><br></pre></td></tr></table></figure></p>
<h2 id="参考索引"><a href="#参考索引" class="headerlink" title="参考索引"></a>参考索引</h2><ul>
<li><a href="https://build.chromium.org/p/chromium/console" target="_blank" rel="noopener">chromium buildbot</a></li>
<li><a href="http://docs.buildbot.net/current/tutorial/docker.html" target="_blank" rel="noopener">docker安装buildbot</a></li>
<li><a href="http://docs.buildbot.net/current/tutorial/tour.html" target="_blank" rel="noopener">quick tour of buildbot</a></li>
<li><a href="http://docs.buildbot.net/current/tutorial/fiveminutes.html" target="_blank" rel="noopener">Buildbot in 5 minutes</a></li>
</ul>
]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>openstack</tag>
        <tag>ci</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之十三：curl vs wget</title>
    <url>/2012/09/curl-vs-wget/</url>
    <content><![CDATA[<p>curl和wget有很多地方是相同的，很多场景下二者都可以使用。那面对一个复杂问题的时候，我们怎么决定使用哪个工具呢？本篇通过对二者进行比较，从而对此提供思路。<br>本篇主要参考<a href="http://daniel.haxx.se/docs/curl-vs-wget.html" target="_blank" rel="noopener">curl官方的文档</a>，翻译加整理。</p>
<h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ul>
<li>都是可通过FTP/HTTP/HTTPS协议下载文件的命令行工具；</li>
<li>都可以发送HTTP POST请求；</li>
<li>都支持cookie的使用；</li>
<li>都被设计为无界面（UI），可在如脚本中使用；</li>
<li>都是开源且免费的软件。</li>
</ul>
<a id="more"></a>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><ul>
<li>curl是基于libcurl库实现，因此特性来源于libcurl库。libcurl库跨平台、开源且免费，因此curl不只是一个命令行工具</li>
<li>管道。curl在传统的UNIX风格的基础上加以扩展，对输入输出做出更多的处理，从而贯彻了”everything is a pipe” 的设计思想。</li>
<li>单点传送（Single shot）。curl被设计为用于数据的单点传送。它只会传送用户指定的URLS，并不包含任何递归下载的逻辑，也不对html进行任何解析。</li>
<li>更多协议支持。目前curl 支持的协议有： FTP, FTPS, HTTP, HTTPS, SCP, SFTP, TFTP, TELNET, DICT, LDAP, LDAPS, FILE, POP3, IMAP, SMTP 和 RTSP 。Wget仅仅支持 HTTP, HTTPS 和 FTP。（协议的支持情况可能会随着时间发展而变化。）</li>
<li>更多平台支持，便于移植。与wget相比，curl可在更多平台上编译和运行。比如OS/400, TPF 和其他很多非UNIX的平台。</li>
<li>更强大的SSL库和SSL支持。curl能应用于多个不同的 SSL/TLS 库, 并提供了更多的可控性和对协议细节更广泛的支持。</li>
<li>curl支持更多的HTTP认证方式。尤其是当你使用HTTP代理的时候，curl支持Basic, Digest, NTLM and Negotiate认证方式（参见<a href="https://adeployblog.appspot.com/2012/08/17/http-auth-schemes.html" target="_blank" rel="noopener">HTTP认证模式</a>）。</li>
<li>libcurl库支持多种不同的SOCKS代理，基于libcurl实现的curl工具也支持。而wget不支持。</li>
<li>双向通信。 curl 提供了上传能力，Wget仅仅支持HTTP POST方式。</li>
<li>HTTP multipart/form-data 的发送能力。 这使得用户可以进行HTTP上传，更好的模拟浏览器的行为从而更大程度的实现HTTP操作的自动化，提供了更多操作的可能。</li>
<li>压缩。 curl 支持GZIP和 inflate Content-Encoding 并且自动进行解压缩操作。</li>
<li>curl提供并执行Transfer-Encoded HTTP的解压缩，而wget不会</li>
<li>curl在7.27.0之后，提供对<a href="http://en.wikipedia.org/wiki/Metalink" target="_blank" rel="noopener">metalink</a>的支持（好吧，百度百科对metalink的解释是不对的， 百度百科说的是oracle公司的一个服务）。而wget需要依靠一个Google Summer开源项目才能支持metalink。</li>
</ul>
<h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><ul>
<li>wget仅仅是一个命令行工具。没有库提供使用。</li>
<li>递归下载支持。wget相比curl最大的优点在于对递归下载的支持，甚至下载一个资源如网页或FTP目录指向的所有资源。</li>
<li>wget下载时无需指定保存文件名。而curl需要使用-o或-O指定。</li>
<li>wget仅支持GnuTLS 和 OpenSSL两种SSL库。</li>
<li>wget仅支持HTTP代理的基本认证（Basic auth）。</li>
<li>wget不支持SOCKS代理。</li>
<li>wget项目更老，基于GPL开源协议，隶属GNU项目。curl基于MIT开源协议，不隶属于任何组织，版权由作者一人所有。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>wput仅是一个单独的工具，不进行讨论。<br>参考：<a href="http://daniel.haxx.se/docs/curl-vs-wget.html" target="_blank" rel="noopener">curl vs Wget</a></p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
        <tag>wget</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之十二：ftp及其他协议</title>
    <url>/2012/08/curl-ftp-usage/</url>
    <content><![CDATA[<p>在<a href="http://stackeye.com/2012/07/linux-curl-description/" target="_blank" rel="noopener">Linux下cURL使用教程之一：cURL简介</a>里，提到curl支持多种协议。本篇就以ftp协议为主，对curl对其他协议的操作进行简介。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>基本使用方法同HTTP没有区别：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl ftp://ftp.cisco.com/pub/mibs/</span><br></pre></td></tr></table></figure></p>
<p>只不过ftp一般会有用户名密码，所有在命令中要加上用户名密码：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u ftpuser:ftppass -O ftp://ftp_server/index.php</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl ftp:// ftpuser:ftppass ftp://ftp_server/index.php</span><br></pre></td></tr></table></figure></p>
<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>使用-T选项。具体请参考<a href="https://adeployblog.appspot.com/2012/08/11/linux-curl-basic-usage-upload-file.html" target="_blank" rel="noopener">Linux下cURL使用教程之六：curl基本使用之HTTP文件上传</a>。<a id="more"></a><br>上传一个文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u ftpuser:ftppass -T myfile.txt ftp://ftp.testserver.com</span><br></pre></td></tr></table></figure></p>
<p>上传多个文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u ftpuser:ftppass -T <span class="string">"&#123;file1,file2&#125;"</span> ftp://ftp.testserver.com</span><br></pre></td></tr></table></figure></p>
<p>从标准输入获得文件内容：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u ftpuser:ftppass -T - ftp://ftp.testserver.com/myfile_1.txt</span><br></pre></td></tr></table></figure></p>
<p>这个命令会将标准输入的内容保存在<a href="ftp://ftp.testserver.com/myfile_1.txt中。" target="_blank" rel="noopener">ftp://ftp.testserver.com/myfile_1.txt中。</a></p>
<h2 id="FTP四种模式"><a href="#FTP四种模式" class="headerlink" title="FTP四种模式"></a>FTP四种模式</h2><p>FTP有两种基本模式：PASV和PORT，也即主动模式和被动模式。在二者基础上分别有两种扩展：ERSV和EPRT。具体请参考相关RFC文档。<br>curl默认使用EPSV模式：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --verbose ftp://ftp_server/ --user user</span><br></pre></td></tr></table></figure></p>
<p>会看到curl执行了EPSV命令。–eprt参数显式指定使用EPRT模式。<br>使用<code>--disable-epsv</code>选项禁用EPSV而使用PASV：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --verbose --<span class="built_in">disable</span>-epsv ftp://ftp_server/ --user user</span><br></pre></td></tr></table></figure></p>
<p>使用<code>-P/--ftp-port &lt;address&gt;</code>选项指定使用EPRT，其中address参数可以指定为“-”，指定使用FTP控制连接相同的地址：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --verbose --ftp-port - ftp://ftp_server/ --user user</span><br></pre></td></tr></table></figure></p>
<p>会看到使用了EPRT命令。<br>而使用<code>--disable-epsv</code>选项，如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --verbose --ftp-port - --<span class="built_in">disable</span>-epsv ftp://ftp_server/ --user user</span><br></pre></td></tr></table></figure></p>
<p>及指定了使用PORT模式。</p>
<h2 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h2><p>以SMTP协议发邮件为例，执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --verbose --ssl --mail-rcpt <span class="built_in">test</span>@163.com --mail-from <span class="built_in">test</span>@163.com smtp://smtp.163.com -u <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<p>–ssl指定使用SSL， smtp://一定要加在url上，否则curl会使用默认的HTTP协议。</p>
<p>之后，按提示输入如下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Subject: Testing</span><br><span class="line">This is a test mail</span><br><span class="line">.</span><br></pre></td></tr></table></figure></p>
<p>即可发送邮件。<br>但是估计是有防作弊机制，测试发现163、GMAIL的SMTP发信都失败，提示“curl: (67) Access denied: 500”，追踪详细过程，发现是“MAIL FROM: <a href="mailto:test@163.com" target="_blank" rel="noopener">test@163.com</a>”这句提示语法错误。不知道是什么原因。<br>但是使用自己搭建的邮件服务器测试成功。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>网关类产品的性能测试之一：简介及性能指标介绍</title>
    <url>/2013/03/gateway-performance-test-desc/</url>
    <content><![CDATA[<p>本文所指的网关类产品，是指实际拓扑中会被部署作为网关的产品，典型的如路由器/交换机、防火墙、IDS/IPS、UTM、NGFW等。<br>但是性能测试中很多种类，对于大多数产品其实是相通的，因此对其它产品的性能测试也有参考价值。<br>文章主要面向的对象为性能测试及性能调优人员，同时对选购产品的潜在客户有指导意义。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于网关类产品性能和稳定性是前提。如今各种NGFW、应用防火墙等概念不断涌现，各大厂商反复在功能的丰富性上做文章，但所有这些只能算作锦上添花，只有产品的性能与稳定性才是真正的根基。对于任何网络环境，如果网关的吞吐小于实际需要的带宽值，必将是一场灾难。而更多的功能导致数据包经过的路径更长，对性能带来了更严峻的挑战。同时，稳定性和性能往往是相关的，且性能测试更标准。<br>因此客户评价网关产品的优劣，除了产品所支持功能以外，更关注的指标就是性能。另外，现在市场上大部分的网络安全类产品或者网关类产品在功能和协议的支持上，同质化较为严重，客户在选取时，性能指标就成为衡量的一个很重的指标项。<br>产品的性能指标不仅客户非常关注，设备厂商在向市场发布产品时，性能指标也会做为重点进行宣传，正面PK。由此可见性能指标对于网关类产品的重要性。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>此系列文章将介绍业界较为常用的性能指标及测试方法。因篇幅较长，为竭尽所能说的更清楚明白，将本系列分为以下四部分：</p>
<ol>
<li>简介及性能指标介绍 - 本篇</li>
<li><a href="http://stackeye.com/2013/03/gateway-performance-test-rfc2544/" target="_blank" rel="noopener">RFC2544四项指标测试方法</a></li>
<li><a href="http://stackeye.com/2013/03/gateway-performance-test-others/" target="_blank" rel="noopener">其它指标测试方法</a></li>
<li><a href="http://stackeye.com/2013/04/gateway-performance-test-tools/" target="_blank" rel="noopener">测试工具、注意事项及经验总结</a></li>
</ol>
<a id="more"></a>
<h2 id="性能测试简介"><a href="#性能测试简介" class="headerlink" title="性能测试简介"></a>性能测试简介</h2><p>以下解释来自百度百科：</p>
<blockquote>
<p>性能测试是通过自动化的测试<strong>工具</strong>模拟多种正常、峰值以及异常<strong>负载</strong>条件来对系统的各项性能指标进行测试。负载测试和压力测试都属于性能测试，两者可以结合进行。通过负载测试，确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。压力测试是通过确定一个系统的<strong>瓶颈</strong>或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。</p>
</blockquote>
<p>其中有三个关键词需要关注：</p>
<ul>
<li>工具：性能测试一般需要的压力较大较复杂，单纯依靠手工很难做到，因此一般需要专业化的设备、工具，或编写自动化测试脚本完成。网关类产品一般要求的负载较高，在千兆、万兆设置更高级别，一般需要专业配置千兆万兆网卡的硬件设备，如IAXA等，价格较昂贵。而其它产品一般也需要如Loadruner、Jmeter等专业化的性能测试软件并根据场景编写脚本完成。</li>
<li>负载：性能测试有别于功能测试的点就在于使用的负载较高。而且负载的构造需要根据实际的场景才有价值，并需要使用特定的工具或自行研发软件实现。</li>
<li>瓶颈：逐渐加大负载到达瓶颈。测试中比较重要的就是各个性能拐点，因为各个拐点往往都有重要的意义。如保持最优响应的拐点、延迟急剧增加的拐点、系统彻底瘫痪的拐点。持续测试找到各个拐点，对于产品的调优、部署及运维都有很大的价值。<br><img src="/img/jmeter-result.png" alt="性能测试结果"></li>
</ul>
<h2 id="术语介绍"><a href="#术语介绍" class="headerlink" title="术语介绍"></a>术语介绍</h2><p>文章中会涉及到一些术语，现总结如下，供参考。</p>
<ul>
<li>性能测试，对产品负载压力承受能力的测试。</li>
<li>RFC，互联网及软件等的一些标准，基本的互联网通信协议都有在RFC文件内详细说明。</li>
<li>网关类产品，部署作为网关的设备及软件。</li>
<li>IDS，入侵检测系统</li>
<li>IPS，入侵防御系统</li>
<li>UTM，对防火墙、IDS\、IPS三个的综合，可以比较全面的进行管理。但是UTM通过一台物理设备集成大量功能，导致了应对大量数据的时候效率会下降，同时存在设备损坏导致全面崩溃的可能。</li>
<li>NGFW，下一代防火墙，安全设备类产品未来的发展方向。</li>
<li>DUT，devices under test，测试设备。</li>
</ul>
<h2 id="性能指标名词解释"><a href="#性能指标名词解释" class="headerlink" title="性能指标名词解释"></a>性能指标名词解释</h2><p>网络安全类产品或网关类产品常见的性能指标有：</p>
<ul>
<li>RFC2544 四项值（吞吐量、延迟、丢包率、背靠背）</li>
<li>TCP 的每秒新建连接数（CPS）</li>
<li>HTTP 的每秒处理事务数（TPS）、HTTP 有效吞吐量（HTTP Throughput）</li>
<li>最大并发连接数等</li>
</ul>
<p>除此之外，部分评测机构或客户也会根据自己的实际情况增加性能指标，如：IPS/UTM下的HTTP有效吞吐量和每秒新建，Mail协议（SMTP/POP3/IMAP）的有效吞吐量和新建，特殊场景的混合流量（如加入恶意流量）的吞吐量等。<br>可参考业界标杆Fortinet的<a href="https://www.fortinet.com/content/dam/fortinet/assets/data-sheets/Fortinet_Product_Matrix.pdf" target="_blank" rel="noopener">性能测试报告</a>。<br><img src="/img/fortinet-product-matrix-sample.png" alt="Fortinet product matrix"></p>
<p>下面我们先认识一下各性能指标名词的含义。本篇只介绍各名词的含义，测试方法后续章节中说明。</p>
<h3 id="RFC2544-四项值"><a href="#RFC2544-四项值" class="headerlink" title="RFC2544 四项值"></a>RFC2544 四项值</h3><p><a href="https://tools.ietf.org/html/rfc1242" target="_blank" rel="noopener">RFC1242</a>文档中定义了吞吐量（Throughput）、延迟（Latency）、丢包率（Frame Loss）、背靠背（Back-to-Back）四个标准术语。<br><a href="https://www.ietf.org/rfc/rfc2544.txt" target="_blank" rel="noopener">RFC2544</a>是RFC组织提出的用于评测网络互联设备（防火墙、IDS、交换机路由器等）的国际标准，其中主要对RFC1242 中定义的性能评测参数的具体测试方法、结果的提交形式作了较详细的规定。</p>
<p>下面将对这四项值是做为重点进行介绍。</p>
<h4 id="吞吐量（Throughput）"><a href="#吞吐量（Throughput）" class="headerlink" title="吞吐量（Throughput）"></a>吞吐量（Throughput）</h4><p>吞吐量是指被测设备在不丢包的情况下，所能转发的最大速率或最大流量。通常测试结果以每秒通过的最大数据包数（PPS）或比特数（Mb/s）。<br>用于反映被测设备所能够处理的最大的数据流量，重在测试被测设备的转发能力。<br>结果值越大越好。<br>吞吐量比较通用，适用于绝大多数软件系统的性能测试。</p>
<h4 id="延迟（Latency）"><a href="#延迟（Latency）" class="headerlink" title="延迟（Latency）"></a>延迟（Latency）</h4><p>发送一定数量的数据包，记录中间数据包发出的时间T1，以及经由被测设备转发后到达接收端口的时间T2：Latency＝T2－T1。延迟的测试结果以毫秒（ms）或微秒（μs）表示。<br>测试延迟是在测试过程中不存在丢包的条件下进行的，也就是说在测试延迟时，先要知道被测设备的吞吐量，从而定义发包的速率。<br>延迟用于反映被测设备处理数据包的速度。<br>延迟越小，表明设备处理速度越快。<br>延迟比较通用，是大多数软件系统性能测试的重要指标。</p>
<h4 id="丢包率（Frame-Loss）"><a href="#丢包率（Frame-Loss）" class="headerlink" title="丢包率（Frame Loss）"></a>丢包率（Frame Loss）</h4><p>丢包率是指在一定的负载下，由于缺乏资源而未能被转发的包占应该转发的包数的百分比。<br>用于反映被测设备承受特定负载能力。<br>结果值越小越好。</p>
<h4 id="背靠背（Back-to-Back）"><a href="#背靠背（Back-to-Back）" class="headerlink" title="背靠背（Back-to-Back）"></a>背靠背（Back-to-Back）</h4><p>以能够产生的最大的速率，发送一定长度的数据包，并不断改变单次发送的数据包数目，直到被测设备能够完全转发所有发送的数据包而不丢包，这个包数就是该设备的背对背值。<br>用于反映被测设备处理突发数据的缓存能力。背对背的值越大，路由器的缓存能力就越强，处理突发数据包的能力越强。</p>
<h3 id="TCP每秒新建连接数（CPS）"><a href="#TCP每秒新建连接数（CPS）" class="headerlink" title="TCP每秒新建连接数（CPS）"></a>TCP每秒新建连接数（CPS）</h3><p>TCP每秒新建是在业界提到最多的一个。这个性能指标出自<a href="https://www.ietf.org/rfc/rfc3511.txt" target="_blank" rel="noopener">RFC3511</a>文档。全称是 Maximum TCP Connection Establishment Rate（最大TCP 建立速率），大家习惯将这个指标称为CPS（TCPConnection Per Second）。<br>TCP每秒新建速率是指在被测设备能够成功建立所有请求连接的条件下，所能承受的最大TCP 连接建立速度。其测试采用迭代搜索算法，每次迭代过程中，以低于被测设备所能承受的最大并发连接数发起速率不同的TCP 连接请求，直到得到所有连接成功建立的最大速率。<br>TCP每秒新建速率以连接数/秒表示结果，其值越大越好。<br>注：TCP Connection Establishment已在<a href="https://tools.ietf.org/html/rfc2647" target="_blank" rel="noopener">RFC2647</a>文档中进行定义。</p>
<h3 id="HTTP的每秒处理事务数（TPS）"><a href="#HTTP的每秒处理事务数（TPS）" class="headerlink" title="HTTP的每秒处理事务数（TPS）"></a>HTTP的每秒处理事务数（TPS）</h3><p>TPS性能指标是反映被测设备应用层的新建速率，这个性能指标也出自RFC3511文档。全称是Maximum HTTP Transaction Rate（最大HTTP传输事务速率），大家习惯将这个指标称为TPS（HTTPTransaction Per Second）。<br>HTTP的每秒事务数是指在被测设备能够成功建立连接的条件下，所能承受的最大的HTTP 协议的请求/回应操作的速度。其测试采用反复搜索过程，每次反复过程中，以低于被测设备所能承受的最大处理速率，直到所有连接被成功建立并且有对相应的请求。<br>结果以连接数/秒表示结果。其值越大越好。</p>
<h3 id="HTTP有效吞吐量（HTTP-Good-Throughput）"><a href="#HTTP有效吞吐量（HTTP-Good-Throughput）" class="headerlink" title="HTTP有效吞吐量（HTTP Good Throughput）"></a>HTTP有效吞吐量（HTTP Good Throughput）</h3><p>HTTP有效吞吐量是反映被测设备在应用层的最大传输速率，这个性能指标在RFC3511文档中没有明确描述，但可以通过将HTTP Transaction Rate调整转化为HTTP有效吞吐量的测试方法。HTTP有效吞吐量是指在被测设备能够成功建立连接的条件下，在同一时间内所能承受的最大的有效数据量。<br>测试结果值越大越好。</p>
<h3 id="最大并发连接数"><a href="#最大并发连接数" class="headerlink" title="最大并发连接数"></a>最大并发连接数</h3><p>最大并发连接数性能指标是反映被测设备最大的会话条目数，这个性能指标也出自RFC3511文档。全称是 Concurrent TCP Connection Capacity。最大并发连接数是指在被测设备能够成功建立连接的条件下，所能同时承受的最大的链接条目数，也反映了被测设备维持多个会话的能力。<br>测试结果值越大越好。</p>
<h3 id="其它性能指标项"><a href="#其它性能指标项" class="headerlink" title="其它性能指标项"></a>其它性能指标项</h3><p>在<a href="https://www.ietf.org/rfc/rfc3511.txt" target="_blank" rel="noopener">RFC3511</a>文档中主要描述了HTTP协议的性能测试，但随着产品及技术的大幅度更新，这往往已经不能满足客户或厂商的需求。我们还需要测试其它协议的性能，通常以应用层为主：包括FTP协议、Mail协议等。但测试的内容基本都是一样的，以每秒新建（每秒会话）和吞吐量为主。只需将HTTP协议变为其它应用层协议即可。</p>
<p>随着网关产品尤其是网络安全类产品的发展，性能测试的范围不再局限于防火墙功能上的性能测试，还新增加了对其它功能如IPS、AV（防病毒）和UTM（集成安全网关）等的性能测试。但可以看到，这些功能的增加对于测试过程或者测试方法而言其实没有直接的影响，仍然要使用原来的测试过程或测试方法。下篇我们将介绍具体的测试方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要是简介及测试方法的概念介绍。所有的性能指标中，RFC2544的四项指标是其中比较重要的部分且目前基本以形成标准，下篇文章将对其进行介绍。</p>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>ips</tag>
        <tag>NGFW</tag>
        <tag>防火墙</tag>
        <tag>spi firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之四：curl基本使用实例</title>
    <url>/2012/08/linux-curl-basic-usage-example/</url>
    <content><![CDATA[<p>本篇主要结合编写的PHP程序实例对上篇<a href="http://stackeye.com/2012/08/linux-curl-basic-usage/" target="_blank" rel="noopener">curl基本使用</a>进行具体说明。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h3><p>建议<code>Ubuntu+Apache+PHP</code>，方便简洁:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2 php5</span><br></pre></td></tr></table></figure></p>
<p>即可。</p>
<h3 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h3><p>以下为测试使用的服务器端代码，全部使用php实现。</p>
<ul>
<li>curldemo.php，用于输出User-Agent、Referer、Cookie信息：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">PHP Demo <span class="keyword">for</span> curl basic usage By Stackeye</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;strong&gt;User-Agent:&lt;/strong&gt;&lt;br&gt;"</span>.$_SERVER[<span class="string">'HTTP_USER_AGENT'</span>].<span class="string">"&lt;br&gt;\n"</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>($_SERVER[<span class="string">'HTTP_REFERER'</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;strong&gt;Referer:&lt;/strong&gt;&lt;br&gt;"</span>.$_SERVER[<span class="string">'HTTP_REFERER'</span>].<span class="string">"&lt;br&gt;\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>($_COOKIE[<span class="string">'user'</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;strong&gt;Cookie:&lt;/strong&gt;&lt;br&gt;user="</span>.$_COOKIE[<span class="string">'user'</span>].<span class="string">"&lt;br&gt;\n"</span>;</span><br><span class="line">        setcookie(<span class="string">"user"</span>,<span class="string">""</span>,time()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">&lt;a href=<span class="string">"http://www.stackeye.com"</span> target=<span class="string">"_blank"</span>&gt;Stackeye<span class="string">'s Blog&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>curlfollow.php，设置cookie后跳转至curldemo.php（使用js跳转，curl不会执行js函数，因此只有在浏览器中才会自动跳转）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    setcookie(<span class="string">"user"</span>,<span class="string">"Stackeye"</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;script&gt;window.location =\"curldemo.php\";&lt;/script&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>curl301.php，重定向至curldemo.php（header重定向后Referer字段为空，设置的cookie也不保存）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    Header( <span class="string">"HTTP/1.1 301 Moved Permanently"</span> ) ;</span><br><span class="line">    Header( <span class="string">"Location: curldemo.php"</span> );</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>curldeny.php，对User-Agent/Referer/cookie有严格要求，才会显示最终内容：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">CurlDeny-PHP Demo <span class="keyword">for</span> curl basic usage By Stackeye</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	I<span class="string">'ll deny all http requests,&lt;br&gt;</span></span><br><span class="line"><span class="string">	except your User-agent contains "Mozilla/4.0",&lt;br&gt;</span></span><br><span class="line"><span class="string">	your referer contains "www.baidu.com",&lt;br&gt;</span></span><br><span class="line"><span class="string">	and your cookie user is "Stackeye"!&lt;br&gt;</span></span><br><span class="line"><span class="string">	If you succeed,you will see "You finally get it"!&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;?php</span></span><br><span class="line"><span class="string">    if(strpos($_SERVER['</span>HTTP_USER_AGENT<span class="string">'],"Mozilla/4.0")!==false)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">    	echo "&lt;strong&gt;User-Agent:&lt;/strong&gt;&lt;br&gt;".$_SERVER['</span>HTTP_USER_AGENT<span class="string">']."&lt;br&gt;\n";</span></span><br><span class="line"><span class="string">    	if(isset($_SERVER['</span>HTTP_REFERER<span class="string">'])</span></span><br><span class="line"><span class="string">         &amp;&amp;strpos($_SERVER['</span>HTTP_REFERER<span class="string">'],"www.stackeye.com")!==false)</span></span><br><span class="line"><span class="string">    	&#123;</span></span><br><span class="line"><span class="string">    		echo "&lt;strong&gt;Referer:&lt;/strong&gt;&lt;br&gt;".$_SERVER['</span>HTTP_REFERER<span class="string">']."&lt;br&gt;\n";</span></span><br><span class="line"><span class="string">    		if(isset($_COOKIE['</span>user<span class="string">'])&amp;&amp;strcmp($_COOKIE['</span>user<span class="string">'],"Stackeye")==0)</span></span><br><span class="line"><span class="string">    		&#123;</span></span><br><span class="line"><span class="string">    	      echo "&lt;strong&gt;Cookie:&lt;/strong&gt;&lt;br&gt;user=".$_COOKIE['</span>user<span class="string">']."&lt;br&gt;\n";</span></span><br><span class="line"><span class="string">            setcookie("user","",time()-1);</span></span><br><span class="line"><span class="string">            echo "You finally get it!&lt;br&gt;\n";</span></span><br><span class="line"><span class="string">    		&#125;</span></span><br><span class="line"><span class="string">    		else</span></span><br><span class="line"><span class="string">    		    echo "\n&lt;br&gt;&lt;br&gt;I'</span>m sorry but you are so close!&lt;br&gt;\n<span class="string">";</span></span><br><span class="line"><span class="string">    	&#125;</span></span><br><span class="line"><span class="string">    	else</span></span><br><span class="line"><span class="string">    	    echo "</span>\n&lt;br&gt;&lt;br&gt;I<span class="string">'m sorry but you are so close!&lt;br&gt;\n";</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    else</span></span><br><span class="line"><span class="string">        echo "\n&lt;br&gt;&lt;br&gt;I'</span>m sorry but you are so close!&lt;br&gt;\n<span class="string">" ;</span></span><br><span class="line"><span class="string">?&gt;</span></span><br><span class="line"><span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;a href="</span>http:<span class="comment">//www.stackeye.com" target="_blank"&gt;Stackeye's Blog&lt;/a&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>setcookie.php，设置cookie的user字段，用以访问curldeny.php:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">SetCookie-PHP Demo <span class="keyword">for</span> curl basic usage By Stackeye</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	I just set the cookie,&lt;br&gt; </span><br><span class="line">	with which you can get the curldeny.php.&lt;br&gt;&lt;br&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    setcookie(<span class="string">"user"</span>,<span class="string">"Stackeye"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;a href=<span class="string">"http://www.stackeye.com"</span> target=<span class="string">"_blank"</span>&gt;Stackeye<span class="string">'s Blog&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上PHP文件放入服务器根目录下即可（Ubuntu+Apache下默认为<code>/var/www</code>）。以下默认服务器地址为本机127.0.0.1。</p>
<h2 id="curl访问任务"><a href="#curl访问任务" class="headerlink" title="curl访问任务"></a>curl访问任务</h2><p>使用curl命令完成如下任务。</p>
<h3 id="1-伪装成Firefox访问curldemo-php"><a href="#1-伪装成Firefox访问curldemo-php" class="headerlink" title="1. 伪装成Firefox访问curldemo.php"></a>1. 伪装成Firefox访问curldemo.php</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o curldemo.html http://127.0.0.1/curldemo.php</span><br></pre></td></tr></table></figure>
<p>保存的html文件可以用浏览器打开查看。</p>
<h3 id="2-伪装来源页面为www-stackeye-com访问curldemo-php"><a href="#2-伪装来源页面为www-stackeye-com访问curldemo-php" class="headerlink" title="2. 伪装来源页面为www.stackeye.com访问curldemo.php"></a>2. 伪装来源页面为<a href="http://www.stackeye.com访问curldemo.php" target="_blank" rel="noopener">www.stackeye.com访问curldemo.php</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -o curlex.html -e http://www.stackeye.com http://127.0.0.1/curldemo.php</span><br></pre></td></tr></table></figure>
<h3 id="3-伪装成Firefox访问curlfollow-php，并保存cookie文件"><a href="#3-伪装成Firefox访问curlfollow-php，并保存cookie文件" class="headerlink" title="3. 伪装成Firefox访问curlfollow.php，并保存cookie文件"></a>3. 伪装成Firefox访问curlfollow.php，并保存cookie文件</h3><p>然后使用保存的cookie文件，伪装成firefox，访问curldemo.php<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o curlfollow.html -D cookie001.txt http://127.0.0.1/curlfollow.php</span><br><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o curldemo.html -D cookie002.txt -b cookie001.txt http://127.0.0.1/curldemo.php</span><br></pre></td></tr></table></figure></p>
<p>curldemo.html将显示user的值为Stackeye。</p>
<h3 id="4-伪装成Firefox并直接使用cookie值访问curldemo-php"><a href="#4-伪装成Firefox并直接使用cookie值访问curldemo-php" class="headerlink" title="4. 伪装成Firefox并直接使用cookie值访问curldemo.php"></a>4. 伪装成Firefox并直接使用cookie值访问curldemo.php</h3><p>cookie中user值为Stackeye，pass值为password<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o curldemo.html -D cookie002.txt -b “user=Stackeye;pass=password” \</span><br><span class="line">http://127.0.0.1/curldemo.php</span><br></pre></td></tr></table></figure></p>
<p>curldemo.html将显示user的值为Stackeye，pass值为password。</p>
<h3 id="5-不自动跟踪重定向访问curl301-php"><a href="#5-不自动跟踪重定向访问curl301-php" class="headerlink" title="5. 不自动跟踪重定向访问curl301.php"></a>5. 不自动跟踪重定向访问curl301.php</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -v -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o curl301.html http://127.0.0.1/curl301.php</span><br></pre></td></tr></table></figure>
<p>因为此时curl301.html文件内容为空，我们只能通过-v查看具体内容。<br>可以看到curl只访问了curl301.php</p>
<h3 id="6-自动跟踪重定向访问curl301-php"><a href="#6-自动跟踪重定向访问curl301-php" class="headerlink" title="6. 自动跟踪重定向访问curl301.php"></a>6. 自动跟踪重定向访问curl301.php</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -L -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o curl301.html http://127.0.0.1/curl301.php</span><br></pre></td></tr></table></figure>
<p>此时打开curl301.html会看到curldemo.php的内容，说明curl自动根据重定向去访问了curldemo.php。</p>
<h3 id="7-访问setcookie-php和curldeny-php，使curldeny-php显示“You-finally-get-it-”"><a href="#7-访问setcookie-php和curldeny-php，使curldeny-php显示“You-finally-get-it-”" class="headerlink" title="7. 访问setcookie.php和curldeny.php，使curldeny.php显示“You finally get it!”"></a>7. 访问setcookie.php和curldeny.php，使curldeny.php显示“You finally get it!”</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o setcookie.html -D cookie001.txt http://127.0.0.1/setcookie.php</span><br><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o curldeny.html -e http://www.adeploy.com -D cookie002.txt -b cookie001.txt \</span><br><span class="line">http://127.0.0.1/curldeny.php</span><br></pre></td></tr></table></figure>
<p>打开curldeny.html文件，可看到“You finally get it!”信息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要是针对curl基本用法的实例以加深理解和掌握。实际操作中，登陆、发帖等操作还会用到提交表单相关操作，下篇将进行讲解。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP认证模式</title>
    <url>/2012/08/http-auth-schemes/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在研究curl和httpclient，用到了HTTP认证相关的知识。<br>但是搜索之后发现，网上居然没有很全面的HTTP认证模式的介绍，尤其是中文的文章。<br>因此结合MS的<a href="http://msdn.microsoft.com/en-us/library/ms789031.aspx" target="_blank" rel="noopener">Understanding HTTP Authentication</a>和<a href="http://hc.apache.org/httpcomponents-client-ga/tutorial/html/authentication.html" target="_blank" rel="noopener">HttpClient Tutorial</a>翻译加个人理解写了一篇。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇博文简介了几种HTTP认证模式。文章内容要求读者对HTTP请求、响应的基本结构，HTTP状态码和HTTP协议头有一定的了解。<br>请参考<a href="http://stackeye.com/2012/07/linux-curl-http-protocol/" target="_blank" rel="noopener">Linux下cURL使用教程之二：HTTP协议概述</a>。</p>
<h2 id="HTTP访问认证框架"><a href="#HTTP访问认证框架" class="headerlink" title="HTTP访问认证框架"></a>HTTP访问认证框架</h2><p>HTTP协议（RFC2616）定义了一个简单的访问认证模式框架。此框架假设有若干页面（被保护资源，也称作realm，区域），只能被特定的人访问，这些人可以在服务器要求时提供凭证。<br>当客户端如浏览器访问一个位于保护区域（protected realm）中的页面时，服务器返回包含401未认证状态码和www认证头（WWW-Authenticate header field）的响应。返回的认证头中必须含有至少一个适用于请求页面的认证要求（challenge）。<br>然后客户端发起第二次请求，此次请求在请求头中包含了试用于服务器认证要求的认证头域。<br>如果服务器接受了客户端提供的凭证，它将返回客户端请求的页面。否则，服务端会返回另一个401未认证响应以提示客户端认证失败。<br>具体认证响应头和请求头的内容取决于认证的方式。RFC2616中定义了两种广泛使用的认证模式：<br>HTTP基本认证（HTTP  Basic authentication）和HTTP摘要认证（HTTP Digest authentication）。<br>此外常用的还有NTLM、SPNEGO（HTTP协商认证，HTTP Negotiate authentication，是其一种）和Kerberos认证方式。<br><a id="more"></a></p>
<h2 id="认证模式"><a href="#认证模式" class="headerlink" title="认证模式"></a>认证模式</h2><h3 id="1-基本认证Basic-Access-Authentication"><a href="#1-基本认证Basic-Access-Authentication" class="headerlink" title="1. 基本认证Basic Access Authentication"></a>1. 基本认证Basic Access Authentication</h3><p>基本认证是基于用户名密码的。<br>服务端的401响应中包含一个认证要求（authentication challenge），此认证要求中含有“Basic”关键字和一个用以表明访问的被保护资源名称的“名称=值”对，如下：<br><code>WWW-Authenticate: Basic realm=&quot;Protected page&quot;</code><br>如果你使用的浏览器，浏览器在接收到401响应时，将会弹出窗口让你输入用户名密码，然后发送认证请求。认证请求中同样包含”Basic”关键字，此外还有Base64编码后的用户名密码，如下：<br><code>Authorization: Basic QWRlcGxveSdzIGJsb2c=</code><br>服务器将用户名密码解码后比对，成功匹配后即认证成功。<br>因为Base64不算是一种加密方法：无密钥的可逆加密，任何人都可解密（百度搜索一下”在线解码“一大堆）。因此基本认证被认为是明文传输，安全性不好。极易出现密码被窃听和重放攻击等安全性问题。<br>如果资源需要更高强度的保护，请使用其他认证方法。</p>
<h3 id="2-摘要认证HTTP-Digest-authentication"><a href="#2-摘要认证HTTP-Digest-authentication" class="headerlink" title="2. 摘要认证HTTP Digest authentication"></a>2. 摘要认证HTTP Digest authentication</h3><p>摘要认证被设计用来弥补基本认证的缺点。摘要认证基于请求-响应（challenge-response）模式，而且使用了哈希加密算法（常用为MD5），从而某些程度上解决了基本认证安全性的问题。<br>服务器返回的初始401响应的www认证头（WWW-Authenticate header）中多出了一个称为nonce的随机数的字段。服务端保证每个401响应中的nonce值唯一。如：<br><code>Authorization: Digest username=&quot;admin&quot;, realm=&quot;HiPER&quot;</code><br>接下来的客户端响应中将包含由用户名、密码、nonce和其他信息组成的数据的哈希值（如使用MD5加密）。所有被加密的数据服务端也具有，因此服务端执行同样加密过程。如果二者一直则认证成功。<br>因为如MD5等哈希加密算法是不可逆的，因此用户名密码明文无法被窃听破解。因为服务器对同一个nonce的请求只接受一次客户端请求，从而能避免重放攻击。<br>但是，digest的安全性也有缺点：</p>
<ul>
<li>只有密码密码被加密，而客户端最终请求的被保护资源是明文传送的，可被窃听</li>
<li>客户端无法确认服务端的正确身份，缺少对服务端的认证方式</li>
<li>近年来，随着计算机性能的提高等因素，传统高强度加密算法的破解已成可能。而MD5更是已有破解方法。</li>
</ul>
<p>更多安全性问题请参考RFC2617。</p>
<h3 id="3-NTML"><a href="#3-NTML" class="headerlink" title="3. NTML"></a>3. NTML</h3><p>NTML由微软开发，使用于Windows平台。被认为是比摘要认证更安全的认证方式。<br>它使用Windows凭证（Windows credentials）来传递认证数据，而不是使用未编码的用户名密码。<br>NTML要求服务器与客户端做出多次数据交换，服务器和所有其中的代理都必须支持永久连接（persistent connections）才能完成认证。</p>
<h3 id="4-Kerberos"><a href="#4-Kerberos" class="headerlink" title="4. Kerberos"></a>4. Kerberos</h3><p>服务器与客户端通过第三方的Kerberos服务器完成认证。具体请参见<a href="http://baike.baidu.com/view/306687.htm" target="_blank" rel="noopener">百度百科条目</a>和<a href="http://zh.wikipedia.org/wiki/Kerberos" target="_blank" rel="noopener">维基百科条目</a>。<br>Kerberose相比NTML有很大改善：速度快，而且允许相互认证、认证代理和简单的信任关系。参考<a href="http://msdn.microsoft.com/en-us/library/aa480475.aspx" target="_blank" rel="noopener">KERBEROS vs NTLM</a>。</p>
<h3 id="5-SPNEGO"><a href="#5-SPNEGO" class="headerlink" title="5. SPNEGO"></a>5. SPNEGO</h3><p>全称是Simple and Protected GSS-API Negotiation，是微软提供的一种使用<a href="http://baike.baidu.com/view/1551940.htm" target="_blank" rel="noopener">GSS-API</a>认证机制的安全协议，用于使Webserver共享Windows Credentials，它扩展了Kerberos(一种网络认证协议)。<br>SPNEGO适用于客户端需要认证，但是客户端服务端都不清楚对方支持什么认证协议的场合。<br>SPENGO其实是一种”伪认证机制“（pseudo-mechanism），用以协商出真正的认证机制。<br>最常见的是微软的HTTP协商认证扩展（HTTP Negotiate authentication extension），协商的最终机制在NTML和Kerberos中选择。Kerberos因其优点优先使用。<br>百度词条对此认证的解释是不够准确的，准确的解释可以参考<a href="http://en.wikipedia.org/wiki/SPNEGO" target="_blank" rel="noopener">维基百科条目</a>。</p>
<h2 id="认证方式选择"><a href="#认证方式选择" class="headerlink" title="认证方式选择"></a>认证方式选择</h2><p>选择何种认证方式取决于资源要被保护的程度。不需要保护的资源使用基本认证方式。因为认证会导致更多的数据传输，可能影响用户体验。<br>认证方式最弱的是基本认证，最强的是协商认证。服务端在WWW-Authentication提供自己支持的认证方式，供客户端任意选择。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>RFC2616-HTTP协议<br>RFC2617-HTTP认证：基本认证和摘要认证<br>RFC1321-MD5摘要加密逻辑<br><a href="http://frontier.userland.com/stories/storyReader$2159" target="_blank" rel="noopener">HTTP Authentication Schemes</a></p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之九：代理的使用</title>
    <url>/2012/08/linux-curl-basic-usage-proxy/</url>
    <content><![CDATA[<p>这个时代估计很少有人不知道Facebook，也很少有人不知道为啥国内无法直接访问Facebook。<br>因此，实际应用中，我们会经常使用到代理。<br>本篇着重讲述在curl命令行中对代理的使用。</p>
<h2 id="代理环境"><a href="#代理环境" class="headerlink" title="代理环境"></a>代理环境</h2><p>本篇中，我们将代理分为HTTP代理和socks代理。<br>可是使用wallproxy+GAE的方式搭建个属于自己的代理，具体请百度或wallproxy官网。wallproxy设置完成后，代理默认为<code>127.0.0.1:8086</code>。</p>
<h2 id="选项-x-–proxy"><a href="#选项-x-–proxy" class="headerlink" title="选项-x/–proxy"></a>选项-x/–proxy</h2><p>参数格式为： <code>-x/--proxy &lt;proxyhost[:port]&gt;</code><br>1、使用指定的HTTP代理<br>如果未指定端口，默认端口为1080。比如使用我们本机wallproxy搭建的代理：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x 127.0.0.1:8086 -e http://www.ip138.com/ http://iframe.ip138.com/city.asp</span><br></pre></td></tr></table></figure></p>
<p>即可看到我们的IP变成了代理服务器的IP。<br><a id="more"></a><br>2、此选项优先级高于环境变量中的代理设置。<br>因此当环境变量中设置使用代理时，可以指定代理为”“而跳过代理。</p>
<p>3、所有通过HTTP代理的操作都会被显示的转化为HTTP，因此某些协议的特殊操作可能无法正常使用。<br>此问题可以通过使用<code>-p/--proxytunnel</code>选项构建基于代理的通信隧道得到解决。</p>
<p>4、在版本7.14.1之后，可以通过和环境变量相同的方式指定代理。<br>如使用协议头（http://），或使用内嵌的用户名密码（见下节）。</p>
<p>5、如果有多个-x使用，只有最后一个有效。</p>
<p>6、<code>--proxy1.0 &lt;proxyhost[:port]&gt;</code><br>使用HTTP1.0版本的代理。默认使用-x/–proxy时，使用的HTTP/1.1版本的代理。</p>
<h2 id="选项-U-–proxy-user"><a href="#选项-U-–proxy-user" class="headerlink" title="选项-U/–proxy-user"></a>选项-U/–proxy-user</h2><p>参数格式为： <code>-U/--proxy-user &lt;user:password&gt;</code><br>1、指定用于HTTP代理认证的用户名密码。curl语句如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x proxy.xxx.com:8080 -U username:password -e http://www.ip138.com/ \</span><br><span class="line">http://iframe.ip138.com/city.asp</span><br></pre></td></tr></table></figure></p>
<p>此语句等价于使用内嵌用户名密码的形式：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x <span class="string">'http://username:password@proxy.xxx.com'</span> -e http://www.ip138.com/ \</span><br><span class="line">http://iframe.ip138.com/city.asp</span><br></pre></td></tr></table></figure></p>
<p>注：</p>
<ul>
<li>curl中每个需要用户名+密码的参数，你都可以只指定用户名，curl会自动提示你输入密码，这样更安全。</li>
<li>用户名密码中如果有shell特殊字符，如$、引号等，建议放在单引号中，这样不会转义。特殊字符经常造成难以察觉的错误。如密码为<code>$password</code>，则执行以下代码会提示密码错误，因为shell把$password理解为取变量password的值了：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x http://username:<span class="variable">$password</span>@proxy.xxx.com -e http://www.ip138.com/ \</span><br><span class="line">http://iframe.ip138.com/city.asp</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2、如果使用了支持SSIP的curl库而使用NTLM方式认证的话，可以在-U后使用冒号，如”-U :“，从而强制curl从环境中读取用户名密码。</p>
<p>3、同-x，如果有多个-U使用，只有最后一个有效。</p>
<h2 id="认证方式类选项"><a href="#认证方式类选项" class="headerlink" title="认证方式类选项"></a>认证方式类选项</h2><p>认证方式介绍请参见HTTP认证模式。</p>
<ol>
<li><p><code>--proxy-anyauth</code><br>让curl自动选择合适的认证方法。这时curl会先发出一次请求来查询认证类型。</p>
</li>
<li><p><code>--proxy-basic</code><br>让curl使用HTTP基本认证（HTTP  Basic authentication）模式与代理服务器通信。这是默认模式。此模式下用户名密码作为明文传递。<br>使用–basic选项启用HTTP基础模式。</p>
</li>
<li><p><code>--proxy-digest</code><br>使用HTTP摘要认证（HTTP Digest authentication）。此模式避免将密码作为明文在网络上传递，相对提高了HTTP认证的安全性。<br>使用–digest选项启用HTTP摘要认证模式。</p>
</li>
<li><p><code>--proxy-negotiate</code><br>使用HTTP协商认证（HTTP Negotiate authentication）。<br>使用–negotiate选项启用此模式。</p>
</li>
<li><p><code>--proxy-ntlm</code><br>使用HTTP NTLM认证（HTTP NTLM authentication）。<br>同样，–ntlm启用此模式。</p>
</li>
</ol>
<h2 id="socks代理类选项"><a href="#socks代理类选项" class="headerlink" title="socks代理类选项"></a>socks代理类选项</h2><p>因为socks代理与-x选项指定的代理冲突，因此指定socks后，会覆盖掉之前使用-x指定的代理。<br>同-x，如果多次指定socks代理，只有最后一次有效。<br>在7.21.7版本之后，可以通过-x使用协议头指定代理类型的方式使用socks代理。</p>
<h3 id="1-socks4-lt-host-port-gt"><a href="#1-socks4-lt-host-port-gt" class="headerlink" title="1. --socks4 &lt;host[:port]&gt;"></a>1. <code>--socks4 &lt;host[:port]&gt;</code></h3><p>使用socks4代理。<br>在7.21.7版本之后，可以使用<code>-x socks4://</code> 代替此参数。<br>我们可以采用ssh的-D选项构建转发环境搭建socks代理实际测试一下。</p>
<p>1）Linux机器A：10.1.1.2，有PHP服务器，开启ssh<br>/var/www下新建ip.php:<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$onlineip = $_SERVER[<span class="string">'REMOTE_ADDR'</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"ip:"</span>.$onlineip;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>2）Linux机器B：10.1.1.3，已安装curl、ssh客户端<br>执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -D 8086 10.1.1.2</span><br></pre></td></tr></table></figure></p>
<p>开启转发，搭建socks代理<br>3）机器B<br>执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://10.1.1.2/ip.php</span><br></pre></td></tr></table></figure></p>
<p>可看到本机IP为10.1.1.3。<br>执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --socks4 127.0.0.1:8086 http://10.1.1.2/ip.php</span><br></pre></td></tr></table></figure></p>
<p>可看到代理IP为10.1.1.2。</p>
<h3 id="2-socks4a-lt-host-port-gt"><a href="#2-socks4a-lt-host-port-gt" class="headerlink" title="2. --socks4a &lt;host[:port]&gt;"></a>2. <code>--socks4a &lt;host[:port]&gt;</code></h3><p>socks4a是socks4的扩展，主要增加了域名解析，其余相同。<br><code>--socks4a</code>参数指定使用代理服务器解析域名，其余使用方法相同。<br>在7.21.7版本之后，可以使用<code>-x socks4a://</code> 代替。</p>
<h3 id="3-socks5-lt-host-port-gt"><a href="#3-socks5-lt-host-port-gt" class="headerlink" title="3. --socks5 &lt;host[:port]&gt;"></a>3. <code>--socks5 &lt;host[:port]&gt;</code></h3><p>socks5在socks4的基础上增加了各种验证的支持。参数使用方法相同。<br>在7.21.7版本之后，可以使用<code>-x socks5://</code> 代替。</p>
<h3 id="4-socks5-hostname-lt-host-port-gt"><a href="#4-socks5-hostname-lt-host-port-gt" class="headerlink" title="4. --socks5-hostname &lt;host[:port]&gt;"></a>4. <code>--socks5-hostname &lt;host[:port]&gt;</code></h3><p>基本同–socks5参数，但是此参数指定使用代理服务器解析域名，而不是本地解析。而–socks5是使用本地域名解析。<br>在7.21.7版本之后，可以使用<code>-x socks5h://</code> 代替。</p>
<h3 id="5-socks5-gssapi-service-lt-servicename-gt"><a href="#5-socks5-gssapi-service-lt-servicename-gt" class="headerlink" title="5. --socks5-gssapi-service &lt;servicename&gt;"></a>5. <code>--socks5-gssapi-service &lt;servicename&gt;</code></h3><p>设置使用gssapi的socks5代理服务器的服务名。</p>
<h3 id="6-socks5-gssapi-nec"><a href="#6-socks5-gssapi-nec" class="headerlink" title="6. --socks5-gssapi-nec"></a>6. <code>--socks5-gssapi-nec</code></h3><p>设置对NEC代理服务器的兼容性。</p>
<h2 id="环境变量及相关选项"><a href="#环境变量及相关选项" class="headerlink" title="环境变量及相关选项"></a>环境变量及相关选项</h2><h3 id="1-环境变量"><a href="#1-环境变量" class="headerlink" title="1. 环境变量"></a>1. 环境变量</h3><p><code>http_proxy [protocol://]&lt;host&gt;[:port]</code><br>设置HTTP协议使用的代理，大小写敏感，只能小写。<br>继续使用wallproxy+GAE搭建的代理，编写脚本curlvariable.sh如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8086</span><br><span class="line">curl -e http://www.ip138.com/ http://iframe.ip138.com/city.asp;<span class="built_in">echo</span></span><br></pre></td></tr></table></figure></p>
<p>执行<code>bash curlvariable.sh</code>后将会看到ip变成了代理服务器的IP。</p>
<p>其它常用相关环境变量如下：</p>
<ul>
<li><code>HTTPS_PROXY [protocol://]&lt;host&gt;[:port]</code><br>设置HTTPS协议使用的代理，大小写都可以，小写优先。</li>
<li><code>FTP_PROXY [protocol://]&lt;host&gt;[:port]</code><br>设置FTP协议使用的代理，大小写都可以，小写优先。</li>
<li><code>ALL_PROXY [protocol://]&lt;host&gt;[:port]</code><br>如果某协议没有指定代理，则使用此代理。大小写都可以，小写优先。</li>
<li><code>NO_PROXY &lt;comma-separated list of hosts&gt;</code><br>后跟host（服务器）列表，访问在列表中的host时，不使用代理。如果列表使用通配符”*“，则匹配所有host。</li>
</ul>
<p>如使用<code>NO_PROXY</code>, 可更改curlvariable.sh如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">!/bin/sh</span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8086</span><br><span class="line"><span class="built_in">export</span> no_proxy=ip138.com</span><br><span class="line">curl -e http://www.ip138.com/ http://iframe.ip138.com/city.asp;<span class="built_in">echo</span></span><br></pre></td></tr></table></figure></p>
<p>执行<code>bash curlvariable.sh</code>后将会看到ip不是代理服务器的IP。</p>
<h3 id="2-命令选项"><a href="#2-命令选项" class="headerlink" title="2. 命令选项"></a>2. 命令选项</h3><p><code>--noproxy &lt;no-proxy-list&gt;</code><br>指定不使用环境变量中代理的host列表<br>更改curlvariable.sh如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8086</span><br><span class="line">curl --noproxy ip138.com -e http://www.ip138.com/ http://iframe.ip138.com/city.asp;<span class="built_in">echo</span></span><br></pre></td></tr></table></figure></p>
<p>执行<code>bash curlvariable.sh</code>后将会看到ip不是代理服务器的IP。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要介绍与代理相关的curl选项。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之六：curl基本使用之HTTP文件上传</title>
    <url>/2012/08/linux-curl-basic-usage-upload-file/</url>
    <content><![CDATA[<p>有些时候，不只需要提交表单，还需要上传附件。本篇针对上传文件，对上篇<a href="http://stackeye.com/2012/08/linux-curl-basic-usage-forms/" target="_blank" rel="noopener">curl提交表单</a>进行补充。<br>注：本篇只针对HTTP上传文件部分。</p>
<h2 id="PHP程序"><a href="#PHP程序" class="headerlink" title="PHP程序"></a>PHP程序</h2><p>同前，所有服务端代码通过php实现。</p>
<ul>
<li>file.php，显示文件上传表单：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">PHP FileUpload Demo <span class="keyword">for</span> curl basic usage By Adeploy</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">This is a PHP File Upload Demo.&lt;br /&gt;</span><br><span class="line">Select a file <span class="keyword">and</span> Submit.&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;form action=<span class="string">"upload_file.php"</span> method=<span class="string">"post"</span></span><br><span class="line">enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">"file"</span>&gt;Filename:&lt;/label&gt;</span><br><span class="line">&lt;input type=<span class="string">"file"</span> name=<span class="string">"file"</span> id=<span class="string">"file"</span> /&gt; </span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;input type=<span class="string">"submit"</span> name=<span class="string">"submit"</span> value=<span class="string">"Submit"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;a href=<span class="string">"http://www.adeploy.com"</span> target=<span class="string">"_blank"</span>&gt;Adeploy<span class="string">'s Blog&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>upload_file.php，处理上传的文件。<br>上传文件后，文件先缓存在临时目录中，脚本结束时临时文件被删除。upload_file.php只是简单输出上传文件的信息，而不做实际场景中将临时文件保存至永久目录等进一步处理。但此差异对我们进行curl实验没有任何影响。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">PHP FileUpload Demo <span class="keyword">for</span> curl basic usage By Adeploy</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">This is a File Upload Process Demo.&lt;br /&gt;</span><br><span class="line">It only shows the information of the file you uploaded.&lt;br /&gt;</span><br><span class="line">The file you uploaded remains temporary,&lt;br /&gt;</span><br><span class="line"><span class="keyword">and</span> is deleted when this script is finished.&lt;br /&gt;&lt;br /&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> ($_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Error: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] . <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Upload: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>] . <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Type: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] . <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Size: "</span> . ($_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] / <span class="number">1024</span>) . <span class="string">" Kb&lt;br /&gt;"</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Stored in: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">&lt;a href=<span class="string">"http://www.adeploy.com"</span> target=<span class="string">"_blank"</span>&gt;Adeploy<span class="string">'s Blog&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>put.php，处理通过HTTP PUT方法上传的文件。<br>同上，为了安全只输出上传文件信息，不做实际转存处理。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">PHP Form Demo <span class="keyword">for</span> curl basic usage By Adeploy</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">This is a PHP PUT Demo.&lt;br&gt;</span><br><span class="line">It reads the file you upload using PUT,&lt;br&gt;</span><br><span class="line"><span class="keyword">and</span> prints the content out.&lt;br&gt;&lt;br&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* PUT data comes in on the stdin stream */</span></span><br><span class="line">$putdata = fopen(<span class="string">"php://input"</span>, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the data 1 KB at a time</span></span><br><span class="line"><span class="comment">   and print the content out */</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"The contents of the file you upload:&lt;br&gt;&lt;br&gt;\n"</span>;</span><br><span class="line"><span class="keyword">while</span> ($data = fread($putdata, <span class="number">1024</span>))</span><br><span class="line">    <span class="keyword">echo</span> $data;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="comment">/* Close the streams */</span></span><br><span class="line">fclose($putdata);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;a href=<span class="string">"http://www.adeploy.com"</span> target=<span class="string">"_blank"</span>&gt;Adeploy<span class="string">'s Blog&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h2><h3 id="F-–form"><a href="#F-–form" class="headerlink" title="-F/–form"></a>-F/–form</h3><p><code>-F/--form &lt;name=content&gt;</code><br>使用<code>Content-Type  multi‐part/form-data</code>的方式提交数据，可用于上传二进制文件。</p>
<ol>
<li><p>@的使用<br>一般使用<code>-F file=@filename</code>的形式，其中file为文件表单的name，filename为文件名。@后面的文件作为文件上传处理。</p>
</li>
<li><p>&lt;的使用<br>对于&lt;后的文件，curl会读取其内容，而不会作为文件上传。类似-d选项中@的作用。<br>如<br><code>curl -F name=&lt;foobar.txt -Fage=100 http://127.0.0.1/welcome.php</code><br>foobar.txt内容为Adeploy，则此命令与以下命令等价：<br><code>curl -F name=Adeploy -Fage=100 http://127.0.0.1/welcome.php</code><br>而-F @foobar.txt表示将foobar.txt作为文件上传。</p>
</li>
<li><p>-F不进行url编码<br>-F与-d类似，都是不对数据进行urlencode编码，而且-F不能与-d或–data-urlencode共用。<br>因此如果上传文件的同时还需要提交其他需要urlencode编码的字段（如中文用户名），就会出现问题。<br>除手动编码外，实用的解决办法是自己编写urlencode函数（网上可以找到Linux脚本实现的urlencode函数或C语言版本、Perl版本、Python），调用即可。</p>
</li>
<li><p>使用”type=”指定Content-Type<br>如<code>curl -F &quot;web=@index.html;type=text/html&quot; url.com</code><br>将index.html以text/html的Content-Type上传。</p>
</li>
<li><p>使用”filename=”修改上传文件的名字<br>如<code>curl -F &quot;file=@localfile;filename=nameinpost&quot; url.com</code><br>上传localfile并修改文件名字为nameinpost。</p>
</li>
</ol>
<h3 id="–form-string"><a href="#–form-string" class="headerlink" title="–form-string"></a>–form-string</h3><p><code>--form-string &lt;name=string&gt;</code><br>基本同-F，但是此参数后面跟”@”、”&lt;”、”;type=”时，不做特殊含义解析。</p>
<h3 id="T-–upload-file"><a href="#T-–upload-file" class="headerlink" title="-T/–upload-file"></a>-T/–upload-file</h3><p><code>-T/--upload-file &lt;file&gt;</code><br>使用HTTP的PUT方法上传文件，需要目标URL支持HTTP的PUT方法。<br>可以与-d、–data-urlencode、-F同时使用。</p>
<h2 id="参数使用实例"><a href="#参数使用实例" class="headerlink" title="参数使用实例"></a>参数使用实例</h2><h3 id="F文件上传"><a href="#F文件上传" class="headerlink" title="-F文件上传"></a>-F文件上传</h3><p>打开file.php选择文件后submit，Developer Tools抓包截图如下：<br><img src="/img/developertools_file.jpg" alt="Developer Tools file上传"><br>注意此时的Content-Type字段是<code>multipart/form-data</code>，主要用于上传文件，具体可参考<a href="http://www.ietf.org/rfc/rfc1867.txt" target="_blank" rel="noopener">RFC1867</a>。<br>分析file.php的源代码可知，表单中file类型的input元素name=file，所以命令如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -o file.html -F file=@a.txt http://127.0.0.1/upload_file.php</span><br></pre></td></tr></table></figure></p>
<h3 id="T文件上传"><a href="#T文件上传" class="headerlink" title="-T文件上传"></a>-T文件上传</h3><p>没有找到正确的PUT表单，因此无法使用Developer Tools跟踪实际提交过程。<br>命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -o put.html -T a.txt http://127.0.0.1/put.php</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要为使用curl上传文件的操作方法。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之一：cURL简介</title>
    <url>/2012/07/linux-curl-description/</url>
    <content><![CDATA[<p>随着网络应用的盛行，HTTP脚本编程成为一项流行的技术：<br>你可能需要到某个web页面自动的下载一些信息（采集）或请求某个接口；<br>可能还需要模仿成一个正常浏览器的样子，或者使用代理；<br>甚至需要上传或POST数据。</p>
<p>而cURL就是HTTP脚本编程的利器。</p>
<h2 id="什么是cURL"><a href="#什么是cURL" class="headerlink" title="什么是cURL"></a>什么是cURL</h2><p>cURL的官方网站上这样解释：“The name is a play on ‘Client for URLs’”。意思为“访问URL的客户端”。<br>“cURL is a command line tool for doing all sorts of URL manipulations and transfers”，cURL是用于进行各种对URL的操作和访问传输的命令行工具。<br>而在Linux man手册里这样解释：“cURL - transfer a URL”，意思是对URL的访问传输。<br>今天我们要讲的curl是Linux下一个强大的对URL进行操作的命令行工具。<br>而cURL的写法，URL突出大写，也正是强调对URL的操作。<br><a id="more"></a></p>
<h2 id="cURL主要特点"><a href="#cURL主要特点" class="headerlink" title="cURL主要特点"></a>cURL主要特点</h2><ol>
<li>支持多协议<br>URL的定义为“统一资源定位符”（详见RFC 3986），是不局限于HTTP协议的。<br>因此cURL支持多种协议，如DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS,IMAP, IMAPS,LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, TELNET and TFTP等。</li>
<li>命令行操作，简单强大<br>CURL是无GUI界面的，全部基于命令行操作，这无疑使它可以很方便的集成在像Linux脚本等程序中，<br>而通过我们进一步编程处理，就可以完成非常强大的功能。</li>
<li>开源跨平台<br>cURL工具是由<a href="http://curl.haxx.se/" target="_blank" rel="noopener">libcurl开源项目组</a>提供，此项目组提供开源的libcurl库，此库是由C语言实现客户端URL操作库，提供对URL的访问等操作功能，cURL工具就是采用libcurl实现。<br>而因为libcurl库是适用于多个平台的，因此cURL也适用于多个平台，如Win、Linux、OS/400、TPF等平台。<br>这成为cURL比GNU官方的wget更强大的原因之一。</li>
</ol>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之三：curl基本使用</title>
    <url>/2012/08/linux-curl-basic-usage/</url>
    <content><![CDATA[<p>在介绍完<a href="http://stackeye.com/2012/07/linux-curl-description/" target="_blank" rel="noopener">cURL简介</a>和需要的<a href="http://stackeye.com/2012/07/linux-curl-http-protocol/" target="_blank" rel="noopener">HTTP协议概述</a>之后。终于可以回归正题，进入curl的使用方法。</p>
<h2 id="curl命令格式"><a href="#curl命令格式" class="headerlink" title="curl命令格式"></a>curl命令格式</h2><p>基本的使用用法如下：<br><code>curl [选项] [URL...]</code></p>
<h2 id="GET一个网页"><a href="#GET一个网页" class="headerlink" title="GET一个网页"></a>GET一个网页</h2><p><code>curl http://www.baidu.com</code><br>网页源码将被打印出来。</p>
<h3 id="o-output-lt-file-gt-指定保存目录"><a href="#o-output-lt-file-gt-指定保存目录" class="headerlink" title="-o/--output &lt;file&gt;指定保存目录"></a><code>-o/--output &lt;file&gt;</code>指定保存目录</h3><p>为便于后续处理，我们将网页内容保存在文件中：<br><code>curl -o stackeye.html http://www.stackeye.com</code><br>此时仍会显示进度条等信息。</p>
<h3 id="s-silent静默模式"><a href="#s-silent静默模式" class="headerlink" title="-s/--silent静默模式"></a><code>-s/--silent</code>静默模式</h3><p>通过脚本结合curl可以实现很复杂的功能，而在脚本中调用curl，我们不需要进度条等信息。如执行：<br><code>curl -s -o stackeye.html http://www.stackeye.com</code><br>将不会显示任何信息。<br><a id="more"></a></p>
<h2 id="v-–verbose查看通信过程、调试。"><a href="#v-–verbose查看通信过程、调试。" class="headerlink" title="-v/–verbose查看通信过程、调试。"></a>-v/–verbose查看通信过程、调试。</h2><p>这个参数可以清晰的查看到curl的通信过程，以便于调试，如执行：<br><code>curl -v http://www.baidu.com</code><br>返回结果如下，可以清晰的看到curl发出的HTTP请求及服务器返回的HTTP响应：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* About to connect() to www.baidu.com port 80 (#0)</span><br><span class="line">*   Trying 119.75.218.77... connected</span><br><span class="line">* Connected to www.baidu.com (119.75.218.77) port 80 (#0)</span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; User-Agent: curl/7.21.0 (i686-pc-linux-gnu) libcurl/7.21.0 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18</span><br><span class="line">&gt; Host: www.baidu.com</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Date: Wed, 01 Aug 2012 12:39:15 GMT</span><br><span class="line">&lt; Server: BWS/1.0</span><br><span class="line">&lt; Content-Length: 8216</span><br><span class="line">&lt; Content-Type: text/html;charset=gbk</span><br><span class="line">&lt; Cache-Control: private</span><br><span class="line">&lt; Expires: Wed, 01 Aug 2012 12:39:15 GMT</span><br><span class="line">&lt; Set-Cookie: BAIDUID=AF0E3C36DBB60C0D7C29DE11705028D7:FG=1; expires=Wed, 01-Aug-42 12:39:15 GMT; path=/; domain=.baidu.com</span><br><span class="line">&lt; P3P: CP=&quot; OTI DSP COR IVA OUR IND COM &quot;</span><br><span class="line">&lt; Connection: Keep-Alive</span><br><span class="line">&lt;</span><br><span class="line">&lt;!doctype html&gt;以下为HTML内容，略</span><br></pre></td></tr></table></figure></p>
<p>以下所有命令都可以通过加入-v选项，查看具体通信过程。<br>更详细的调试信息可以使用–trace-ascii选项，如：<br><code>curl --trace-ascii debug.txt http://www.baidu.com</code></p>
<h2 id="A-–user-agent指定User-Agent字段"><a href="#A-–user-agent指定User-Agent字段" class="headerlink" title="-A/–user-agent指定User-Agent字段"></a>-A/–user-agent指定User-Agent字段</h2><p>此选项字段用于指定HTTP请求头的User-Agent字段，即客户端（如浏览器）类型。<br>很多网站为了防止自动化程序采集，仅允许浏览器访问，最简单的办法就是通过User-Agent字段识别客户端类型做出处理。而如下命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span></span><br><span class="line"> http://www.stackeye.com</span><br></pre></td></tr></table></figure></p>
<p><code>&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)&quot;</code>为firefox的UserAgent值。<br>通过-A指定User-Agent字段，使curl伪装成Firefox，从而绕过网站的检测。<br>User-Agent字段可以通过抓包分析得到，或者通过chrome的Developer Tools、Firefox的Firebug等工具得到。<br>而如果一个网站对浏览器的限制也很严格的话，那我们甚至可以通过修改User-Agent伪装成百度蜘蛛或者googlebot突破限制，因为基于SEO的考虑，网站对搜索引擎蜘蛛的限制很小。</p>
<h2 id="e-–referer-设置Referer"><a href="#e-–referer-设置Referer" class="headerlink" title="-e/–referer 设置Referer"></a>-e/–referer <url>设置Referer</url></h2><p>此选项字段用于指定HTTP请求头中的Referer字段，即来源网页。<br>为了防盗链，很多网页尤其是图片等可下载资源会检测Referer字段，对于非自己站内的来源全部屏蔽掉，此时我们就需要这个参数。<br>通过执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span></span><br><span class="line"> -e http://www.baidu.com http://www.stackeye.com</span><br><span class="line">http://www.stackeye.com将检测到来源网站为http://www.baidu.com</span><br></pre></td></tr></table></figure></p>
<h2 id="cookie使用"><a href="#cookie使用" class="headerlink" title="cookie使用"></a>cookie使用</h2><p>cookie的介绍参考上一篇。<br>我们登录网站后，为保持登录状态，需要使用cookie信息。</p>
<h3 id="D-–dump-header-保存协议头部信息"><a href="#D-–dump-header-保存协议头部信息" class="headerlink" title="-D/–dump-header 保存协议头部信息"></a>-D/–dump-header 保存协议头部信息</h3><p><code>-D/--dump-header &lt;file&gt;</code>保存协议头部信息<br>头部信息中包含最常使用的cookie信息，如执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span></span><br><span class="line"> -e http://www.baidu.com -D stackeyecookie.txt http://www.stackeye.com</span><br></pre></td></tr></table></figure></p>
<p>会将头部信息保存至stackeyecookie.txt中。</p>
<h3 id="b-–cookie-指定cookie"><a href="#b-–cookie-指定cookie" class="headerlink" title="-b/–cookie 指定cookie"></a>-b/–cookie 指定cookie</h3><p><code>-b/--cookie &lt;name=data&gt;/&lt;file&gt;</code>指定cookie<br>-b后可直接加-D保存的文件，curl会自动从中读取出cookie值，而且-b选项不会修改此文件。如执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span></span><br><span class="line"> -e http://www.baidu.com -b stackeyecookie.txt http://www.stackeye.com</span><br></pre></td></tr></table></figure></p>
<p>会自动将stackeyecookie.txt中cookie信息附加至HTTP请求头中。</p>
<p>结合-D和-b参数，即可完成cookie的保存和后续使用。</p>
<p>cookie的形式就是“属性:值”对形式，-b后可直接以“属性=值”的形式给出cookie，当有多个属性时以分号间隔且包含在双引号中。如执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span></span><br><span class="line"> -b <span class="string">"user=Adeploy;pass=password"</span> http://www.stackeye.com</span><br></pre></td></tr></table></figure></p>
<p>会将cookie信息<code>user=Adeploy;pass=password</code>附加在HTTP请求头中。</p>
<h2 id="Redirects重定向"><a href="#Redirects重定向" class="headerlink" title="Redirects重定向"></a>Redirects重定向</h2><p>打开某些网页，网页会显示“ 3XX Moved Permanently ”，即网页被移动到其他位置，新位置一般由HTTP响应头中的Location字段给出。<br>重定向一般是因为网站结构调整后，避免用户访问原来页面出现404错误。<br>而另一类常见的用法就是在登陆成功后，网页显示成功信息，然后将用户重定向至内容页面。<br><code>-L/--location</code>选项可以自动跟踪重定向。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇只介绍简单的curl使用选项，下篇将结合实例具体说明。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之五：curl基本使用之提交表单</title>
    <url>/2012/08/linux-curl-basic-usage-forms/</url>
    <content><![CDATA[<p>很多时候，我们想获得的内容或者想进行的操作，只有在登陆之后才有权限，此时就需要用到提交表单。<br>表单以HTML的形式呈现给用户，用户使用表单提交数据后，服务端获得表单数据进行处理，然后进行后续操作。比如我们登录的过程，登录的表单呈现给我们，输入用户名密码提交后，服务端获得用户名密码在数据库中查询，以查询结果判定密码正确与否。<br>向HTTP服务器提交数据常用的有GET和POST两种方法。下文针对这两种方法，结合实例说明curl的使用。</p>
<h2 id="PHP程序"><a href="#PHP程序" class="headerlink" title="PHP程序"></a>PHP程序</h2><p>同前篇，服务端所有代码通过php实现。</p>
<ul>
<li>post.php，显示表单用于POST提交数据：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">PHP POST Demo <span class="keyword">for</span> curl basic usage By Stackeye</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">This is a post form demo.&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;form action=<span class="string">"welcome.php"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">Name: &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span> /&gt;</span><br><span class="line">Age: &lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span> /&gt;</span><br><span class="line">&lt;input type=<span class="string">"submit"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;a href=<span class="string">"http://www.stackeye.com"</span> target=<span class="string">"_blank"</span>&gt;Stackeye<span class="string">'s Blog&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li>welcome.php，处理POST或GET的数据并显示：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">PHP Form Demo <span class="keyword">for</span> curl basic usage By Stackeye</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">This is a PHP Form Demo.&lt;br /&gt;</span><br><span class="line">It can parse both GET <span class="keyword">and</span> POST data.&lt;br /&gt;</span><br><span class="line">This is a &lt;strong&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span>(count($_POST) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"POST"</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"GET"</span>; </span><br><span class="line"><span class="meta">?&gt;</span>&lt;/strong&gt; Request.&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">Welcome &lt;strong&gt;<span class="meta">&lt;?php</span> <span class="keyword">echo</span> $_REQUEST[<span class="string">"name"</span>]; <span class="meta">?&gt;</span>&lt;/strong&gt;.&lt;br /&gt;</span><br><span class="line">You are &lt;strong&gt;<span class="meta">&lt;?php</span> <span class="keyword">echo</span> $_REQUEST[<span class="string">"age"</span>]; <span class="meta">?&gt;</span>&lt;/strong&gt; years old.</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;a href=<span class="string">"http://www.stackeye.com"</span> target=<span class="string">"_blank"</span>&gt;Stackeye<span class="string">'s Blog&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="跟踪表单提交的过程"><a href="#跟踪表单提交的过程" class="headerlink" title="跟踪表单提交的过程"></a>跟踪表单提交的过程</h2><p>提交表单的过程比GET网页的过程要复杂些。GET一个网页一般只会对Referer、User-Agent等字段进行限制。而提交表单的过程，需要知道提交的数据的字段名称、字段值的格式等。而且某些表单还含有隐藏字段。因此使用curl提交表单一般需要我们分析网页源代码，甚至采用抓包工具等进行数据包的分析。</p>
<p>我们分析的一般都是HTTP协议，chrome自带的Developer Tools可以更容易的分析HTTP协议，因此我们使用此工具（Firefox上的Firebug插件提供类似功能）。<br>以下分析基于chrome浏览器。Firefox浏览器需要自行安装firebug插件。</p>
<p>使用chrome打开网页（注意360急速浏览器下要使用“极速模式”，不要使用“兼容模式”），然后右键“审核元素”即可，如下图：<br><img src="/img/developertools.jpg" alt="chrome developer tools"><br>几个比较重要的tab页：</p>
<ul>
<li>Element标签用于显示当前元素，如想看到一个按钮的源码，对按钮右键审核元素即可看到。</li>
<li>Network标签用于显示数据包，对于协议的分析，我们最常用此标签。</li>
</ul>
<h2 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h2><h3 id="1-d-data-lt-data-gt"><a href="#1-d-data-lt-data-gt" class="headerlink" title="1. -d/--data &lt;data&gt;"></a>1. <code>-d/--data &lt;data&gt;</code></h3><p>指定HTTP请求时发送的数据（主要为POST请求），使用和用户通过浏览器提交表单时一样的方式。使用的content-type是<code>application/x-www-form-urlencoded</code>。<br>相当于<code>--data-ascii</code>。发送纯粹二进制的数据（data purely binary），需要使用<code>--data-binary</code>。URL-encode编码要发送的数据，需要使用<code>--data-urlencode</code>。<br>当有多个-d时，curl会自动将发送的数据段是用“&amp;”符号拼接，如：<code>-d name=Stackeye -d age=100</code>将自动拼接为name=Stackeye&amp;age=100作为post数据块（post chunk）发送。<br>如果想指定文件中的内容，可以使用-d @filename的形式。如文件foobar中内容为<code>name=Stackeye</code>，使用-d @foobar即可达到<code>-d name=Stackeye</code>一样的效果（只有第一个=作为特殊字符）。从文件读入时要注意=、@等特殊字符的异常情况。<br>而-d @-可以指定要发送的内容来自标准输入（stdin）。如执行<code>curl -d @- http://127.0.0.1/welcome.php</code>，在终端输入数据后回车、Ctrl+D后达到相同效果。<br>对于文件的使用，对于其他类似选项适用。<br>但<code>-d/--data</code>不会对数据进行url编码，而实际场景中我们最常用的还是发送url编码后的数据。</p>
<h3 id="2-data-urlencode-lt-data-gt"><a href="#2-data-urlencode-lt-data-gt" class="headerlink" title="2. --data-urlencode &lt;data&gt;"></a>2. <code>--data-urlencode &lt;data&gt;</code></h3><p>使用URL-encode编码要发送的数据。除此之外，其余同-d。<br>-d选项默认是不会对要发送数据进行编码的，在旧版本没有<code>--data-urlencode</code>选项的curl时，要发送编码的数据，必须手动对数据进行编码，或者将数据存放在编码的文件中。<br>比如要发送数据为”Stackeye blog”，必须手动把空格变为”%20”：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d name=Stackeye%20blog -d age=100 http://127.0.0.1/welcome.php</span><br></pre></td></tr></table></figure></p>
<p>而<code>--data-urlencode</code>自动完成此过程:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --data-urlencode name=Stackeye%20blog --data-urlencode age=100 \</span><br><span class="line">http://127.0.0.1/welcome.php</span><br></pre></td></tr></table></figure></p>
<p>wireshark抓包后显示如下：<br><img src="/img/curl_encode.jpg" alt="curl urlencode post数据抓包"><br>在我们的程序中，直接使用-d发送需urlencode编码的数据（一般为除字母数字外的其他字符，如空格，汉字等），程序也会正常处理，那我们为什么还需要使用-<code>-data-urlencode</code>呢？原因如下：</p>
<ul>
<li>能正常处理是apache服务器的原因。实际使用中服务器、程序语言不同，很可能出现无法处理不urlencode编码的数据，尤其是汉字和jsp程序，容易出现乱码</li>
<li>我们在使用浏览器操作时，浏览器会自动进行urlencode操作。为了尽可能逼真，我们使用<code>--data-urlencode</code>尽可能模仿浏览器的操作</li>
</ul>
<p><code>--data-urlencode</code>同样可以使用@指定从文件中输入。而且可以使用<code>name@filename</code>的形式。如使用<code>--data-urlencode name@foobar</code>，文件foobar中内容为Stackeye，即可达到<code>--data-urlencode name=Stackeye</code>的效果。这在-d选项中是不行的。需要注意的是此用法不会对name进行编码，所以需要预先编码好name字段。实际场景中一般name字段都是固定的，so it’s not too much trouble.</p>
<h3 id="3-data-binary-lt-data-gt"><a href="#3-data-binary-lt-data-gt" class="headerlink" title="3. --data-binary &lt;data&gt;"></a>3. <code>--data-binary &lt;data&gt;</code></h3><p>发送指定的不做任何处理的数据（This posts data exactly as specified with no extra processing whatsoever），其余同-d。</p>
<h3 id="4-G-get"><a href="#4-G-get" class="headerlink" title="4. -G/--get"></a>4. <code>-G/--get</code></h3><p>和-d/–data、–data-binary一块使用时，表示强制使用GET的方式提交表单。<br>和 -I/–head 一块使用时，表示把提交的数据加在url中，而不是加在数据头中。</p>
<h2 id="参数使用实例"><a href="#参数使用实例" class="headerlink" title="参数使用实例"></a>参数使用实例</h2><h3 id="1-POST"><a href="#1-POST" class="headerlink" title="1. POST"></a>1. POST</h3><p>分析post.php可知，此php脚本提交了两个字段：name和age。<br>打开Developer Tools，填写表单提交后，可看到Network标签下显示出HTTP的POST数据包：<br><img src="/img/developertools_post.jpg" alt="chrome developer tools post分析"><br>注意图中红圈处，可以在“view source”和”view parsed”直接切换，Request Header此时正以source模式显示，此模式下更利于我们的分析。<br>由此图可看到当前页面(post.php)向welcome.php提交了两个字段name和age，值分别为“Stackeye”和“100”，并可看到服务器的返回信息。</p>
<p>我们可使用curl命令的-d选项模拟此POST过程：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o welcome.html \</span><br><span class="line">-e http://127.0.0.1/post.php -d name=Stackeye -d age=100 http://127.0.0.1/welcome.php</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o welcome.html \</span><br><span class="line">-e http://127.0.0.1/post.php -d <span class="string">"name=Stackeye;age=100"</span> http://127.0.0.1/welcome.php</span><br></pre></td></tr></table></figure></p>
<p>因为POST提交表单的过程，一定会有显示表单的页面，因此一般都会有来源页面。因此使用-e指定了post页面为来源页面。<br>分析可得到curl命令需要使用的几乎所有信息。</p>
<p>注：“几乎所有”的原因是如有些字段是在别的网页传递而来，或者由当前页面的js脚本等生成，此时就需要进一步的分析网页源代码等内容。</p>
<h3 id="2-GET"><a href="#2-GET" class="headerlink" title="2. GET"></a>2. GET</h3><p>GET的提交我们直接使用网址后面加参数的形式，使用浏览器打开如下网址：<br><code>http://XXX.XXX.XXX.XXX/welcome.php?name=StackeyeGet&amp;age=101</code><br>同样使用Developer Tools抓包分析如下：<br><img src="/img/developertools_get.jpg" alt="Developer Tools GET分析"><br>由此图可看到GET向welcome.php提交了两个字段name和age，值分别为“StackeyeGet”和“101”。<br>我们可以使用curl的-G选项提交：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o welcome.html \</span><br><span class="line">-e http://127.0.0.1/post.php -G -d name=Stackeye -d age=100 http://127.0.0.1/welcome.php</span><br></pre></td></tr></table></figure></p>
<p>此时可看到welcome.html中有“This is a GET Request.”表明是由GET提交数据。</p>
<p>实际场景中，表单中指定使用GET提交数据的情况很少。因此-G较少使用。<br>但我们更常用的还是直接curl带参数的url，此时与手动操作更接近：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o welcome.html \</span><br><span class="line"><span class="string">"http://127.0.0.1/welcome.php?name=StackeyeGet&amp;age=101"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要为curl提交表单的相关命令参数。<br>实际应用中，我们可能还需要使用curl上传文件，相关命令请看下篇。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之八：curl基本使用实例之115网盘自动摇一摇脚本</title>
    <url>/2012/08/linux-curl-example-115/</url>
    <content><![CDATA[<p>上一篇使用shell+curl的方式完成了登陆百度空间并发表文章。但是奈何shell脚本对大批量文字的处理太弱，因此脚本显得鸡肋。<br>而本篇则完成一个实际可用的脚本程序：115网盘自动摇一摇脚本。</p>
<h2 id="115网盘简介"><a href="#115网盘简介" class="headerlink" title="115网盘简介"></a>115网盘简介</h2><p>115网盘容量和速度都算不错的。注册送15G，然后可通过每天摇一摇等方式获得容量。<br>免费会员每天可以摇一次，可以获得几十M到一百多M的空间，和几百“雨露”。雨露可用于升级，升级后增加空间，但是貌似现在没有了。<br>可以在淘宝上搜一下115账号的价格。<br>（注：当初写这个脚本的时候，还在网盘大战前后，如今的115早已不如当前，摇一摇这个功能早已消失。）</p>
<h2 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h2><p>登陆过程我们仍然使用Developer Tools分析。<br>简单的办法是使用谷歌官方的chrome浏览器或Firefox+Firebug。</p>
<h2 id="登陆过程"><a href="#登陆过程" class="headerlink" title="登陆过程"></a>登陆过程</h2><p>登陆，使用Developer Tools抓包，很容易看到第一个POST包。</p>
<h3 id="1、POST地址"><a href="#1、POST地址" class="headerlink" title="1、POST地址"></a>1、POST地址</h3><p><code>https://passport.115.com/?ac=login</code></p>
<h3 id="2、三部分数据"><a href="#2、三部分数据" class="headerlink" title="2、三部分数据"></a>2、三部分数据</h3><ul>
<li>Request Headers，没特殊需要注意的字段。</li>
<li>Query String Parameters，没用。</li>
<li>Form Data，有两个数据：用户名、密码，字段名分别为login[account]、login[passwd]，参数明文。<a id="more"></a>
<h3 id="3、curl脚本"><a href="#3、curl脚本" class="headerlink" title="3、curl脚本"></a>3、curl脚本</h3>伪造User-Agent，伪装来源页面，登陆保存cookie：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#username/passwd are the parameters of this script</span></span><br><span class="line">username=<span class="variable">$1</span></span><br><span class="line">passwd=<span class="variable">$2</span></span><br><span class="line"><span class="comment">#save to log</span></span><br><span class="line">date&gt;&gt;yaoyao.log</span><br><span class="line"><span class="built_in">echo</span> Log <span class="variable">$1</span>&gt;&gt;yaoyao.log</span><br><span class="line"><span class="comment">#login post</span></span><br><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o 1151.html -D 115cookie001.txt http://www.115.com/</span><br><span class="line">curl -s -L -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line"> -e http://www.115.com/ -o 1152.html -D 115cookie002.txt -b 115cookie001.txt \</span><br><span class="line"> --data-urlencode back=http://www.115.com \</span><br><span class="line"> --data-urlencode goto=http://115.com \</span><br><span class="line"> --data-urlencode login[account]=<span class="variable">$username</span> \</span><br><span class="line"> --data-urlencode login[passwd]=<span class="variable">$passwd</span> \</span><br><span class="line"> <span class="string">'http://passport.115.com/?ac=login'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>为了更逼真，我们先访问了下首页，完整模仿实际用户行为。<br>登陆成功与否不在此处检测，原因见下节。</p>
<h2 id="摇一摇过程"><a href="#摇一摇过程" class="headerlink" title="摇一摇过程"></a>摇一摇过程</h2><h3 id="1、摇一摇抓包分析"><a href="#1、摇一摇抓包分析" class="headerlink" title="1、摇一摇抓包分析"></a>1、摇一摇抓包分析</h3><p>在“网盘”页面下，点击摇一摇，摇成功后抓包分析。<br>很快发现摇一摇的GET数据包。</p>
<h3 id="2、字段分析"><a href="#2、字段分析" class="headerlink" title="2、字段分析"></a>2、字段分析</h3><p>GET网址为：<code>http://115.com/?ct=ajax_user&amp;ac=pick_space&amp;token=dfcce64ebe71051a732d7943068ab***&amp;_=1345093324***</code><br>多次试验发现，URL中有两个变化的参数，token和<em>。没有其它特殊字段。<br>token和</em>字段，按上篇文章思路，我们先考虑这两个字段没有实际意义的情况。</p>
<h3 id="3、curl脚本-1"><a href="#3、curl脚本-1" class="headerlink" title="3、curl脚本"></a>3、curl脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -L -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-e http://www.115.com/ -o 1153.html -D 115cookie003.txt -b 115cookie002.txt \</span><br><span class="line">http://115.com/?ct=ajax_user\&amp;ac=pick_space\&amp;token=dfcce64ebe71051a756f7943068ab147\&amp;_=1331178826515</span><br></pre></td></tr></table></figure>
<p>成功后会有跳转，所有我们使用了-L选项自动跟踪跳转。<br>token和_字段处，填入格式相同的随机值，打开1153.html发现失败。</p>
<h3 id="4、寻找token字段"><a href="#4、寻找token字段" class="headerlink" title="4、寻找token字段"></a>4、寻找token字段</h3><p>同上篇相同思路，从后向前寻找。或者抓包，然后搜索token值。<br>1）最终发现在GET网页<code>http://115.com/?ct=file&amp;ac=userfile&amp;aid=1&amp;cid=0&amp;tpl=list_pg&amp;limit=35的Response</code>里有：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span> window["INDEX_HOME_DATA"] = &#123;take_token: '164d32f6fc1e668c0769eff1235e83ff',is_take: Number('1') &#125;;</span><br></pre></td></tr></table></figure></p>
<p>2）我们使用curl脚本：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-e http://115.com/ -o 1153.html -D 115cookie003.txt -b 115cookie002.txt \</span><br><span class="line"><span class="string">'http://115.com/?ct=file&amp;ac=userfile&amp;aid=1&amp;cid=0&amp;tpl=list_pg&amp;limit=35'</span></span><br></pre></td></tr></table></figure></p>
<p>cat 1153.html|grep token即可看到token字段。</p>
<p>3）增加curl语句GET此页面提取token即可。<br>与上文POST摇一摇的代码合并后脚本如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#get token</span></span><br><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-e http://115.com/ -o 1153.html -D 115cookie003.txt -b 115cookie002.txt \</span><br><span class="line"><span class="string">'http://115.com/?ct=file&amp;ac=userfile&amp;aid=1&amp;cid=0&amp;tpl=list_pg&amp;limit=35'</span></span><br><span class="line">token=`cat 1153.html | grep Yao|awk -F <span class="string">"'"</span> <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"'"</span> <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"token="</span><span class="variable">$token</span></span><br><span class="line"><span class="comment">#check before post</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$token</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"error in getting bdstoken"</span>&gt;&gt;yaoyao.log;</span><br><span class="line">    <span class="built_in">exit</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#yao post</span></span><br><span class="line">curl -s -L -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-e http://www.115.com/ -o 1154.html -D 115cookie004.txt -b 115cookie002.txt \</span><br><span class="line">http://115.com/?ct=ajax_user\&amp;ac=pick_space\&amp;token=<span class="variable">$token</span>\&amp;_=1331178977515</span><br></pre></td></tr></table></figure></p>
<p>测试成功，证明_字段没有实际作用。估计是个时间戳之类的，服务器并不对其正确唯一与否做出很严格的校验。<br>我们只需要在获得token后检验token是否为空即可，不需要在登陆后检测登陆是否成功。因为即使登陆成功后获得token识别，脚本也会终止。</p>
<h2 id="后续处理"><a href="#后续处理" class="headerlink" title="后续处理"></a>后续处理</h2><h3 id="1、结果处理"><a href="#1、结果处理" class="headerlink" title="1、结果处理"></a>1、结果处理</h3><p>摇一摇POST页面<code>http://115.com/?ct=ajax_user&amp;ac=pick_space&amp;token=164d32f6fc1e668c0769eff1235e8***&amp;_=1345094656***</code>得到的结果中，有三个字段有意义：</p>
<ul>
<li>picked：摇一摇获得空间数</li>
<li>total_size：总空间数</li>
<li>exp：获得的雨露数</li>
</ul>
<p>提取脚本如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#get the result</span></span><br><span class="line">cat 1154.html |awk -F<span class="string">"picked\":\""</span> <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"\""</span> <span class="string">'&#123;print $1&#125;'</span>&gt;&gt;yaoyao.log</span><br><span class="line">cat 1154.html |awk -F<span class="string">"total_size\":\""</span> <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"\""</span> <span class="string">'&#123;print $1&#125;'</span>&gt;&gt;yaoyao.log</span><br><span class="line">cat 1154.html |awk -F<span class="string">"exp\":"</span> <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"&#125;"</span> <span class="string">'&#123;print $1&#125;'</span>&gt;&gt;yaoyao.log</span><br></pre></td></tr></table></figure></p>
<p>结果保存在日志中。我们只需要查看日志即可判断成功与否。</p>
<h3 id="2、资源清理"><a href="#2、资源清理" class="headerlink" title="2、资源清理"></a>2、资源清理</h3><p>脚本如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -f 1151.html 1152.html 1153.html 1154.html</span><br><span class="line">rm -f 115cookie001.txt 115cookie002.txt 115cookie003.txt 115cookie004.txt</span><br></pre></td></tr></table></figure></p>
<p>除115cookie002.txt之外，其余的cookie其实不用保存。<br>稳妥的办法是在开头结尾都添加资源清理语句。</p>
<h3 id="3、容错处理"><a href="#3、容错处理" class="headerlink" title="3、容错处理"></a>3、容错处理</h3><p>脚本中没有做太完备的容错处理。<br>因为在网络好的情况下，一般只会一次成功，失败的概率很小。没必要添加逻辑复杂的容错处理。</p>
<h2 id="Linux设置自动执行"><a href="#Linux设置自动执行" class="headerlink" title="Linux设置自动执行"></a>Linux设置自动执行</h2><p>可设置crotab自动执行。<br>如<code>vim /etc/crontab</code>添加如下字段：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30 5    * * *   root   bash yaoyao.sh username password</span><br></pre></td></tr></table></figure></p>
<p>表示每天5:30以root用户自动执行”bash yaoyao.sh username password“。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>完整的脚本请下载yaoyao.sh<br>使用方法：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash yaoyao.sh username password</span><br></pre></td></tr></table></figure></p>
<p>使用bash执行的原因是，其他shell可能有不支持的shell语法。<br>日志保存在yaoyao.log中。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之十一：HTTPS及证书使用简介</title>
    <url>/2012/08/linux-curl-usage-https-cert/</url>
    <content><![CDATA[<p>某些HTTPS网站对证书的要求比较严格，使用curl直接访问时会出现如下错误：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl: (60) SSL certificate problem, verify that the CA cert is OK. Details:</span><br><span class="line">error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed</span><br><span class="line">More details here: http://curl.haxx.se/docs/sslcerts.html</span><br></pre></td></tr></table></figure></p>
<p>此时就需要使用证书。<br>因此本篇只对curl相关选项做出介绍，详细原理请参考HTTPS协议。</p>
<h2 id="使用到的选项"><a href="#使用到的选项" class="headerlink" title="使用到的选项"></a>使用到的选项</h2><h3 id="E-–cert-导入证书"><a href="#E-–cert-导入证书" class="headerlink" title="-E/–cert 导入证书"></a>-E/–cert 导入证书</h3><p><code>-E/--cert &lt;certificate[:password]&gt;</code>导入证书。curl默认使用PEM格式的证书。<br>一般我们从浏览器导出的cert都是X.509格式。可以使用openssl转化为PEM格式。<br><a id="more"></a></p>
<h3 id="–cert-type-指定证书类型"><a href="#–cert-type-指定证书类型" class="headerlink" title="–cert-type 指定证书类型"></a>–cert-type 指定证书类型</h3><p><code>--cert-type &lt;type&gt;</code>指定证书类型，可以为PEM、 DER 或 ENG类型。</p>
<h3 id="–cacert-指定CA证书"><a href="#–cacert-指定CA证书" class="headerlink" title="–cacert 指定CA证书"></a>–cacert 指定CA证书</h3><p><code>--cacert &lt;CA certificate&gt;</code><br>指定使用的CA证书。CA证书必须是PEM格式。<br>默认情况下，curl使用一个自带的CA文件。可以在<a href="http://curl.haxx.se/docs/caextract.html" target="_blank" rel="noopener">这里</a>下载curl提供的最新的CA证书。<br>curl通过读取环境变量CURL_CA_BUNDLE的值作为CA证书库（CA cert bundle）的路径。此选项优先级高于此环境变量被使用。</p>
<h3 id="–capath-指定CA路径"><a href="#–capath-指定CA路径" class="headerlink" title="–capath 指定CA路径"></a>–capath 指定CA路径</h3><p><code>--capath &lt;CA certificate directory&gt;</code><br>指定使用的CA证书路径目录。证书必须为PEM格式，且此目录已被curl自带的c_rehash工具处理过。<br>在需要指定多个CA证书的时候，使用–capath指定CA目录更高效。</p>
<h3 id="k-–insecure-跳过验证"><a href="#k-–insecure-跳过验证" class="headerlink" title="-k/–insecure 跳过验证"></a>-k/–insecure 跳过验证</h3><p><code>-k/--insecure</code><br>指定允许使用不安全的ssl连接传输。<br>所有的连接都是试图通过使用默认安装的CA证书库（CA certificate bundle）来验证是安全的。非安全的连接默认是不允许的。</p>
<h3 id="指定私钥"><a href="#指定私钥" class="headerlink" title="指定私钥"></a>指定私钥</h3><p><code>--key &lt;key&gt;</code><br>指定私钥文件名。</p>
<p><code>--key-type &lt;type&gt;</code><br>指定私钥文件类型，可以为DER、PEM 或 ENG。默认使用PEM。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://curl.haxx.se/docs/sslcerts.html" target="_blank" rel="noopener">Details on Server SSL Certificates</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，curl脚本HTTP相关部分告一段落。<br>后续会介绍些curl使用其他协议的例子，及在编程中使用libcurl库。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之二：HTTP协议概述</title>
    <url>/2012/07/linux-curl-http-protocol/</url>
    <content><![CDATA[<p>虽然cURL支持多种协议，但日常我们最常用的还是HTTP协议，下文中着重介绍HTTP的相关使用方法，因此我们要对HTTP协议有所了解。</p>
<blockquote>
<p>HTTP，超文本传送协议，通过因特网传送万维网文档的数据传送协议。</p>
</blockquote>
<p>我们访问一个网页的实际过程如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端C===HTTP请求===&gt;服务端S：GET index.html http/1.1</span><br><span class="line">客户端C&lt;==HTTP响应====服务端S：HTTP/1.1 200 OK HTML文件内容</span><br></pre></td></tr></table></figure></p>
<p>HTTP协议本身是个无状态协议，它不像其他基于会话的协议那样去不断追踪、记忆事务处理过程。而它要做的就只是简单的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">连接=&gt;发起HTTP请求(HTTP Request)=&gt;得到HTTP响应(HTTP Response)=&gt;断开连接</span><br></pre></td></tr></table></figure></p>
<p>而平常我们通过浏览器浏览网页这个过程，浏览器自动完成发送HTTP请求及对服务端应答的数据进行解析的工作，从而将网页呈现给我们。</p>
<p>我们使用cURL要做的就是模仿浏览器的动作，因此要对HTTP请求的格式进行进一步的解析。</p>
<h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p>在你向HTTP服务器请求一个资源（比如简单的使用浏览器打开一个网页），TCP三次握手建立连接后，HTTP请求发出。<br>HTTP请求信息由3部分组成：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l 请求行(Request Line)</span><br><span class="line">l 请求头(Request Header)</span><br><span class="line">l 请求正文(Message Body)</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="HTTP请求行"><a href="#HTTP请求行" class="headerlink" title="HTTP请求行"></a>HTTP请求行</h3><p>典型的HTTP请求行格式为：<br><code>HTTP命令 请求资源的URI HTTP版本号</code><br>HTTP请求行例子如下：<br><code>GET / HTTP/1.1\r\n</code></p>
<p>这个请求行的意思是：请求得到（GET）/路径下的默认主页文件，使用HTTP协议1.1版本。</p>
<p>根据HTTP标准，HTTP请求可以使用多种请求方法。例如：HTTP1.1支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE和TARCE。而服务器也可以自定义请求命令供客户端使用。具体请参考HTTP的RFC文档。而我们最常用的是GET和POST命令：</p>
<h4 id="GET命令"><a href="#GET命令" class="headerlink" title="GET命令"></a>GET命令</h4><p>GET主要用于取得URL指定的资源信息，也可用来提交表单。GET提交的信息实际上是附加在url之后作为URL的一部分。<br>当年盛行一时的SQL注入，最常见的检测手段就是在GET提交的链接后加单引号来检测是否存在注入漏洞。<br>如提交username和password两个字段，正常的GET网址如下：<br><code>http://www.xxx.com/login.php?username=user&amp;password=pass</code><br>网站后台就会在_GET数组中取得username和password的值，从而组建SQL语句：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> user_table <span class="keyword">where</span> username=<span class="keyword">user</span> <span class="keyword">and</span> <span class="keyword">password</span>=pass</span><br></pre></td></tr></table></figure></p>
<p>如果返回的count值大于0即为用户名密码正确。<br>而添加单引号后：<br><code>http://www.xxx.com/login.php?username=user&amp;password=pass&#39;</code><br>组建的SQL语句为<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> user_table <span class="keyword">where</span> username=<span class="keyword">user</span> <span class="keyword">and</span> <span class="keyword">password</span>=pass<span class="string">'</span></span><br></pre></td></tr></table></figure></p>
<p>这个SQL语句执行出错，网页显示错误信息，黑客从而得知网页有SQL注入漏洞。<br>因此使用GET提交表单是不安全的，只进行了简单的编码无法加密，可以很容易的从网址猜出各字段的意思。而且受限于URL长度限制，GET提交表单能携带的数据也有限。</p>
<h4 id="POST命令"><a href="#POST命令" class="headerlink" title="POST命令"></a>POST命令</h4><p>POST主要用于提交表单，尤其是提交大批量的表单数据。<br>POST方法克服了GET方法的一些缺点。通过POST方法提交表单数据时，数据不是作为URL请求的一部分而是作为标准数据传送给Web服务器，这就克服了GET方法中的信息无法加密和数据量太小的缺点。</p>
<p>HTTP请求的下一段数据为HTTP请求头。</p>
<h3 id="HTTP请求头"><a href="#HTTP请求头" class="headerlink" title="HTTP请求头"></a>HTTP请求头</h3><p>HTTP请求头中主要包含关于请求本身或者客户端的有用信息，比如浏览器的类型、浏览器语言、编码、压缩算法等信息。服务器上的动态脚本如PHP等可以利用请求头信息生成动态的网页内容。</p>
<p>典型的HTTP请求头例子如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.168 Safari/535.19 QIHU 360EE</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Referer: http://www.adeploy.com/</span><br><span class="line">Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3</span><br></pre></td></tr></table></figure></p>
<p><code>\r\n</code>表示换行。由此可以看到HTTP请求头是由几行“属性:值”对组成的，例如属性Accept的值为<code>*/*\r\n</code> ，表示客户端可以接受任意数据类型。<br>而我们最常用的是<code>User-Agent</code>字段和<code>Referer</code>字段，分别用于指定客户端类型和来源页面。<br>最末行额外多出的一对<code>\r\n</code>表示一个空白行，此空白行表示HTTP请求头结束，以下部分为请求正文。</p>
<h3 id="HTTP请求正文"><a href="#HTTP请求正文" class="headerlink" title="HTTP请求正文"></a>HTTP请求正文</h3><p>HTTP请求正文经常为空，除非需要向服务端提交信息，如在使用POST向网站提交表单的时候。<br>例如如下是一个完整的HTTP请求的例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.adeploy.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.168 Safari/535.19 QIHU 360EE</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Referer: http://www.adeploy.com/</span><br><span class="line">Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3</span><br></pre></td></tr></table></figure></p>
<h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>当收到HTTP请求之后，HTTP服务器会进行处理然后返回一个HTTP响应给客户端（典型的客户端为浏览器）。HTTP响应中包含几乎与HTTP请求同样类型的数据。<br>HTTP响应信息也由3部分组成：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l 响应行(Response Status Line)</span><br><span class="line">l 响应头(Response Header)</span><br><span class="line">l 响应正文(Message Body)</span><br></pre></td></tr></table></figure></p>
<p>响应行以服务端使用的HTTP协议版本号开始，后加响应状态码，表示请求结果状态，例如：<br><code>HTTP/1.1 200 OK</code><br>状态码200表示请求成功。</p>
<p>紧接着的是响应头。响应头与请求头十分相似，也是由几行“属性:值”对组成。其中包含关于服务器的有用信息、响应数据等。典型响应头如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Expires: Fri, 01 Jan 1990 00:00:00 GMT</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Date: Tue, 31 Jul 2012 07:20:31 GMT</span><br><span class="line">Server: Google Frontend</span><br><span class="line">Content-Length: 10387</span><br></pre></td></tr></table></figure></p>
<p>如果请求成功，响应正文中将包含请求的数据，如图片文件的二进制数据、HTML文件等。一旦响应正文传输完毕，服务端又没有使用HTTP 1.1/2版本的Keep-Alive请求，HTTP连接将会断开。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie是服务器为了辨别用户身份、进行session跟踪用户识别，而储存在客户端的数据。用以判断在HTTP传输中的状态，从而弥补HTTP协议无状态的缺陷。</p>
<p>比如我们登录一个网站后，关闭网页后重新打开网页，服务端就可以通过cookie信息判断我们曾经登录过，从而跳过重新登录的过程，让用户感觉到亲切、方便、人性化。</p>
<p>当客户端向服务端发起请求时，浏览器会自动将cookie信息添加在HTTP请求头中。例子如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cookie: __utmc=90639562; __utma=90639562.1273157993.1343361841.1343361841.1343718828.2; __utmb=90639562.1.10.1343718828; __utmz=90639562.1343361841.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none)</span><br></pre></td></tr></table></figure></p>
<p>在我们使用cURL时，每次访问网页都相当于浏览器打开关闭一次，因此cookie会起到很大的作用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇介绍后续会使用的HTTP协议知识，只做简要概括，具体请参考RFC文档。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>http协议</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLAlchemy简介及在OpenStack中的使用</title>
    <url>/2015/07/sqlalchemy-intro/</url>
    <content><![CDATA[<p>SQLAlchemy是Python编程语言下的一款开源软件，提供了SQL工具包及对象关系映射(ORM)工具。</p>
<h2 id="web编程之orm"><a href="#web编程之orm" class="headerlink" title="web编程之orm"></a>web编程之orm</h2><p>在编写web服务时，我们通常使用orm，而不是直接使用SQL与数据库进行交互。<br>如果使用Django等比较全面的框架，可以选择默认的ORM。但如果选择flask等轻量级框架，则需要自己选择ORM。同时，自己选择使用ORM也带来了更大的灵活性。<br><a id="more"></a></p>
<h3 id="orm是什么"><a href="#orm是什么" class="headerlink" title="orm是什么"></a>orm是什么</h3><p>以下节选自wikipeida：</p>
<blockquote>
<p>Object-relational mapping (ORM, O/RM, and O/R mapping tool) in computer science is a programming technique for converting data between incompatible type systems in object-oriented programming languages.</p>
</blockquote>
<p>以下节选自百度百科：</p>
<blockquote>
<p>对象关系映射（英语：Object Relation Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。</p>
</blockquote>
<p>实际项目中，我们主要使用orm作为与数据库等进行实际交互的工具。</p>
<h3 id="为什么使用orm"><a href="#为什么使用orm" class="headerlink" title="为什么使用orm"></a>为什么使用orm</h3><p>与直接使用sql访问数据库相比，其有以下好处：</p>
<ul>
<li>代码的简洁性，对存储层的通用封装<br>使用orm，操作数据库往往仅需要简单的几条语句，使代码变得简洁。</li>
<li>数据源的兼容性<br>orm往往对多种数据库、数据源进行通用的封装，从而使得编写一套代码，适用于不同的数据源变得可能。</li>
<li>操作的安全性<br>直接使用sql操作数据库，往往会因为开发人员疏忽引入sql注入等安全问题。而使用orm，能避免此问题。</li>
<li>操作语句的高效性<br>orm的封装是众多开发人员智慧的结晶，其中往往已经对生成的sql语句进行了优化，使得一般语句的性能比较高效，而开发人员不需要再去考虑性能问题。但orm一般是通用的解决方案，无法针对所有场景进行优化，特殊场景下其生成的sql语句可能会非常低效，因此需要在实际使用时进行监控并酌情优化。</li>
</ul>
<h2 id="简介及特性"><a href="#简介及特性" class="headerlink" title="简介及特性"></a>简介及特性</h2><p>SQLAlchemy的特性主要如下：</p>
<ul>
<li>Mature, High Performing Architecture DBA Approved</li>
<li>Non-Opinionated</li>
<li>Unit Of Work</li>
<li>Function-based query construction Modular and Extensible</li>
<li>Separate mapping and class design …</li>
</ul>
<p>See: <a href="http://www.sqlalchemy.org/features.html" target="_blank" rel="noopener">http://www.sqlalchemy.org/features.html</a></p>
<h2 id="安装及使用"><a href="#安装及使用" class="headerlink" title="安装及使用"></a>安装及使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>开发环境推荐使用pip安装，同时注意版本问题。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install sqlalchemy</span><br></pre></td></tr></table></figure></p>
<p>生产环境推荐使用rpm/deb安装，同时注意版本问题。<br>rpm - 版本兼容问题<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install SQLAlchemy</span><br><span class="line">apt-get install SQLAlchemy</span><br></pre></td></tr></table></figure></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>支持的2种方式:</p>
<ul>
<li>SQL Expression Language (core)</li>
<li>Object Relational Mapper (orm)</li>
</ul>
<h2 id="Core方式"><a href="#Core方式" class="headerlink" title="Core方式"></a>Core方式</h2><p>(raw sql、sql expression)<br>对于绝大多数应用, 推荐使用SqlAlchemy. 即使是使用raw sql,<br>SqlAlchemy 也可以带来如下好处:</p>
<ul>
<li>内建数据库连接池</li>
<li>强大的log功能</li>
</ul>
<p>SqlAlchemy的sql expression和raw sql的比较:</p>
<ul>
<li>sql expression 写法是纯python代码, 阅读性更好</li>
<li>raw sql 比 sql expression 更灵活, 如果SQL很复杂, 更有优势了</li>
</ul>
<h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">engine_str = <span class="string">"mysql:mysql://root:root@localhost/django_sqla"</span></span><br><span class="line">engine = create_engine(engine_str, echo=<span class="literal">True</span>)</span><br><span class="line">conn = engine.connect()</span><br></pre></td></tr></table></figure>
<h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Table objects <span class="keyword">and</span> its children <span class="keyword">as</span> metadata Table Column(String, Integer…)</span><br><span class="line">Create tables within the engine</span><br></pre></td></tr></table></figure>
<h3 id="Insert-expression"><a href="#Insert-expression" class="headerlink" title="Insert expression"></a>Insert expression</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ins2=users.insert() <span class="comment">#anexpression</span></span><br><span class="line">result2 = conn.execute(ins2, id=<span class="number">2</span>, name=’wendy’, fullname=’Wendy Williams’) <span class="comment"># execute</span></span><br><span class="line">Multiple inserts: conn.execute(ins2, a_list)</span><br></pre></td></tr></table></figure>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">users.update().values(&#123;…&#125;).where(…)</span><br></pre></td></tr></table></figure>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>同上</p>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = select([users]) <span class="keyword">or</span> s = users.select()</span><br><span class="line">result = conn.execute(s)</span><br><span class="line">result.fetchone()</span><br><span class="line">result.close()</span><br></pre></td></tr></table></figure>
<h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sqlalchemy allows using string</span><br><span class="line">s = text(“””Hello”””)</span><br></pre></td></tr></table></figure>
<h2 id="orm方式"><a href="#orm方式" class="headerlink" title="orm方式"></a>orm方式</h2><h3 id="Declare-a-Mapping"><a href="#Declare-a-Mapping" class="headerlink" title="Declare a Mapping"></a>Declare a Mapping</h3><p>declarative_base: define classes and mapping to tables<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Base = declarative_base()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = ‘users’</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<h3 id="MetaData"><a href="#MetaData" class="headerlink" title="MetaData"></a>MetaData</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Base.metadata.create_all(engine)</span><br></pre></td></tr></table></figure>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>事务<br>using session to handle orm’s action<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Session = sessionmaker(bind=engine)</span><br><span class="line">session = Session()</span><br></pre></td></tr></table></figure></p>
<h3 id="Connection-pool"><a href="#Connection-pool" class="headerlink" title="Connection pool"></a>Connection pool</h3><h3 id="Add-insert"><a href="#Add-insert" class="headerlink" title="Add(insert)"></a>Add(insert)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ed_user = User(<span class="string">'ed'</span>, <span class="string">'Ed Jones'</span>, <span class="string">'edspassword'</span>)</span><br><span class="line">session.add(ed_user)</span><br><span class="line">session.add_all([...])</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>
<h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = session.query(User).filter(User.name==‘ed<span class="string">')</span></span><br><span class="line"><span class="string">result[0].name, result[0][0]</span></span><br></pre></td></tr></table></figure>
<h3 id="Relationship"><a href="#Relationship" class="headerlink" title="Relationship"></a>Relationship</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span><span class="params">(Base)</span></span></span><br><span class="line">__tablename__ = ‘addresses’</span><br><span class="line">...</span><br><span class="line">user_id = Column(Integer, ForeignKey(<span class="string">'users.id'</span>)) user = relationship(<span class="string">"User"</span>,</span><br><span class="line">backref=backref(<span class="string">'addresses'</span>, order_by=id))</span><br></pre></td></tr></table></figure>
<h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>Alembic<br><a href="http://blog.csdn.net/ying_593254979/article/details/10189799" target="_blank" rel="noopener">参考</a></p>
<h2 id="OpenStack中的使用"><a href="#OpenStack中的使用" class="headerlink" title="OpenStack中的使用"></a>OpenStack中的使用</h2><p>wsgi框架+SQLAlchemy</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>版本兼容问题<br>rpmbuild</p>
<h2 id="参考索引"><a href="#参考索引" class="headerlink" title="参考索引"></a>参考索引</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Object-relational_mapping" target="_blank" rel="noopener">orm in wiki</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>web</tag>
        <tag>orm</tag>
        <tag>sqlalchemy</tag>
      </tags>
  </entry>
  <entry>
    <title>解密Redis持久化</title>
    <url>/2017/04/redis-persistence-demystified/</url>
    <content><![CDATA[<p>本文主要是对<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html" target="_blank" rel="noopener">antirez博客</a>的翻译。其实<a href="http://blog.nosqlfan.com/html/3813.html" target="_blank" rel="noopener"></a>nosqlfan已经有一篇译文，但不知道为什么省略了很多重要的细节，因此完整翻译了本篇。</p>
<p>首先antirez感觉到，他看到的所有针对Redis的文章和讨论中，对Redis持久化的误解是最大的。因此在这篇文章中，他将尝试真正的公正一些：不做Redis的广告，不尝试跳过任何细节以避免使Redis模糊不清。作者想做的仅是提供一个清晰易懂的描绘，介绍Redis持久化的工作原理，Redis的持久化如何可靠，以及与其它数据库的对比。</p>
<h2 id="操作系统和磁盘"><a href="#操作系统和磁盘" class="headerlink" title="操作系统和磁盘"></a>操作系统和磁盘</h2><h3 id="写操作的流程"><a href="#写操作的流程" class="headerlink" title="写操作的流程"></a>写操作的流程</h3><p>我们应该考虑的第一件事是对于数据库的持久化，我们的期望是什么。因此我们将一个简单的写操作中发生的事情可视化：</p>
<ol>
<li>客户端发送写命令到数据库（数据库在客户端内存中）</li>
<li>数据库接收到写操作（数据在服务器内存中）</li>
<li>数据库调用系统调用，将数据写入磁盘（数据在内核缓冲区中）</li>
<li>操作系统将写缓冲区的数据转移到磁盘控制器上（数据在磁盘缓存中）</li>
<li>磁盘控制器真正将数据写入到物理介质（数据真正落在磁盘上）<a id="more"></a>
<blockquote>
<p>注意：以上是一个各方面简单化的版本，因为实际有更多的cache和buffer。<br>步骤2经常被实现为数据库内部的一个复杂缓存系统。写操作也经常被不同的线程或进程处理。然而数据库或早或晚要将数据写入磁盘，而这就是我们关心的。也就是说，内存中的数据在某个节点必须要被传输到内核（步骤3）。<br>另外一个大的细节省略在步骤3.现实要更复杂，因为大多数高级操作系统内核实现了不同级别的缓存，其中通常包含文件系统级别的chache和一个略小一些的buffer cache。</p>
</blockquote>
</li>
</ol>
<h3 id="故障分析"><a href="#故障分析" class="headerlink" title="故障分析"></a>故障分析</h3><p>在这个流程中什么时候我们的写操作才是安全的呢？</p>
<p>如果我们考虑一个仅涉及数据库软件的失效（例如进程被管理员杀掉或崩溃），而不涉及操作系统内核，那成功执行完成步骤3的写操作就被认为是安全的。也就是在write这个系统调用（或其它用于将数据转移到内核的系统调用）返回成功后。在此步骤之后，即使数据库进程崩溃，内核仍然会负责将数据转移到磁盘控制器。</p>
<p>如果我们考虑一个更灾难性的事件，如电力中断，只有在步骤5执行完成后我们才是安全的。也就是在数据真正被转移到物理设备中时。</p>
<p>我们可以总结为，数据安全的重要阶段位于步骤3、4、5：</p>
<h3 id="POSIX-API"><a href="#POSIX-API" class="headerlink" title="POSIX API"></a>POSIX API</h3><h3 id="我们无法控制的部分"><a href="#我们无法控制的部分" class="headerlink" title="我们无法控制的部分"></a>我们无法控制的部分</h3><h3 id="数据损坏"><a href="#数据损坏" class="headerlink" title="数据损坏"></a>数据损坏</h3><h2 id="Redis持久化实现"><a href="#Redis持久化实现" class="headerlink" title="Redis持久化实现"></a>Redis持久化实现</h2><h3 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h3><h3 id="AOF文件"><a href="#AOF文件" class="headerlink" title="AOF文件"></a>AOF文件</h3><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>appendfsync no<br>appendfsync everysec<br>appendfsync always<br>为什么pipeline不同<br>AOF和Redis事务</p>
<h3 id="与PostgreSQL和MySQL的对比"><a href="#与PostgreSQL和MySQL的对比" class="headerlink" title="与PostgreSQL和MySQL的对比"></a>与PostgreSQL和MySQL的对比</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h2><h2 id="附录：关于重启阶段的笔记"><a href="#附录：关于重启阶段的笔记" class="headerlink" title="附录：关于重启阶段的笔记"></a>附录：关于重启阶段的笔记</h2>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>nosql</tag>
        <tag>aof</tag>
        <tag>rdb</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之十：HTTP文件下载</title>
    <url>/2012/08/linux-curl-usage-download-file/</url>
    <content><![CDATA[<p>其实每次我们使用curl去打开一个url都是执行一次下载操作，因此我们甚至可以认为curl是一个下载工具。<br>而且curl的某些选项及特性，使得curl能完成非常强大的下载功能。<br>基本命令及一些有用的参数如下。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>使用<code>curl [URL...]</code>下载URL，并输出在终端。<br>可指定多个URL。多个URL时，下载内容同时在终端显示。</p>
<h2 id="–progress-bar-进度条"><a href="#–progress-bar-进度条" class="headerlink" title="-#/–progress-bar 进度条"></a>-#/–progress-bar 进度条</h2><p>添加参数<code>-#/--progress-bar</code>查看下载进度条。</p>
<h2 id="o-–output-输出文件"><a href="#o-–output-输出文件" class="headerlink" title="-o/–output 输出文件"></a>-o/–output 输出文件</h2><p>使用参数<code>-o/--output &lt;file&gt;</code>下载并保存至文件file。<br>可同时下载多个URL，每个-o对应一个URL。<br>如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o a.html http://www.a.com http://www.b.com</span><br></pre></td></tr></table></figure></p>
<p>会下载<a href="http://www.a.com的内容在a.html中，并在终端输出www.b.com的内容。而" target="_blank" rel="noopener">www.a.com的内容在a.html中，并在终端输出www.b.com的内容。而</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o a.html http://www.a.com -o b.html http://www.b.com</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o a.html -o b.html http://www.a.com http://www.b.com</span><br></pre></td></tr></table></figure></p>
<p>会分别下载两个URL至两个文件中。<br><a id="more"></a></p>
<h2 id="O-–remote-name"><a href="#O-–remote-name" class="headerlink" title="-O/–remote-name"></a>-O/–remote-name</h2><p>下载并从url中提取文件名。<br>多个URL的情况同-o选项相同：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O -O http://www.xxx.com/a.html http://www.xxx.com/b.html</span><br><span class="line">curl -O http://www.xxx.com/a.html -O http://www.xxx.com/b.html</span><br></pre></td></tr></table></figure></p>
<p>都会将两个URL分别保存在a.html和b.html中。</p>
<h2 id="C-–continue-at-断点续传"><a href="#C-–continue-at-断点续传" class="headerlink" title="-C/–continue-at 断点续传"></a>-C/–continue-at 断点续传</h2><p>使用参数<code>-C/--continue-at &lt;offset&gt;</code>进行断点续传。offset参数指定跳过多少bytes。<br>“-C -”指定自动检测断点续传开始位置。<br>使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -<span class="comment"># -O http://dl_dir.qq.com/qqfile/qd/QQ2012Beta3_QQProtect2.8.exe</span></span><br></pre></td></tr></table></figure></p>
<p>下载QQ安装程序，在下载未完成时Ctrl+C结束下载，然后使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -<span class="comment"># -C - -O http://dl_dir.qq.com/qqfile/qd/QQ2012Beta3_QQProtect2.8.exe</span></span><br></pre></td></tr></table></figure></p>
<p>进行断点续传。可看到第二次下载时并不是重新下载，而是从上次结束的地方下载。</p>
<h2 id="r-–range-分块下载"><a href="#r-–range-分块下载" class="headerlink" title="-r/–range 分块下载"></a>-r/–range 分块下载</h2><p>使用<code>-r/--range &lt;range&gt;</code>分块下载，指定每块下载的字节范围。如上例中下载qq，分块下载如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -r 0-10240 -o qq.exe.part1 http://dl_dir.qq.com/qqfile/qd/QQ2012Beta3_QQProtect2.8.exe</span><br></pre></td></tr></table></figure></p>
<p>下载前10240bytes。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -r 10241-20480 -o qq.exe.part2 http://dl_dir.qq.com/qqfile/qd/QQ2012Beta3_QQProtect2.8.exe</span><br></pre></td></tr></table></figure></p>
<p>下载10241-20480bytes。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -r 20481- -o qq.exe.part3 http://dl_dir.qq.com/qqfile/qd/QQ2012Beta3_QQProtect2.8.exe</span><br></pre></td></tr></table></figure></p>
<p>下载20481bytes及之后的字节。<br>下载完后可使用<code>cat qq.exe.part&gt;qq.exe</code>的形式得到完整文件（win下需要使用copy /b）。<br>此选项适用于HTTP/FTP/SFTP及本地文件。</p>
<h2 id="–limit-rate-限速下载"><a href="#–limit-rate-限速下载" class="headerlink" title="–limit-rate 限速下载"></a>–limit-rate 限速下载</h2><p>使用参数<code>--limit-rate &lt;speed&gt;</code>限速下载。默认单位为bytes/s，’k’或’K’指定使用单位KB/s，可以使用’m’或’M’指定使用单位MB/s，’g’或’G’指定使用单位GB/s。如<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -<span class="comment"># -O --limit-rate 100K http://dl_dir.qq.com/qqfile/qd/QQ2012Beta3_QQProtect2.8.exe</span></span><br></pre></td></tr></table></figure></p>
<p>指定限速为100KB/s。<br>限速是限制平均速度，某时刻的突发速度可能超过限制速度，但平均速度会低于限制速度。<br>如果同时使用了-Y/–speed-limit限制了最低下载速度，-Y/–speed-limit选择优先级更高。因此如果-Y/–speed-limit指定的值高于限制的速度，那么限制的速度回被突破，以保证最低下载速度有效（因为如果低于-Y/–speed-limit指定的最低下载速度，下载会被取消）。</p>
<h2 id="y-Y-限制速度"><a href="#y-Y-限制速度" class="headerlink" title="-y/-Y 限制速度"></a>-y/-Y 限制速度</h2><p>使用参数<code>-y/--speed-time &lt;time&gt;</code>或<code>-Y/--speed-limit &lt;speed&gt;</code>限制速度。<br>网速太慢时取消下载。</p>
<ul>
<li>-Y指定最低速度。使用-y指定超时时间而未指定最低速度时，最低速度默认为1.</li>
<li>-y指定超时时间，即低于最低速度多次时间时取消下载。使用-Y指定最低速度而未指定超时时间时，超时时间默认为30。</li>
</ul>
<h2 id="z-–time-cond-更新下载"><a href="#z-–time-cond-更新下载" class="headerlink" title="-z/–time-cond 更新下载"></a>-z/–time-cond 更新下载</h2><p>使用参数<code>-z/--time-cond &lt;date expression&gt;</code>设置只在更新时下载。具体的时间格式请参考<code>man 3 curl_getdate</code>（这个只有在安装了libcurl开发库之后才有），或者<a href="http://curl.haxx.se/libcurl/c/curl_getdate.html" target="_blank" rel="noopener">curl_getdate在线文档</a>。<br>如果时间格式解析失败，curl将会把此字段理解为文件名，从文件中读取时间。<br>需要网页中有相关字段表明最后更新日期。<br>如curl_getdate在线文档网页内有字段:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page updated June 20, 2012.</span><br></pre></td></tr></table></figure></p>
<p>表明网页最后更新日期是2012-06-20，因此执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -z 20-jun-12 http://curl.haxx.se/libcurl/c/curl_getdate.html</span><br></pre></td></tr></table></figure></p>
<p>curl_getdate.html在2012-06-20以后被更新，会被下载。而在日期前加上”-“，则表示相反意思，如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -z -20-jun-12 http://curl.haxx.se/libcurl/c/curl_getdate.html</span><br></pre></td></tr></table></figure></p>
<p>只有 curl_getdate.html 在2012-06-20之前被更新才会下载。因此此命令不会下载curl_getdate.html。</p>
<h2 id="文件批量下载"><a href="#文件批量下载" class="headerlink" title="文件批量下载"></a>文件批量下载</h2><p>通过使用正则表达式，可以对有一定规律的文件批量下载。如我们在PHP服务器的/var/www下新建a、b两个目录，新建如下文件：<br><code>a/1.php a/2.php...a/7.php,b/1.php b/2.php...b/5.php</code><br>PHP文件内容相同，都为输出绝对路径，用以标志文件的不同：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">__FILE__</span> ;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可以使用命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O http://127.0.0.1/&#123;a,b&#125;/[1-7].php</span><br></pre></td></tr></table></figure></p>
<p>批量下载文件。<br>a/1.php-a/7.php会保存在当前目录下的1.php-7.php中。b/1.php-b/5.php如果也保存在当前目录下的1.php-5.php的话，会覆盖以前的文件。因此curl会把b/1.php-b/5.php的内容在终端输出而不会保存文件。而执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="string">"http://10.1.1.103/&#123;a,b&#125;/[1-7].php"</span> -o <span class="string">"#1_#2.php"</span></span><br></pre></td></tr></table></figure></p>
<p>则会使用“目录<em>文件”的形式命名文件，避免文件名冲突。<br>{}、[]类似于正则表达式中的语法，用以取得多个文件。#加数字的形式用以取得正则表达式的当前值。<br>如#1表示第一个正则表达式的当前值，上例中即为{a,b}的值。<br>当下载<code>http://10.1.1.103/a/1.php</code>时，#1为“a”，#2为“1”，#1</em>#2.php即为“a_1.php”。从而完成批量文件的自动命名。</p>
<p>注：注意此时网址包含在双引号中，这是因为如果不被包含在引号中，{}中的内容无法使用#1的形式引用，会出现如下错误<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal error: invalid pattern type (0)</span><br><span class="line">Warning: bad output glob!</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实日常使用，我们更多使用wget下载文件。相比wget，curl功能更具体一些。<br>关于二者的区别，请参考后续文章。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的KeepAlive使用简介</title>
    <url>/2018/04/tcp-keepalive/</url>
    <content><![CDATA[<p>在现代应用系统实现中，我们一般使用长连接与服务端进行交互，以减少建立连接的开销。<br>同时使用连接池，维护特定数量的连接以备随时使用。<br>但是在NAT等有中间设备的情况下，长连接很可能因为某些原因被断开。<br>从而导致连接池失去应有的作用。</p>
<p>基于这些需求，就需要使用TCP的keepalive功能。<br>它能提供一种自动、高效、可灵活配置，相比应用层心跳包更轻量的连接保活方式。</p>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>当我们需要对外提供服务的时候，尤其是KV存储这种对稳定性更高的中间件服务，一般会使用VIP, 而不是让用户直连：</p>
<ul>
<li>减少变更时对用户的影响：如proxy替换、扩容、维护</li>
<li>高可用：更方便的高可用，用户无需探活健康检查等</li>
<li>隐藏拓扑细节：更高的安全性</li>
</ul>
<p>使用VIP时需要注意的是，长时间idle的连接会被reset。<br>原因是LVS一般配置为保持连接有时间限制，如果超过此时间后连接上一直没有报文，LVS就会发送RST报文断开链接。<br>这么做的原因是为了节省连接资源，也避免攻击。</p>
<p>但是在实际使用场景中，用户一般使用资源池维护长连接。<br>在连接池中预留部分多余连接是合理的，此部分连接应该保证长期有效。</p>
<p>这就需要用到<strong>TCP的keepalive功能</strong>。<br><a id="more"></a></p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3><p>具体可以通过man 7 tcp查看。</p>
<p>Linux中有三相关配置项，可使用<code>sysctl -a</code>查看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以下单位都为秒</span><br><span class="line">net.ipv4.tcp_keepalive_time = 7200 # 表示在这个时间之后没有数据时启动探测报文</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 75  # 前一个探测报文和后一个探测报文之间的时间间隔</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 9  # 探测的最大次数</span><br></pre></td></tr></table></figure></p>
<p>使用上述配置，表现大概如下：</p>
<p>连接空闲7200s后触发keepalive，发送第一次ACK</p>
<ul>
<li>连接如果正常，对端会回应ACK</li>
<li>连接如果一直正常，会再次等待空闲7200s后发送ACK</li>
<li>如果连接异常，对端未回应ACK，会等待75s后发送第二个ack</li>
<li>如果一直未成功，第9次发送ACK未回应后，发送RST包关闭连接</li>
</ul>
<p>（注意：以上参数在不同系统下表现可能不一致，我们只说linux下的表现。）<br>系统的配置只是默认值。关闭一个连接需要的时间计算公式为：<code>tcp_keepalive_time + tcp_keepalive_probes* tcp_keepalive_intvl</code><br>默认为<code>7200s+9*75s = 2h 11min 15s</code>。</p>
<p>这其中存在两个问题：</p>
<ul>
<li>默认idle时间为2小时超过2个小时才开始keepalive，时间太长了，这个时间内一般应用早已经超时</li>
<li>没有提供全局开启keepalive的选项</li>
</ul>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>如上，Linux中没有提供全局开启keepalive的选项，必须通过setsockopt系统调用针对单独的socket进行设置。<br>TCP socket 中有三个选项和内核对应：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCPKEEPIDLE: 覆盖 tcp_keepalive_time</span><br><span class="line">TCPKEEPINTVL: 覆盖 tcp_keepalive_intvl</span><br><span class="line">TCPKEEPCNT: 覆盖 tcp_keepalive_probes</span><br></pre></td></tr></table></figure></p>
<h3 id="python-demo"><a href="#python-demo" class="headerlink" title="python demo"></a>python demo</h3><p>服务端启动：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -l 9999</span><br></pre></td></tr></table></figure></p>
<p>客户端代码：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">host=<span class="string">'localhost'</span></span><br><span class="line">port=<span class="number">9999</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, <span class="number">1</span>) <span class="comment"># 开启keepalive</span></span><br><span class="line">s.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, <span class="number">5</span>) <span class="comment"># 5s后开始探活</span></span><br><span class="line">s.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, <span class="number">2</span>) <span class="comment"># 探活间隔2s</span></span><br><span class="line">s.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPCNT, <span class="number">10</span>) <span class="comment">#最大次数</span></span><br><span class="line">s.connect((host, port))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"connected to %s:%d"</span> % (host, port)</span><br><span class="line">s.sendall(<span class="string">"hello world!"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">300</span>):</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"sleep for %ds"</span> % i</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">s.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"finish!"</span></span><br></pre></td></tr></table></figure></p>
<p>在运行一段时间后通过iptables阻断通信：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --destination-port 9999 -j DROP</span><br></pre></td></tr></table></figure></p>
<h3 id="抓包查看"><a href="#抓包查看" class="headerlink" title="抓包查看"></a>抓包查看</h3><p>使用tcpdump抓包可看到以下包的交互：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15:23:12.110546 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [S], seq 4140259582, win 65495, options [mss 65495,sackOK,TS val 2989652584 ecr 0,nop,wscale 7], length 0</span><br><span class="line">15:23:12.110564 IP 127.0.0.1.9999 &gt; 127.0.0.1.39455: Flags [S.], seq 1045216537, ack 4140259583, win 65483, options [mss 65495,sackOK,TS val 2989652584 ecr 2989652584,nop,wscale 7], length 0</span><br><span class="line">15:23:12.110576 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989652584 ecr 2989652584], length 0</span><br><span class="line">15:23:12.110634 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [P.], seq 1:13, ack 1, win 512, options [nop,nop,TS val 2989652584 ecr 2989652584], length 12</span><br><span class="line">15:23:12.110642 IP 127.0.0.1.9999 &gt; 127.0.0.1.39455: Flags [.], ack 13, win 512, options [nop,nop,TS val 2989652584 ecr 2989652584], length 0</span><br><span class="line">15:23:17.110179 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989657584 ecr 2989652584], length 0</span><br><span class="line">15:23:17.110193 IP 127.0.0.1.9999 &gt; 127.0.0.1.39455: Flags [.], ack 13, win 512, options [nop,nop,TS val 2989657584 ecr 2989652584], length 0</span><br><span class="line">15:23:22.110187 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989662584 ecr 2989657584], length 0</span><br><span class="line">15:23:22.110200 IP 127.0.0.1.9999 &gt; 127.0.0.1.39455: Flags [.], ack 13, win 512, options [nop,nop,TS val 2989662584 ecr 2989652584], length 0</span><br><span class="line">15:23:27.110191 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989667584 ecr 2989662584], length 0</span><br><span class="line">15:23:29.110457 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989669584 ecr 2989662584], length 0</span><br><span class="line">15:23:31.110451 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989671584 ecr 2989662584], length 0</span><br><span class="line">15:23:33.110178 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989673584 ecr 2989662584], length 0</span><br><span class="line">15:23:35.110429 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989675584 ecr 2989662584], length 0</span><br><span class="line">15:23:37.110459 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989677584 ecr 2989662584], length 0</span><br><span class="line">15:23:39.110433 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989679584 ecr 2989662584], length 0</span><br><span class="line">15:23:41.110452 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989681584 ecr 2989662584], length 0</span><br><span class="line">15:23:43.110428 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989683584 ecr 2989662584], length 0</span><br><span class="line">15:23:45.110449 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989685584 ecr 2989662584], length 0</span><br><span class="line">15:23:47.110448 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [R.], seq 13, ack 1, win 512, options [nop,nop,TS val 2989687584 ecr 2989662584], length 0</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>15:23:12.110546 - 15:23:12.110576为三次握手建立连接</li>
<li>15:23:12.110634 - 15:23:12.110642为数据发送接收ACK</li>
<li>15:23:17.110179 - 15:23:22.110200为5s探活一次，并接收到9999返回的ACK</li>
<li>15:23:26通过iptables阻断掉9999端口</li>
<li>15:23:27.110191 - 15:23:45.110449每隔2s发送一次探活包，但并无应答</li>
<li>15:23:47.110448发送RST包关闭连接</li>
</ul>
<p>抓包分析结果基本与我们预期一致。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="KeepAlive-in-C"><a href="#KeepAlive-in-C" class="headerlink" title="KeepAlive in C"></a>KeepAlive in C</h3><p>C中可以非常简单的通过系统调用对是否开启及3个参数进行配置。<br>C语言实现代码示例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> s;</span><br><span class="line">   <span class="keyword">int</span> optval;</span><br><span class="line">   <span class="keyword">socklen_t</span> optlen = <span class="keyword">sizeof</span>(optval);</span><br><span class="line">   <span class="keyword">int</span> keepAlive = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> keepIdle = <span class="number">5</span>;        <span class="comment">// idle</span></span><br><span class="line">   <span class="keyword">int</span> keepInterval = <span class="number">5</span>;    <span class="comment">// interval</span></span><br><span class="line">   <span class="keyword">int</span> keepCount = <span class="number">3</span>;       <span class="comment">// count</span></span><br><span class="line">   <span class="comment">/* Create the socket */</span></span><br><span class="line">   <span class="keyword">if</span>((s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">"socket()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Check the status for the keepalive option */</span></span><br><span class="line">   <span class="keyword">if</span>(getsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, &amp;optlen) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">"getsockopt()"</span>);</span><br><span class="line">      close(s);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"SO_KEEPALIVE is %s\n"</span>, (optval ? <span class="string">"ON"</span> : <span class="string">"OFF"</span>));</span><br><span class="line">   <span class="comment">/* 设置开启keepalive */</span></span><br><span class="line">   <span class="keyword">if</span>(setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span>*)&amp;keepAlive,<span class="keyword">sizeof</span>(keepAlive)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">      close(s);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"SO_KEEPALIVE set on socket\n"</span>);</span><br><span class="line">   <span class="comment">/* 设置IDLE */</span></span><br><span class="line">   <span class="keyword">if</span>(setsockopt(s, SOL_TCP, TCP_KEEPIDLE, (<span class="keyword">void</span> *)&amp;keepIdle, <span class="keyword">sizeof</span>(keepIdle)) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">      close(s);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 设置INTVL */</span></span><br><span class="line">   <span class="keyword">if</span>(setsockopt(s, SOL_TCP, TCP_KEEPINTVL, (<span class="keyword">void</span> *)&amp;keepInterval, <span class="keyword">sizeof</span>(keepInterval)) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">      close(s);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 设置CNT */</span></span><br><span class="line">   <span class="keyword">if</span>(setsockopt(s, SOL_TCP, TCP_KEEPCNT, (<span class="keyword">void</span> *)&amp;keepCount, <span class="keyword">sizeof</span>(keepCount)) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">      close(s);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Check the status again */</span></span><br><span class="line">   <span class="keyword">if</span>(getsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, &amp;optlen) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">"getsockopt()"</span>);</span><br><span class="line">      close(s);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"SO_KEEPALIVE is %s\n"</span>, (optval ? <span class="string">"ON"</span> : <span class="string">"OFF"</span>));</span><br><span class="line">   close(s);</span><br><span class="line">   <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="KeepAlive-in-Go"><a href="#KeepAlive-in-Go" class="headerlink" title="KeepAlive in Go"></a>KeepAlive in Go</h3><p>Go中net.TCPConn结构提供以下两个参数：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span> <span class="title">SetKeepAlive</span><span class="params">(keepalive <span class="keyword">bool</span>)</span> <span class="title">error</span> // 开启关闭<span class="title">keepalive</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span> <span class="title">SetKeepAlivePeriod</span><span class="params">(d time.Duration)</span> <span class="title">error</span> // 使用相同的值设置<span class="title">IDLE</span>和<span class="title">INTVL</span></span></span><br></pre></td></tr></table></figure></p>
<p>目前不支持设置TCP_KEEPCNT的，其它选项可以方便的配置，代码示例如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetKeepAlivePeriod</span><span class="params">(c *net.Conn, d time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t, ok := c.Sock.(*net.TCPConn); ok &#123; <span class="comment">// 只有TCPConn支持</span></span><br><span class="line">        <span class="keyword">if</span> err := t.SetKeepAlive(d != <span class="number">0</span>); err != <span class="literal">nil</span> &#123; <span class="comment">// 设置开启</span></span><br><span class="line">            <span class="keyword">return</span> errors.Trace(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> d != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := t.SetKeepAlivePeriod(d); err != <span class="literal">nil</span> &#123; <span class="comment">// 设置参数</span></span><br><span class="line">                <span class="keyword">return</span> errors.Trace(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><ul>
<li>合理配置，不要探测太频繁，太频繁是对网络资源的浪费</li>
<li>不要滥用，是对连接资源的浪费，资源池中还是应该使用合理的连接数</li>
<li>还是需要对连接的异常进程处理，不能完全保证连接的可用</li>
</ul>
<h3 id="与HTTP-keepalive"><a href="#与HTTP-keepalive" class="headerlink" title="与HTTP keepalive"></a>与HTTP keepalive</h3><p>TCP的keep alive与HTTP的keep alive不是一个概念。<br>HTTP的keep alive功能指的是HTTP 1.1后,请求默认是使用持久连接，即服务器在响应后保持连接，后续的请求通过该连接继续传输，减少建立连接的开销。</p>
<h3 id="与重传"><a href="#与重传" class="headerlink" title="与重传"></a>与重传</h3><p>如果发送方发送的数据包没有收到接收方回复的ACK数据包，此时TCP keepalive机制并不会被启动，而是启动超时重传机制。而因为重传也算作网络传输，因此就使得TCP Keep-alive机制在未收到ACK包时失效。</p>
<h3 id="与应用层心跳"><a href="#与应用层心跳" class="headerlink" title="与应用层心跳"></a>与应用层心跳</h3><p>不能取代应用层心跳。因为：</p>
<ul>
<li>keepalive某些场景下会失效</li>
<li>应用层心跳更有效，keepalive只能保证连接层的有效，而实际场景中连接可能有效，但服务已经无法响应</li>
<li>应用层心跳可用实现更个性化的功能</li>
</ul>
<p>连接测试<br>既然连接池中的连接不能保证一定有些，那可不可以在每次使用前增加检测呢？例如jedispool就提供了TestOnBorrow、TestOnBorrow、TestWhileIdle三个选项，提供在特定场景下对连接测试的功能。<br>但是不建议使用。<br>原因是：</p>
<ul>
<li>连接正常的场景下，相当于浪费一次RTT，增加了延迟</li>
<li>检测过后，也不能保证连接一定有效<br>因此还是建议开启keepalive配合完善的异常处理、重试的方式实现。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TCP keepalive通过在空闲时发送ACK数据包，然后对方回应ACK来实现连接的包含。尤其适用于有中间设备的长连接通信。<br>使用方便，除设置选项后应用无需做出任何改变，也更轻量。但是不能完全取代应用层心跳。<br>适合用来做连接保活，很难用于做探活。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html" target="_blank" rel="noopener">Using TCP keep alive under Linux</a></p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>keepalive</tag>
        <tag>vip</tag>
        <tag>LVS</tag>
      </tags>
  </entry>
  <entry>
    <title>Kolla：Openstack容器化部署简介</title>
    <url>/2016/03/openstack-kolla-intro/</url>
    <content><![CDATA[<p><a href="https://github.com/openstack/kolla" target="_blank" rel="noopener">Kolla</a>是Openstack的容器化部署项目。</p>
<p>本文主要对Kolla项目进行简单介绍，对其诞生的意义、内部的大概实现做出介绍，以便于读者快速理解项目以投入使用、快速进行自定义开发。</p>
<p>以下主要针对Kolla的Mitaka版本。开始写这篇文章时，Mitaka还尚未发布，因此使用的其实是master版本。</p>
<h2 id="为什么要做容器化部署"><a href="#为什么要做容器化部署" class="headerlink" title="为什么要做容器化部署"></a>为什么要做容器化部署</h2><h3 id="Openstack之美"><a href="#Openstack之美" class="headerlink" title="Openstack之美"></a>Openstack之美</h3><p>参考下图，OpenStack的架构设计是很漂亮的：清晰定义的服务，完美的原子操作，独立运行的可能，组件尽量无状态易于扩展。这是一个几乎做到极致的分布式架构。<br><img src="/img/the-beauty-of-openstack.png" alt="the beauty of openstack"></p>
<h3 id="Openstack之殇"><a href="#Openstack之殇" class="headerlink" title="Openstack之殇"></a>Openstack之殇</h3><p>但是现实是残酷的：</p>
<ul>
<li>服务之间往往有严重的依赖，使得部署复杂，修改麻烦，服务的管理困难；</li>
<li>配置复杂，有时候可能仅仅是一个微小的配置错误，就会导致整个集群功能异常；</li>
<li>而且随着OpenStack的发展，架构及配置只会越来越复杂。</li>
</ul>
<p>运维成本很高，效率低，严重影响了使用体验。<br><a id="more"></a><br><img src="/img/the-reality-of-openstack.png" alt="The Reality of OpenStack"><br>生产环境一旦部署完成很难去做大的升级。所以虽然每半年社区更新一个版本（目前马上M版本），但是真正生产环境可能还是I甚至E版本。对于每个组件，只做微小bug的升级，而且升级流程会非常谨慎。对于私有云产品也许还可以，但对于有大量用户严格SLA的公有云产品这是无法容忍的。这也是为什么说Openstack厂商离AWS、阿里云甚至UCloud这些大的公有云厂商还有很大的距离。<br>举个例子，如果我们要升级keystone这个基础组件——它是Openstack的认证组件，负载整个Openstack集群的鉴权，因此非常重要。<br>我们首先需要去判断这个版本的keystone和环境中使用的其它组件的当前版本是否完全兼容。而事实证明官方文档介绍很少，也是靠不住的，社区等着你发现bug做贡献呢；开发人员做出的估计有些也是不靠谱的，可以自行统计下每个组件的代码量；甚至简单的测试都不足够可靠，用例库也是逐渐总结出来的。这也说明了引入灰度上线和回滚机制是很有必要的。但是以现有的运维工具，回滚比较困难而且代价很大。因此一般在升级前都要做严格的升级测试，会有资源和人力的成本。</p>
<h3 id="容器的崛起"><a href="#容器的崛起" class="headerlink" title="容器的崛起"></a>容器的崛起</h3><p>虽然使用已有的一些OpenStack自动化部署工具，如puppet、fuel等，但往往只能部分解决这些问题，如不支持回滚、太重而导致资源浪费、体积太大速度缓慢等。<br>而docker在解决所有这些问题上具有很大的优势：</p>
<ul>
<li>服务直接的相互隔离</li>
<li>轻量级，节省资源，体积小便捷易携带迁移</li>
<li>容易描述的运行时关系</li>
<li>容易升级回滚，可灰度上线，对服务完整的生命周期管理</li>
<li>不只局限于OpenStack，对其它服务如HA等也适用</li>
<li>而通过与Kubernetes、服务发现等容器技术栈的高级工具组合，能提供更强大的解决方案</li>
</ul>
<p>当然还有容器的火爆发展，OpenStack社区怎么可能错过。</p>
<p><strong>下图对以上所有做了个很好的总结：</strong><br><img src="/img/docker-background.png" alt="Kolla Backgroud"></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>Kolla中使用到的技术栈总结如下。</p>
<ul>
<li>Docker，容器化基础工具</li>
<li>Ansible，配置管理，主要用于生成配置文件</li>
<li>Jinja，模板工具</li>
<li>Kubernetes/Mesos，Openstack社区或者说很多开源社区的特点就是：大而全的策略，可以预言：容器领域内所有火的组件慢慢都会在Kolla中出现，而且它们确实能组合出强大的功能。</li>
</ul>
<h3 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h3><p>Docker是通过Linux内核如LXC、namespace等实现的容器化技术。关于Docker的详细请参考docker系列文章或官方文档。<br><img src="/img/docker-internal.png" alt="docker内部组件"><br>通过Docker镜像，可以方便的对image进行版本管理。而且因为image的分层特性，体积较小，容易携带和分享。Docker的这些特性使得它非常适合于CI（持续集成/持续）/CD（持续部署/交付）系统，替换原来较重效率低得物理机或虚拟机方案。<br><img src="/img/docker-stages.png" alt="docker"><br>在Kolla中，用到了超权限容器（super privileged containers），因为部分组件直接访问宿主机的资源而不是使用自己的命名空间，如libvirt需要访问宿主机的网络空间来创建虚拟机。但是除非必要，对容器需要严格的权限控制以保证安全。<a href="http://developers.redhat.com/blog/2014/11/06/introducing-a-super-privileged-container-concept/" target="_blank" rel="noopener">参考</a></p>
<h3 id="Ansible简介"><a href="#Ansible简介" class="headerlink" title="Ansible简介"></a>Ansible简介</h3><h4 id="Ansible-组成"><a href="#Ansible-组成" class="headerlink" title="Ansible 组成"></a>Ansible 组成</h4><p>Ansible主要由以下部分组成：</p>
<ul>
<li>Inventory: 资产配置库,定义可管控的主机列表</li>
<li>Modules: core modules（自带模块）、custom modules(自定义模块)</li>
<li>Playbooks: 按照所设定编排的顺序执行完成安排任务</li>
</ul>
<p><img src="/img/ansible-arch.png" alt="ansible架构"></p>
<h4 id="Inventory"><a href="#Inventory" class="headerlink" title="Inventory"></a>Inventory</h4><p>资产配置文件,用来定义你要管理的主机,文件采用 INI 格式。 </p>
<ul>
<li>被管理的机器可以通过其IP或域名指定</li>
<li>未分组的机器需保留在hosts的顶部</li>
<li>分组可以使用<code>[]</code>指定</li>
<li>分组也能嵌套</li>
<li>也可以通过数字和字母模式来指定一系列连续主机，支持从一些外围组件获取动态的Inventory,如Ansible Tower。</li>
</ul>
<h4 id="Playbook"><a href="#Playbook" class="headerlink" title="Playbook"></a>Playbook</h4><p>Playbook为YMAL格式，语法简单：</p>
<ul>
<li>在ansible中几乎所有的yaml文件都是以list开始,每个item是键值对的list。</li>
<li>所有的yaml文件都以<code>---</code>开头表示开始一个document,所有的列表元素以-开头,键值对用冒号,冒号后面的空格是必须的</li>
<li>键值对中的值如果是bool类型的字符串<code>true/false</code>(首字母不论大小写),会load成python中对应的bool值</li>
<li>在键值对中如果值中有冒号或者以两个大括号开头的变量定义,则必须用引号引起来</li>
</ul>
<p>Playbook由若干Play组成,每一个Play是对一个或一组主机进行一系列动作,Play从上到下依次执行,从而完成部署、配置和编排。每个Play大致结构如下:</p>
<ul>
<li>Host and Users – 指定操作的主机及使用的用户</li>
<li>Tasks – 每个Task有Name用于在执行时显示,及具体的Action调用module执行实际任务。</li>
<li>Handlers – 何时触发或notify触发别的动作,从而建立依赖关系一个Playbook文件可以通过include引入其他的yml文件,实现复用。</li>
</ul>
<h4 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h4><p>Ansible自1.2版本引入的新特性,用于层次性、结构化地组织Playbook。<br>Roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。而要使用Roles只需要在Playbook中使用roles指令即可。<br>简单来讲,Roles就是通过分别将变量、文件、任务、模块及处理器放置于单独的目录中,并可以便捷地引用它们的一种机制。</p>
<h4 id="Best-Practise"><a href="#Best-Practise" class="headerlink" title="Best Practise"></a>Best Practise</h4><p>一个标准的目录结构如下图。<br><img src="/img/ansible-best-practise.png" alt="Ansible标准目录结构"></p>
<h2 id="Kolla"><a href="#Kolla" class="headerlink" title="Kolla"></a>Kolla</h2><p>基于上面的因素，结合容器技术近几年的快速发展，Openstack社区诞生了Kolla项目。<br>Kolla的使命如下：</p>
<blockquote>
<p>Kolla provides <strong>production-ready</strong> containers and deployment tools for operating OpenStack clouds.</p>
</blockquote>
<p>Kolla通过提供容器和Ansible的playbook来完成使命。Kolla被尽力设计为开箱即用，但又支持深度的自定义。这使得具有很少OpenStack经验的人员也可以轻易的部署并使用OpenStack，并随着经验的增长进行个性化定义以满足更高的需求。<br>Kolla不只简化了部署，也简化了操作。</p>
<h3 id="Kolla安装"><a href="#Kolla安装" class="headerlink" title="Kolla安装"></a>Kolla安装</h3><p>建议使用Mitaka之后的版本，因为M版本相对之前版本变动较大，之前基本相当于演示版本。<br>因项目变化很快，不做详述，请参考官方文档：<a href="http://docs.openstack.org/developer/kolla/quickstart.html" target="_blank" rel="noopener">kolla quickstart</a></p>
<h3 id="Kolla架构"><a href="#Kolla架构" class="headerlink" title="Kolla架构"></a>Kolla架构</h3><p><img src="/img/kolla-arch.png" alt="Kolla architecture"></p>
<p>其中绿色的组件是kolla提供的，蓝色组件由其它开源软件提供。<br>基本工作流如下：</p>
<ol>
<li>开发人员提交代码到gerrit，被review通过后merge至git</li>
<li>CD系统build出软件包（如RPM、DEB等）</li>
<li>CD系统使用软件包生成docker镜像</li>
<li>CD提交镜像到私有docker registry</li>
<li>CD系统触发节点上的镜像升级</li>
<li>Ansible下载最新镜像并更新容器，完成升级</li>
</ol>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>比较重要的目录如下。</p>
<ul>
<li>ansible – ansible相关文件,包括资产配置文件、变量文件、扩展库、Roles、Playbooks</li>
<li>docker – docker 相关文件,主要包括 Dockerfile 和其它需要在 build 镜像时添加的文<br>件</li>
<li>etc – kolla 自己的配置文件</li>
<li>kolla – kolla 封装的工具,如 build.py 用于 build 镜像等</li>
<li>tools – 其它一些工具,部分已迁移至 kolla 目录,目前主要是一些开发测试用工具</li>
</ul>
<p>以下详细介绍。</p>
<h3 id="ansible"><a href="#ansible" class="headerlink" title="ansible"></a>ansible</h3><p>此目录下是一个标准的 ansible 项目,主要包含如下目录及文件。</p>
<ul>
<li>action_plugins – action 扩展插件</li>
<li>group_vars – 全局变量</li>
<li>inventory – 资产配置文件,主要包含 all-in-one 和 multinode 两个,实际环境中使用时需要保证主机名的正确对应。</li>
<li>library – 扩展 ansible module</li>
<li>roles – 每个模块对应的 role</li>
<li>*.yml - 若干 Playbook,其中针对 zeus,编写了单独的 Playbook,执行需要通过-p 指</li>
</ul>
<p>我们需要在 roles 目录下添加对应的 role,使用了官方推荐的目录结构,其中一个 role 的结构如 下:</p>
<ul>
<li>defaults – 变量默认值</li>
<li>meta – 依赖</li>
<li>tasks–task列表,入口在main.yml,目前支持的action包括deploy、pull、upgrade、reconfigure,每个 action 对应一个 task 文件。</li>
<li>templates – 使用到的配置文件模板,及生成 config.json 需要的模板文件。</li>
</ul>
<p>需要注意一个叫做 common 的 role,其它的 role 大多依赖它,其中包含的内容有:</p>
<ul>
<li>kolla-toolbox – 其中装有所有 client,主要用来注册 endpoint 和操作数据库</li>
<li>heka – 用来收集日志,Docker 镜像 build 时需要去 s3 下载 rpm 包,已被墙</li>
<li>cron – 用来执行定时任务<br>设置配置项 common_run: True,可以指定不执行 common 相关的任务,但没找到有选项去具体控制使用哪个组件。<br>kolla-toolbox是我们必须的。所以只能使用代码注释的办法,注释掉 heka 和 cron 相关代码。</li>
</ul>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>此目录下主要为各模块对应的Dockerfile模板及其它build镜像时需要的文件。<br>Dockerfile模板使用的是Jinja2 模板,其中包含变量,用于根据参数判断,在部署时由ansible 根据参数及配置动态生成。<br>基础镜像在 base 目录下,其中主要是基本配置及安装基本软件包。其余镜像基本集成自base。<br>如果具体组件依赖不同,可自定义base镜像使用。<br>Docker镜像中用到两个比较重要的脚本:start.sh(base)和 extend_start.sh(具体镜像),其作用及实现原理见第 5 节。</p>
<h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><p>使用 kolla 时,我们一般不直接使用 docker 及 ansible,而是使用封装后的命令:</p>
<ul>
<li>kolla/cmd/build.py – 用于 build 镜像,对 <code>docker build</code> 进行了封装</li>
<li>tools/kolla-ansible – 对 ansible 的封装</li>
</ul>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>推荐使用的依赖版本,其它版本可能会有各种问题。 </p>
<ul>
<li>操作系统 – 推荐宿主机器使用centos7。centos6下经过一番折腾也能安装成功，但是各种问题真心不建议使用，或者升级内核。如果有需要可以在容器内运行centos6。</li>
<li>Docker版本 – 推荐从docker官网安装新版本。 </li>
<li>Ansible – 1.9.4</li>
<li>Docker Python – 1.6.0</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="添加配置项"><a href="#添加配置项" class="headerlink" title="添加配置项"></a>添加配置项</h3><ul>
<li><code>roles/templates/*.j2</code> – 一般是在配置文件中使用,配置文件一般为Jinja模板,使用类似Django模板的语法</li>
<li><code>roles/defaults/main.yml</code> – 配置默认值</li>
<li><code>group_vars/all.yml</code> – 全局默认值</li>
<li><code>globals.yml</code>或<code>passwords.yml</code>中。</li>
</ul>
<p>另外,在config.yml的对应任务中也可以看到,在实际生成配置文件时,还用到了其它一些文件,<br>如Nova下:</p>
<ul>
<li><code>/etc/kolla/config/global.conf</code></li>
<li><code>/etc/kolla/config/database.conf</code></li>
<li><code>/etc/kolla/config/messaging.conf</code></li>
<li><code>/etc/kolla/config/nova.conf</code></li>
<li><code>/etc/kolla/config/nova/.conf</code></li>
</ul>
<p>也可以在这些文件中添加配置,而覆盖ansible生成的配置,或添加缺少的配置。</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>以cinder-api为例：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &#123;&#123; namespace &#125;&#125;/&#123;&#123; image_prefix &#125;&#125;cinder-base:&#123;&#123; tag &#125;&#125;</span><br><span class="line"><span class="keyword">MAINTAINER</span> &#123;&#123; <span class="keyword">maintainer</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if install_type == <span class="string">'binary'</span> %&#125;</span><br><span class="line">    &#123;% if base_distro in [<span class="string">'centos'</span>, <span class="string">'fedora'</span>, <span class="string">'oraclelinux'</span>, <span class="string">'rhel'</span>] %&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install -y python-keystone \</span></span><br><span class="line"><span class="bash">  &amp;&amp; yum clean all</span></span><br><span class="line"></span><br><span class="line">    &#123;% elif base_distro in [<span class="string">'ubuntu'</span>] %&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y --no-install-recommends \</span></span><br><span class="line"><span class="bash">        cinder-api \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get clean</span></span><br><span class="line"></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> extend_start.sh /usr/<span class="built_in">local</span>/bin/kolla_cinder_extend_start</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod 755 /usr/<span class="built_in">local</span>/bin/kolla_cinder_extend_start</span></span><br><span class="line"></span><br><span class="line">&#123;&#123; include_footer &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> cinder</span><br></pre></td></tr></table></figure></p>
<p>其中除了设置相关信息外，还做了这些事：</p>
<ol>
<li>继承cinder-base<br>cinder-base位于kolla/docker/cinder/cinder-base目录下。<br>cinder-base继承自openstack-base，openstack-base继承自base。<br>base中主要安装基础包（如python）、设置源、执行set_configs.py（验证并通过config.json生成配置文件）、执行start.sh。<br>openstack-base中主要做大多数服务通用的动作，如安装openstack的基础依赖包等。<br>cinder-base中主要做cinder服务通用的动作，如安装cinder-common、设置sudoer文件等。<br>同时我们看到对docker的tag的支持。</li>
<li>安装软件包<br>通过识别操作系统类型，安装对应的包。<br>如果研究下cinder-base的内容，可看到对源码安装的支持。</li>
<li>执行需要的命令<br>base中设置了通过CMD执行start.sh。cinder-base中通过CMD执行extend_start.sh。<br>其中服务的启动主要在start.sh中，而需要的其它工作如db_sync主要在extend_start中执行。</li>
</ol>
<h3 id="Playbook-Role"><a href="#Playbook-Role" class="headerlink" title="Playbook/Role"></a>Playbook/Role</h3><p>TODO</p>
<h2 id="配置及部署"><a href="#配置及部署" class="headerlink" title="配置及部署"></a>配置及部署</h2><p>在部署时，我们主要配置哪些文件呢？</p>
<ul>
<li>globals.yml<br>其中配置必须的变量,但一般不包含密码。</li>
<li>passwords.yml<br>其中配置需要的密码。</li>
<li><p>资产配置文件<br>ansible/inventory目录下，使用主机名指定，在实际使用时需要保证主机名的对应。也可根据实际需要进行主机、分组等的调整。另一个可能使用到的是禁用某个组件，如禁用ceilometer-compute: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># disable by default</span><br><span class="line">[ceilometer-compute:children]</span><br><span class="line">#ceilometer</span><br></pre></td></tr></table></figure>
</li>
<li><p>kolla-build.conf<br>指定 build 使用的源,可以使用 rpm 包或 repo 文件。<br>如不知道会使用 delorean 源,其内容为社区最近 build 出的 master 分支的 RPM 包: Delorean is a tool to build rpm packages on each commit of a set of git repositories. 建议根据需要指定使用rdo的源。<br>在 build 时通过–config-file=参数指定使用的 kolla-build.conf。</p>
</li>
</ul>
<h2 id="项目现状"><a href="#项目现状" class="headerlink" title="项目现状"></a>项目现状</h2><p>TODO</p>
<h2 id="参考索引"><a href="#参考索引" class="headerlink" title="参考索引"></a>参考索引</h2><ul>
<li><a href="https://github.com/openstack/kolla" target="_blank" rel="noopener">Kolla项目github地址</a></li>
<li><a href="http://docs.openstack.org/developer/kolla/index.html" target="_blank" rel="noopener">Openstack Kolla Docs</a></li>
<li><a href="http://www.slideshare.net/daneyonhansen/openstack-kolla-introduction" target="_blank" rel="noopener">Kolla Introduction PPT</a></li>
<li><a href="https://www.ansible.com/blog/openstack-kolla" target="_blank" rel="noopener">Openstack Kolla: Dependency Management Done Right With Docker And Ansible</a></li>
<li><a href="https://allthingsopen.com/2014/10/22/a-demonstration-of-kolla-docker-and-kubernetes-based-deployment-of-openstack-services-on-atomic/" target="_blank" rel="noopener">A Demonstration of Kolla: Docker and Kubernetes based Deployment</a></li>
<li><a href="http://www.chenshake.com/openstack-project-series-2-kolla/" target="_blank" rel="noopener">陈沙克日志对Kolla介绍</a></li>
</ul>
]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>openstack</tag>
        <tag>kolla</tag>
        <tag>docker</tag>
        <tag>容器化</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之七：curl基本使用实例之发布文章到百度空间</title>
    <url>/2012/08/linux-curl-example-post-to-baidu-hi/</url>
    <content><![CDATA[<p>前六篇之后，我们对curl的基本使用已经有了一定的了解。下面我们就在实际场景中使用我们的所学。<br>本篇实例目标为编写linux脚本,使用curl完成发布文章至百度空间。<br>下文将从百度空间登陆到发表文章，对每个过程的HTTP进行分析，并编写脚本实现。</p>
<h2 id="工欲善其事，必先利其器"><a href="#工欲善其事，必先利其器" class="headerlink" title="工欲善其事，必先利其器"></a>工欲善其事，必先利其器</h2><p>抓包分析我们使用chrome自带的Developer Tools。<br>实际分析过程中最好把Developer Tools的Network标签左下角的“Preserve Log upon Navigation”选中，如下图圈中处：<br><img src="/img/developertoolspreserve.jpg" alt="Chrome Developer Tools Preserve Log upon Navigation"><br>单击变为红色即可。<br>此选项的作用在于当当前页面跳转到其他网页时，保存原来的日志记录。<br>默认不保存，比如在登陆成功一个网站后，自动跳转到其他网页，这样登陆网站过程中的记录都不保存。我们就没有办法对登陆过程进行具体分析。</p>
<h2 id="POST登陆"><a href="#POST登陆" class="headerlink" title="POST登陆"></a>POST登陆</h2><h3 id="1-操作过程"><a href="#1-操作过程" class="headerlink" title="1. 操作过程"></a>1. 操作过程</h3><p>登陆我们采用网址<code>https://passport.baidu.com/?login</code>，而不使用网址<code>http://hi.baidu.com/index.htm</code>或<code>http://hi.baidu.com/go/login</code> 右侧的登陆框。<br>这是因为后者可能因为百度空间改版等原因改变，而前者是百度账号的登陆界面，变化的几率要小。而且后者界面很多图片等元素，不利于我们抓包分析。</p>
<h3 id="2-登陆过程分析"><a href="#2-登陆过程分析" class="headerlink" title="2. 登陆过程分析"></a>2. 登陆过程分析</h3><p>登陆成功后找到<code>/?login</code>的POST包，如下图：<br><img src="/img/DeveloperToolsBaiduLogin.jpg" alt="Developer Tools Baidu Login HTTP Analy"><br>主要显示了状态信息、请求头部（Request Headers）、POST数据（Form Data）和响应头部（Response Heades）。<br>Query String Parameters是对GET的参数的解析，即网址中的?login。一般网址中“?”后面的都应该是参数，具体请参考Linux下cURL使用教程之二：HTTP协议概述中“GET命令”一节。<br><a id="more"></a><br>请求头部如下（view source模式）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /?login HTTP/1.1 Host: passport.baidu.com Connection: keep-alive Content-Length: 215 Cache-Control: max-age=0 Origin: https://passport.baidu.com User-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.168 Safari/535.19 Content-Type: application/x-www-form-urlencoded Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Referer: https://passport.baidu.com/?login Accept-Encoding: gzip,deflate,sdch Accept-Language: zh-CN,zh;q=0.8 Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3 Cookie: BAIDU_WISE_UID=...无关cookie代码，很长，略去</span><br></pre></td></tr></table></figure></p>
<p>POST数据如下（view decoded模式，因为curl可以完成urlencode，我们发送明文即可）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tpl_ok:</span><br><span class="line">next_target:</span><br><span class="line">tpl:</span><br><span class="line">skip_ok:</span><br><span class="line">aid:</span><br><span class="line">need_pay:</span><br><span class="line">need_coin:</span><br><span class="line">pay_method:</span><br><span class="line">u: .%2F</span><br><span class="line">return_method: get</span><br><span class="line">more_param:</span><br><span class="line">return_type:</span><br><span class="line">psp_tt: 0</span><br><span class="line">password: youcan&apos;tsee</span><br><span class="line">safeflg: 0</span><br><span class="line">isphone: false</span><br><span class="line">username: Stackeye</span><br><span class="line">verifycode:</span><br><span class="line">mem_pass: on</span><br></pre></td></tr></table></figure></p>
<h3 id="3-登陆过程curl脚本"><a href="#3-登陆过程curl脚本" class="headerlink" title="3. 登陆过程curl脚本"></a>3. 登陆过程curl脚本</h3><p>百度要求的不严格，因此我们不考虑来源页面（Referer）等信息，只注意隐藏User-Agent字段。同时保存cookie供后续使用。脚本如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o baidu001.html -D bdcookie001.txt \</span><br><span class="line">--data-urlencode username=<span class="variable">$username</span> \</span><br><span class="line">--data-urlencode password=<span class="variable">$password</span> \</span><br><span class="line">--data-urlencode mem_pass=on \</span><br><span class="line">https://passport.baidu.com/?login</span><br></pre></td></tr></table></figure></p>
<p>实验发现其他字段非必要，因此舍弃。</p>
<h2 id="POST发表文章"><a href="#POST发表文章" class="headerlink" title="POST发表文章"></a>POST发表文章</h2><h3 id="1-操作过程-1"><a href="#1-操作过程-1" class="headerlink" title="1. 操作过程"></a>1. 操作过程</h3><p>点击“我的空间”，进入<a href="http://hi.baidu.com/home，然后点击“文字“，进入到`http://hi.baidu.com/pub/show/createtext`，随便写些内容，右侧加些标签，发表即可。" target="_blank" rel="noopener">http://hi.baidu.com/home，然后点击“文字“，进入到`http://hi.baidu.com/pub/show/createtext`，随便写些内容，右侧加些标签，发表即可。</a></p>
<h3 id="2-过程分析"><a href="#2-过程分析" class="headerlink" title="2. 过程分析"></a>2. 过程分析</h3><p>找到对createtext的POST包。POST的url为<code>http://hi.baidu.com/pub/submit/createtext</code>。<br>请求头中没有我们关心的字段：cookie不用具体分析，Referer等字段我们不去关注。</p>
<p>POST数据如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Stackeye&apos;s title</span><br><span class="line">tags[]: stackeyetag</span><br><span class="line">content: &lt;p&gt;Stackeye&amp;#39;s&amp;nbsp;content&lt;/p&gt;&lt;p&gt;This&amp;nbsp;is&amp;nbsp;for&amp;nbsp;curl&amp;nbsp;learning&amp;nbsp;test.&lt;/p&gt;</span><br><span class="line">private: 0</span><br><span class="line">imgnum: 0</span><br><span class="line">bdstoken: 01ae260f7a99a896a16dfa8d9f75cf16</span><br><span class="line">qbid:</span><br><span class="line">refer: http://hi.baidu.com/home</span><br><span class="line">multimedia[]: undefined#undefined#undefined#undefined</span><br><span class="line">private1: 0</span><br><span class="line">qing_request_source:</span><br></pre></td></tr></table></figure></p>
<p>title是文章标题，tags是标签，content是内容。<br>除此之外还有一个bdstoken字段猜不出其含义。多次测试发现，其他字段基本固定，而bdstoken字段在每次退出重新登陆后就会发生变化。<br>这种字段来源有三种可能性：</p>
<ul>
<li>此字段没有实际意义<br>比如只是个简单的标志，服务器端并不校验此字段值。</li>
<li>服务器生成，然后在POST之前传给客户端<br>需要我们分析POST之前数据包的响应数据。因为可能的数据包不多（一般来讲，图片、css、js等的包可以直接排除）。</li>
<li>POST之前的某个网页动态生成<br>比如此网页或之前的某个网页上的js、Ajax等在客户端执行的函数生成。<br>这个需要审视此网页和之前的每个网页中的js等代码，甚至需要动态调试，比较麻烦。因此我们最后考虑这种情况。</li>
</ul>
<h3 id="3-寻找bdstoken字段"><a href="#3-寻找bdstoken字段" class="headerlink" title="3. 寻找bdstoken字段"></a>3. 寻找bdstoken字段</h3><p>编写脚本，bdstoken传递格式类似的随机值，文章发表失败。<br>寻找之前的数据包，我们从后向前找，查找每个text/html等网页类型的数据包的Response内容。<br>Developer Tools的搜索功能搜索不到，可以右键数据包”save all as har“保存为har文件，用记事本打开即可查找。但是不能批量保存，比较繁琐。<br>更简单的解决方式是使用wireshark抓包，wireshark的字符串搜索可以搜索到。<br>我们很快找到在GET的createtext页面（<code>http://hi.baidu.com/pub/show/createtext</code>）里有bdstoken字段，GET及bdstoken取出语句：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#get bdstoken</span></span><br><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o baidu002.html \</span><br><span class="line">-D bdcookie002.txt -b bdcookie001.txt \</span><br><span class="line">http://hi.baidu.com/pub/show/createtext</span><br><span class="line">bdstoken=<span class="string">""</span></span><br><span class="line"><span class="comment">#`cat baidu002.html |grep bdstoken=|awk -F "bdstoken=" '&#123;print $2&#125;'|awk -F "\&amp;" '&#123;print $1&#125;'`</span></span><br><span class="line"><span class="built_in">echo</span> bdstoken=<span class="variable">$bdstoken</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#check before submit</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$bdstoken</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"error in getting bdstoken"</span>;</span><br><span class="line">    <span class="built_in">exit</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p>脚本中使用了awk用于从html代码中提取bdstoken字段，HTML中相关内容为：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://passport.baidu.com?logout&amp;bdstoken=393d8ef656bf74c8f739aa3ae5262f94&amp;u=http://hi.baidu.com/pub/show/createtext"</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>“bdstoken=”作为前分割标志，“&amp;”作为结束标志即可。</p>
<h3 id="4-curl脚本"><a href="#4-curl脚本" class="headerlink" title="4. curl脚本"></a>4. curl脚本</h3><ul>
<li><p>POST过程<br>使用的cookie是第一版步产生的bdcookie001<br>这是因为基本上只有第一步登陆的过程产生重要的cookie信息，其他步产生的cookie是非必须的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title=<span class="string">"Stackeye's title"</span></span><br><span class="line">content=<span class="string">"Stackeye's content!&lt;p&gt;This is for curl learning test."</span></span><br><span class="line">tags=<span class="string">"testtags"</span></span><br><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -e http://hi.baidu.com/pub/show/createtext \</span><br><span class="line">-o baidu003.html -D bdcookie003.txt -b bdcookie001.txt \</span><br><span class="line">--data-urlencode title=<span class="string">"<span class="variable">$title</span>"</span> \</span><br><span class="line">--data-urlencode tags[]=<span class="variable">$tags</span> \</span><br><span class="line">--data-urlencode content=<span class="string">"<span class="variable">$content</span>"</span> \</span><br><span class="line">--data-urlencode private=0 \</span><br><span class="line">--data-urlencode imgnum=0 \</span><br><span class="line">--data-urlencode bdstoken=<span class="variable">$bdstoken</span> \</span><br><span class="line">--data-urlencode qbid= \</span><br><span class="line">--data-urlencode refer=http://hi.baidu.com/home \</span><br><span class="line">--data-urlencode multimedia[]=:undefined<span class="comment">#undefined#undefined#undefined \</span></span><br><span class="line">--data-urlencode private1=0 \</span><br><span class="line">--data-urlencode qing_request_source= \</span><br><span class="line">http://hi.baidu.com/pub/submit/createtext</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证成功与否：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#result</span></span><br><span class="line">result=`cat baidu003.html |awk -F <span class="string">": \""</span> <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"\""</span> <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$result</span> -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Success!"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Fail!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>资源清理语句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -f baidu001.html baidu002.html baidu003.html</span><br><span class="line">rm -f bdcookie001.txt bdcookie002.txt bdcookie003.txt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="1-POST文章时，title、content中不能含有特殊字符"><a href="#1-POST文章时，title、content中不能含有特殊字符" class="headerlink" title="1. POST文章时，title、content中不能含有特殊字符"></a>1. POST文章时，title、content中不能含有特殊字符</h3><p>title、content中不能含有双引号不能转义的特殊字符，如$,\,<code>。
单引号不转义除单引号之外的所有特殊字符。而且在title=&quot;Stackeye&#39;s title&quot;和--data-urlencode title=&quot;$title&quot; \两处都使用单引号的会出现错误。
因此如果实际应用的话，还需要另外一个特殊字符替换函数，替换$,\,</code>和双引号。<br>shell脚本对大批量文字的处理比较繁琐吃力。<br>因此实际场景中，遇到对文字处理较多的场景，shell脚本+curl的方式只作为测试手段探究原理与逻辑，程序使用Java、PHP、Python、C等更强大的语言实现。</p>
<h3 id="2-没有错误重试"><a href="#2-没有错误重试" class="headerlink" title="2. 没有错误重试"></a>2. 没有错误重试</h3><p>可以使用如下循环进行错误重试：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#retry after fail</span></span><br><span class="line">COUNTER=0</span><br><span class="line"><span class="comment">#当失败时循环5次</span></span><br><span class="line"><span class="keyword">while</span> [ fail ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$COUNTER</span> -gt 5 ];<span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> error</span><br><span class="line">                <span class="built_in">exit</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        sleep 60</span><br><span class="line">        <span class="comment">#curl语句</span></span><br><span class="line">        COUNTER=`expr <span class="variable">$COUNTER</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-文件权限"><a href="#3-文件权限" class="headerlink" title="3. 文件权限"></a>3. 文件权限</h3><p>文件中保存有账户密码，记得设置文件属性为700，避免密码泄露。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>完整脚本如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"By Stackeye's blog"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"www.stackeye.com"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Change the file mod to 700 to keep your password safe!"</span></span><br><span class="line"></span><br><span class="line">username=<span class="string">""</span></span><br><span class="line">password=<span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#login</span></span><br><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o baidu001.html -D bdcookie001.txt \</span><br><span class="line">--data-urlencode username=<span class="variable">$username</span> \</span><br><span class="line">--data-urlencode password=<span class="variable">$password</span> \</span><br><span class="line">--data-urlencode mem_pass=on \</span><br><span class="line">https://passport.baidu.com/?login</span><br><span class="line"></span><br><span class="line"><span class="comment">#get bdstoken</span></span><br><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o baidu002.html \</span><br><span class="line">-D bdcookie002.txt -b bdcookie001.txt \</span><br><span class="line">http://hi.baidu.com/pub/show/createtext</span><br><span class="line">bdstoken=`cat baidu002.html |grep bdstoken=|awk -F <span class="string">"bdstoken="</span> <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"\&amp;"</span> <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"><span class="built_in">echo</span> bdstoken=<span class="variable">$bdstoken</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#submit the article</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$bdstoken</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"error in getting bdstoken"</span>;</span><br><span class="line">    <span class="built_in">exit</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">title=<span class="string">"Stackeye's title"</span></span><br><span class="line">content=<span class="string">"Stackeye's content!&lt;p&gt;This is line2!"</span></span><br><span class="line">tags=<span class="string">"testtags"</span></span><br><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -e http://hi.baidu.com/pub/show/createtext \</span><br><span class="line">-o baidu003.html -D bdcookie003.txt -b bdcookie001.txt \</span><br><span class="line">--data-urlencode title=<span class="string">"<span class="variable">$title</span>"</span> \</span><br><span class="line">--data-urlencode tags[]=<span class="variable">$tags</span> \</span><br><span class="line">--data-urlencode content=<span class="string">"<span class="variable">$content</span>"</span> \</span><br><span class="line">--data-urlencode private=0 \</span><br><span class="line">--data-urlencode imgnum=0 \</span><br><span class="line">--data-urlencode bdstoken=<span class="variable">$bdstoken</span> \</span><br><span class="line">--data-urlencode qbid= \</span><br><span class="line">--data-urlencode refer=http://hi.baidu.com/home \</span><br><span class="line">--data-urlencode multimedia[]=:undefined<span class="comment">#undefined#undefined#undefined \</span></span><br><span class="line">--data-urlencode private1=0 \</span><br><span class="line">--data-urlencode qing_request_source= \</span><br><span class="line">http://hi.baidu.com/pub/submit/createtext</span><br><span class="line"><span class="comment">#result</span></span><br><span class="line">result=`cat baidu003.html |awk -F <span class="string">": \""</span> <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"\""</span> <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$result</span> -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Success!"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Fail!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#delete temp files</span></span><br><span class="line">rm -f baidu001.html baidu002.html baidu003.html</span><br><span class="line">rm -f bdcookie001.txt bdcookie002.txt bdcookie003.txt</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
