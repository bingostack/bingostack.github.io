<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>自动化测试实践：自动化测试的思考总结</title>
    <url>/2013/09/auto-testing-summary/</url>
    <content><![CDATA[<p>目前所在的团队一直主要负责部门产品的自动化测试方案。团队在自动化测试方面已经有了几年的探索，但直到最近才真正发挥作用大大提升了产品的测试效率，在这个过程中走了很多的弯路。<br>以下是我这一个阶段以来做自动化测试的思考及总结，有一些大的方向上的讨论，也有一些细节的探讨，希望给大家参考。</p>
<h2 id="关于要不要做"><a href="#关于要不要做" class="headerlink" title="关于要不要做"></a>关于要不要做</h2><p>相信还有很多人对自动化测试有疑问，或者因为种种原因不愿意引入自动化测试。以下总结了一些反对自动化测试的论点：</p>
<ul>
<li>自动化实现较难<br>一般领域内都有可用的自动化测试框架，是这个领域内大家在自动化测试领域探索后的经验总结。在使用正确框架的基础上，自动化测试的实现并不复杂。</li>
<li>自动化成本太高<br>下文中将会详细解释，如果设计合理，并有正确的预期，自动化的收益远大于成本。</li>
<li>项目规模较小，没必要做自动化测试<br>以我们自动化项目的经验，越早做自动化测试，越容易实现，成功率越高。因此可以说成本越低，受益越高。</li>
<li>会限制产品的灵活性<br>需求的频繁变更确实是自动化的灾难。但一般如果需求需要频繁变更，往往预示着其它问题。</li>
</ul>
<a id="more"></a>
<h3 id="手工测试的局限"><a href="#手工测试的局限" class="headerlink" title="手工测试的局限"></a>手工测试的局限</h3><ul>
<li>大量机械、重复性的工作效率较低、测试结果可能不准确<br>总结一个词：boring</li>
<li>很难满足需要模拟大量数据、大量并发量的测试场景<br>比如无法实现系统可靠性测试，如对关键业务进行持续数十天的7*24小时测试</li>
<li>很难适合敏捷开发过程,无法在短时间内完成大量的测试用例的回归<br>对于测试标准严格的大型软件产品，测试用例的数量可能是以“万”为单位的，全部手工回归一遍需要几人月的工作量！</li>
</ul>
<h3 id="自动化测试的引入"><a href="#自动化测试的引入" class="headerlink" title="自动化测试的引入"></a>自动化测试的引入</h3><p>自动化测试就是使用软件来控制测试用例的执行,将实际测试结果与预期结果进行比较,并提供测试预置条件设置、测试逻辑控制以及测试报告生成等重要功能。<br>软件甚至计算机、机器的出现，是为提高人的效率。既然机械、重复性的劳动较多，为何不将这部分工作软件化、自动化？<br>自动化测试可以极大的提升回归测试的工作效率，并简化稳定性测试、兼容性测试等负载类测试的难度,在保障产品质量和持续构建等方面起到举足轻重的作用。</p>
<h3 id="自动化测试的好处"><a href="#自动化测试的好处" class="headerlink" title="自动化测试的好处"></a>自动化测试的好处</h3><p>简单说几点自动化能带来的好处：</p>
<ul>
<li>快速接收；</li>
<li>持续回归；</li>
<li>节约人力成本；</li>
<li>完成人力难以实现的测试，如扩展到性能及稳定性测试。</li>
</ul>
<p>当然有些场景下自动化测试是不适合的。</p>
<h3 id="自动化测试的代价"><a href="#自动化测试的代价" class="headerlink" title="自动化测试的代价"></a>自动化测试的代价</h3><ul>
<li>开发维护成本<br>特别是从零开始的阶段，自动化会有些挑战。其次是提高测试代码的稳定性，需要付出很大经历。</li>
<li>对开发流程的挑战、对开发规范的检验<br>自动化测试非常依赖标准的流程，如果没有较好的开发规范，开发人员随意变更代码、测试用例维护不完善，都会导致自动化的推动困难重重。</li>
</ul>
<h3 id="对自动化测试的正确预期"><a href="#对自动化测试的正确预期" class="headerlink" title="对自动化测试的正确预期"></a>对自动化测试的正确预期</h3><p>很多自动化项目失败的原因是对于自动化没有合理的预期，大多期望太高。</p>
<ul>
<li>自动化测试无法取代手工测试<br>只能取代其中机械重复的部分，“无脑工作量”，越高的智能需要越大的投入。单为测试来说，难以实现且不太值得。</li>
<li>自动化代码需要持续的维护<br>提高自动化的覆盖度、提高稳定性、与需求变更保持同步，所有这些都需要持续投入进行开发维护。</li>
<li>但自动化测试确实会带来很大的好处<br>成功的自动化项目能为项目节省至少50%的人力成本，且可以实现一些手工难以实现的功能。</li>
</ul>
<h2 id="关于如何做"><a href="#关于如何做" class="headerlink" title="关于如何做"></a>关于如何做</h2><p>接下来探讨一下如何做的一些问题。</p>
<h3 id="自动化测试的前提"><a href="#自动化测试的前提" class="headerlink" title="自动化测试的前提"></a>自动化测试的前提</h3><p>一个项目、产品，可不可以、值不值得做自动化测试，主要有一下几个前提需要考虑：</p>
<ul>
<li><p>需求变动不频繁<br>如果需求，特别是测试的接口（如界面、输出的结果展现）变化频繁，自动化代码的维护无法赶上产品迭代的速度，这种情况下不建议引入自动化测试，而应该等产品稳定、需求收敛后再考虑自动化。否则会导致自动化成本过高，而实际未来得及使用就已经失效了。<br>但同时需要注意的是，如果在项目开始后还频繁变更需求，那往往是项目遇到了比较大的问题。此时应该慎重的考虑整个项目，而不只是仅考虑自动化是否该引入了。</p>
</li>
<li><p>项目周期长，并且有迭代<br>项目周期长，才有足够的时间开发自动化测试代码，并确保能真正用上。如果自动化未完成，项目已经结束，那自动化就多余了。<br>而且最好项目有持续迭代。否则如果只需要测试一次或几次，自动化带来的收益太小了。</p>
</li>
<li><p>模拟可以实现并且是有效的<br>自动化的过程就是模拟人使用软件的过程。对于无法用软件模拟的动作（如验证码的测试），是无法自动化的。<br>并且模拟必须是有效有价值的。朋友分享的案例是app测试时的定位问题：app中用到了定位，为了方便测试，编写了修改定位的脚本对app进行测试。但实际测试后发现无法测试全面，很多问题只有在实际场景中才会出现。</p>
</li>
</ul>
<h3 id="从简单做起"><a href="#从简单做起" class="headerlink" title="从简单做起"></a>从简单做起</h3><p>二八定律同样适合于自动化测试：提高自动化覆盖度的过程中你会发现80%的工作量集中在20%的测试用例上。然而这也意味着，我们往往只需要投入20%的工作量，即可实现80%的自动化。<br>因此自动化的过程要从实现的简单到困难，开始阶段往往收益比例是最大的。举例我接手的一个自动化项目，测试输入是5000+网站，其中80%只有打开首页这一个动作，10%还需要一个登陆动作，剩下只有不到10%才涉及发帖子等其它复杂的、个性化操作。如果按照从易到难的顺序实现，很容易就可以自动化80%，甚至90%，剩下的10%仍然采用手工测试都会大大减少人工测试的成本。</p>
<h3 id="按照标准项目来做"><a href="#按照标准项目来做" class="headerlink" title="按照标准项目来做"></a>按照标准项目来做</h3><p>绝大多数自动化项目最终失败的原因是没有把自动化作为一个正式的产品项目来看。<br>自动化测试的项目也是一个标准的软件项目，也应该遵循一些标准的开发流程。如前期也需要确定需求，也需要考虑敏捷、持续迭代，也需要做好自己的测试。<br>实现中容易陷入一些困惑，其实是因为我们忽略了某些流程。典型的如没有做好前期需求收集的识别，完全按使用者说的去做，结果做出来一个并不实用的傻瓜式的自动化方案。再比如没有做好测试，导致测试脚本不稳定。这些都可能导致项目流产。</p>
<h3 id="要不要做成傻瓜式"><a href="#要不要做成傻瓜式" class="headerlink" title="要不要做成傻瓜式"></a>要不要做成傻瓜式</h3><p>自动化的一个比较大的陷阱就是试图做成傻瓜式，特别是没有专业的产品经理为自动化提取需求的情况下。以下是一个典型的傻瓜式自动化测试需求：测试人员只做测试设计，再做一些配置或工具录制，自动化的测试用例就生成了。之后所有的测试工作交由自动化测试完成。<br>事实证明，这种方案的代价远远大于收益，缺点如下：</p>
<ul>
<li>傻瓜化往往需要开发额外的工具<br>越智能的工具，带来越高的开发成本。而且这些工具往往不通用。</li>
<li><p>自动化脚本质量不高，且维护成本太高<br>比如以录制来说，自动生成的脚本往往有各种问题，效率不高，需要手动调整；而且一旦交互或需求变化，可能很多用例都需要重新录制。而且可能会生成一些复杂难以被人理解的代码，遇见问题时调试困难。</p>
</li>
<li><p>所需的培训成本并不低<br>这些工具往往需要使用特定的规则。比如之前看到一个自动化方案，通过一些规定的词汇指定各步骤，然后解析自动生成测试脚本。任何一个词汇不满足要求就生成失败，还要智能的去解析变量，几乎就是重造了一个编译器。<br>但其实回头想一下有没有必要创建一套特定的不通用的规则、重造一门语言？为什么不简单的去要求使用人员去学习一套通用的规则、学习一门语言，如python、tcl？只需要最简单的入门即可。</p>
</li>
</ul>
<h3 id="关于UI测试"><a href="#关于UI测试" class="headerlink" title="关于UI测试"></a>关于UI测试</h3><p>如前所讲，自动化要从易到难，UI测试相比其它自动化测试（典型的如CLI测试），就属于比较难的阶段。<br>但若使用类似于selenium的UI自动化框架，实现并不是很复杂。但UI测试的表现不太稳定，需要付出很多的努力使得用例稳定。典型的如打开网页点击按钮这个简单的动作，实际测试发现总会有一定概率下，这个按钮不出现，而且重现调查也很难找到原因。<br>在这种情况下，建议先demo实验下，可行后从易到难实现。</p>
<h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><p>哪些测试阶段应该自动化测试？严格说起来，只分为三个阶段：</p>
<ul>
<li>单元测试应该做，但更多应该开发人员，或者更详细一些，代码的编写者维护单元测试用例。</li>
<li>集成测试和系统测试等开发迭代过程中的测试，应该自动化，并且是自动化的主要使用场景。</li>
<li>发散测试/探索性测试，不应该自动化，因为要发挥人的灵活性，弥补自动化测试的不足。</li>
</ul>
<h2 id="关于实现细节"><a href="#关于实现细节" class="headerlink" title="关于实现细节"></a>关于实现细节</h2><p>让我们深入细节，探讨一些深入的点。</p>
<h3 id="工具或框架的选择"><a href="#工具或框架的选择" class="headerlink" title="工具或框架的选择"></a>工具或框架的选择</h3><p>尽量选择开源的工具或框架：</p>
<ul>
<li>方便定制化开发</li>
<li>非开源软件很多内部逻辑不透明，可能难以大规模扩展</li>
<li>技术积累、沉淀，使用开源软件能使团队得到更多的技术积累</li>
<li>节省费用，很多收费的自动化测试工具很贵，使用开源软件可积累一大笔费用</li>
</ul>
<p>UI的自动化测试，推荐使用开源的selenium。在我们的项目中，使用selenium实现了绝大多数UI测试需要的功能，而且很容易扩展。<br>CLI的自动化测试选择要多一些，可以简单的使用shell脚本，或python、tcl等更加高级、功能更强大的语言。<br>针对某些特定框架、语言，如js，框架本身可能提供了一些自动化测试框架，因为它可能会用到语言或框架的一些特性，推荐优先使用。</p>
<h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>测试环境的自动部署也是很重要的。虽然不是必须，比如可以在手工搭建好的环境上进行测试。但是对于复杂的环境，或者测试的扩展是很重要的。<br>基础设施部分建议使用虚拟机+pxe实现，软件建议使用配置管理工具实现。</p>
<h3 id="函数库封装"><a href="#函数库封装" class="headerlink" title="函数库封装"></a>函数库封装</h3><p>如前文所说，我们应该将自动化测试作为一个标准项目来开发。因此也应该进行分层设计，核心的库与具体业务解耦。</p>
<ul>
<li>核心库封装各基础功能，建议由自动化团队负责维护；</li>
<li>具体用例通过调用核心库实现，由测试人员维护。</li>
</ul>
<p>这样如果产品接口发生的变更（如登录发生了变化），只需要简单的更新核心库及部分用例即可。如果每个脚本单独实现，此时就需要更新所有依赖此接口的用例。<br>不要单独编写每个测试用例，简单到容易的过程中容易犯这个错误。<br>并且用例之间尽量保持独立，否则不容易扩展，逻辑太复杂。如果一个用例的过程被多次使用，那说明应该封装了。</p>
<h3 id="sleep的使用"><a href="#sleep的使用" class="headerlink" title="sleep的使用"></a>sleep的使用</h3><p>等待某些条件达成时，最简单的方式就是使用sleep。<br>但sleep的时间设置多少？如果过少，可能条件还未达成；如果过多，会导致执行变慢。而且不同的环境，需要的等待时间不同。<br>所有这些会导致测试的不稳定。因此因减少sleep的使用，而应该实时的去检测条件。这样会增加代码量，但会减少不稳定导致的错误。</p>
<h2 id="关于弥补不足"><a href="#关于弥补不足" class="headerlink" title="关于弥补不足"></a>关于弥补不足</h2><p>自动化是通过代码模拟人的动作，存在天然的不足。如果能做到足够的精确和高效，那它所具有的人工智能的价值已经超越被测试软件的价值了。<br>幸运的是，我们可以通过一些不太高成本的方式弥补其不足。</p>
<h3 id="不稳定如何解决"><a href="#不稳定如何解决" class="headerlink" title="不稳定如何解决"></a>不稳定如何解决</h3><p>因为代码的实现及环境因素等，自动化代码难免会出现不稳定的情况，可采取如下方式：</p>
<ul>
<li>多次测试，多次测试一排除偶然性的影响，但也不能忽略偶然性bug出现的可能</li>
<li>专人排查，对所有出错的用例进行排查，定位是产品问题、测试代码问题，还是环境问题。这就要求自动化测试过程中记录足够的日志信息</li>
<li>持续维护，持续维护代码，保持与主干项目同步，并增强稳定性</li>
<li>代码自测，做好测试代码的自测，提高测试代码的质量</li>
</ul>
<h3 id="加强探测性测试"><a href="#加强探测性测试" class="headerlink" title="加强探测性测试"></a>加强探测性测试</h3><p>自动化尽可能的模仿人，但相似度越高，代价越大；<br>探测性测试可以用较小的成本获得大的受益，同时可检测自动化测试是否有效。</p>
<h3 id="如何跟踪软件迭代的进度"><a href="#如何跟踪软件迭代的进度" class="headerlink" title="如何跟踪软件迭代的进度"></a>如何跟踪软件迭代的进度</h3><p>自动化的价值就是能及时的对产品进行测试，因此对开发进度有比较高的要求，特别是在项目持续迭代时：</p>
<ul>
<li>尽早介入，最好能在详细设计阶段开始自动化开发，但这需要与产品开发人员约定好接口</li>
<li>模块化的封装，封装后可减少修改</li>
<li>变更太快的项目，会导致自动化测试无法维护，只能等版本稳定</li>
</ul>
<h2 id="团队实际经验"><a href="#团队实际经验" class="headerlink" title="团队实际经验"></a>团队实际经验</h2><p>最后说下团队实际的经验，大体分为3个阶段：</p>
<ol>
<li>录制阶段<br>此阶段团队的大部分精力用来开发一个录制的工具：开启录制后，只需要测试人员执行一遍测试，工具即可记录并自动生成自动化代码。同上所述，这个工具的开发本身是不太容易的，而且实际也很难用于别的项目，录制出的脚本也需要再去修改。遇到需求变更，一般都需要重新录制。<br>开始的两年团队一直在重复这个困局：项目开始，团队开始开发维护录制工具；项目集成测试，团队开始录制维护脚本；项目接近释放，录制勉强完成，用来做一次验收测试；开始下一轮循环。<br>此阶段自动化几乎无法实际使用。此阶段的成果在于通过虚拟机+PXE的方式，产品的自动部署流程基本打通。</li>
<li>脚本阶段<br>经过2年的开发，团队发现录制工具并不实用，而且开发维护的成本较大，自动化进度很慢。因此决定同时采用录制、脚本编写两种方式，开始从易到难的自动化测试用例，并编写模板培训测试人员使用。<br>因为很多用例步骤都是重复的，通过复制粘贴的形式，自动化了很多测试用例，自动化进度大大加快。<br>这个阶段自动化覆盖度大大提高，但是代码质量不高，维护成本很高。</li>
<li>封装自动化库阶段<br>最终终于将自动化作为一个标准的项目进行开发：产品经理协助提取分析需求；代码解耦，封装核心库，并持续维护提高稳定性，逐渐扩展到UI测试；持续培训测试人员实现自动化，并review其代码。<br>到这个阶段，前期花费巨大精力的录制工具几乎已经被抛弃。<br>经过这个阶段，自动化覆盖度达到90%，因不稳定原因导致的用例失败率降低到10%。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，自动化测试绝大多数情况下是很有价值的。<br>但是需要遵循一些规则，建议将自动化测试项目规范的作为一个产品去开发，并尽可能将敏捷的思想应用其中。</p>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之十三：curl vs wget</title>
    <url>/2012/09/curl-vs-wget/</url>
    <content><![CDATA[<p>curl和wget有很多地方是相同的，很多场景下二者都可以使用。那面对一个复杂问题的时候，我们怎么决定使用哪个工具呢？本篇通过对二者进行比较，从而对此提供思路。<br>本篇主要参考<a href="http://daniel.haxx.se/docs/curl-vs-wget.html" target="_blank" rel="noopener">curl官方的文档</a>，翻译加整理。</p>
<h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ul>
<li>都是可通过FTP/HTTP/HTTPS协议下载文件的命令行工具；</li>
<li>都可以发送HTTP POST请求；</li>
<li>都支持cookie的使用；</li>
<li>都被设计为无界面（UI），可在如脚本中使用；</li>
<li>都是开源且免费的软件。</li>
</ul>
<a id="more"></a>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><ul>
<li>curl是基于libcurl库实现，因此特性来源于libcurl库。libcurl库跨平台、开源且免费，因此curl不只是一个命令行工具</li>
<li>管道。curl在传统的UNIX风格的基础上加以扩展，对输入输出做出更多的处理，从而贯彻了”everything is a pipe” 的设计思想。</li>
<li>单点传送（Single shot）。curl被设计为用于数据的单点传送。它只会传送用户指定的URLS，并不包含任何递归下载的逻辑，也不对html进行任何解析。</li>
<li>更多协议支持。目前curl 支持的协议有： FTP, FTPS, HTTP, HTTPS, SCP, SFTP, TFTP, TELNET, DICT, LDAP, LDAPS, FILE, POP3, IMAP, SMTP 和 RTSP 。Wget仅仅支持 HTTP, HTTPS 和 FTP。（协议的支持情况可能会随着时间发展而变化。）</li>
<li>更多平台支持，便于移植。与wget相比，curl可在更多平台上编译和运行。比如OS/400, TPF 和其他很多非UNIX的平台。</li>
<li>更强大的SSL库和SSL支持。curl能应用于多个不同的 SSL/TLS 库, 并提供了更多的可控性和对协议细节更广泛的支持。</li>
<li>curl支持更多的HTTP认证方式。尤其是当你使用HTTP代理的时候，curl支持Basic, Digest, NTLM and Negotiate认证方式（参见<a href="https://adeployblog.appspot.com/2012/08/17/http-auth-schemes.html" target="_blank" rel="noopener">HTTP认证模式</a>）。</li>
<li>libcurl库支持多种不同的SOCKS代理，基于libcurl实现的curl工具也支持。而wget不支持。</li>
<li>双向通信。 curl 提供了上传能力，Wget仅仅支持HTTP POST方式。</li>
<li>HTTP multipart/form-data 的发送能力。 这使得用户可以进行HTTP上传，更好的模拟浏览器的行为从而更大程度的实现HTTP操作的自动化，提供了更多操作的可能。</li>
<li>压缩。 curl 支持GZIP和 inflate Content-Encoding 并且自动进行解压缩操作。</li>
<li>curl提供并执行Transfer-Encoded HTTP的解压缩，而wget不会</li>
<li>curl在7.27.0之后，提供对<a href="http://en.wikipedia.org/wiki/Metalink" target="_blank" rel="noopener">metalink</a>的支持（好吧，百度百科对metalink的解释是不对的， 百度百科说的是oracle公司的一个服务）。而wget需要依靠一个Google Summer开源项目才能支持metalink。</li>
</ul>
<h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><ul>
<li>wget仅仅是一个命令行工具。没有库提供使用。</li>
<li>递归下载支持。wget相比curl最大的优点在于对递归下载的支持，甚至下载一个资源如网页或FTP目录指向的所有资源。</li>
<li>wget下载时无需指定保存文件名。而curl需要使用-o或-O指定。</li>
<li>wget仅支持GnuTLS 和 OpenSSL两种SSL库。</li>
<li>wget仅支持HTTP代理的基本认证（Basic auth）。</li>
<li>wget不支持SOCKS代理。</li>
<li>wget项目更老，基于GPL开源协议，隶属GNU项目。curl基于MIT开源协议，不隶属于任何组织，版权由作者一人所有。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>wput仅是一个单独的工具，不进行讨论。<br>参考：<a href="http://daniel.haxx.se/docs/curl-vs-wget.html" target="_blank" rel="noopener">curl vs Wget</a></p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
        <tag>wget</tag>
      </tags>
  </entry>
  <entry>
    <title>网关类产品的性能测试之一：简介及性能指标介绍</title>
    <url>/2013/03/gateway-performance-test-desc/</url>
    <content><![CDATA[<p>本文所指的网关类产品，是指实际拓扑中会被部署作为网关的产品，典型的如路由器/交换机、防火墙、IDS/IPS、UTM、NGFW等。<br>但是性能测试中很多种类，对于大多数产品其实是相通的，因此对其它产品的性能测试也有参考价值。<br>文章主要面向的对象为性能测试及性能调优人员，同时对选购产品的潜在客户有指导意义。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于网关类产品性能和稳定性是前提。如今各种NGFW、应用防火墙等概念不断涌现，各大厂商反复在功能的丰富性上做文章，但所有这些只能算作锦上添花，只有产品的性能与稳定性才是真正的根基。对于任何网络环境，如果网关的吞吐小于实际需要的带宽值，必将是一场灾难。而更多的功能导致数据包经过的路径更长，对性能带来了更严峻的挑战。同时，稳定性和性能往往是相关的，且性能测试更标准。<br>因此客户评价网关产品的优劣，除了产品所支持功能以外，更关注的指标就是性能。另外，现在市场上大部分的网络安全类产品或者网关类产品在功能和协议的支持上，同质化较为严重，客户在选取时，性能指标就成为衡量的一个很重的指标项。<br>产品的性能指标不仅客户非常关注，设备厂商在向市场发布产品时，性能指标也会做为重点进行宣传，正面PK。由此可见性能指标对于网关类产品的重要性。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>此系列文章将介绍业界较为常用的性能指标及测试方法。因篇幅较长，为竭尽所能说的更清楚明白，将本系列分为以下四部分：</p>
<ol>
<li>简介及性能指标介绍 - 本篇</li>
<li><a href="http://stackeye.com/2013/03/gateway-performance-test-rfc2544/" target="_blank" rel="noopener">RFC2544四项指标测试方法</a></li>
<li><a href="http://stackeye.com/2013/03/gateway-performance-test-others/" target="_blank" rel="noopener">其它指标测试方法</a></li>
<li><a href="http://stackeye.com/2013/04/gateway-performance-test-tools/" target="_blank" rel="noopener">测试工具、注意事项及经验总结</a></li>
</ol>
<a id="more"></a>
<h2 id="性能测试简介"><a href="#性能测试简介" class="headerlink" title="性能测试简介"></a>性能测试简介</h2><p>以下解释来自百度百科：</p>
<blockquote>
<p>性能测试是通过自动化的测试<strong>工具</strong>模拟多种正常、峰值以及异常<strong>负载</strong>条件来对系统的各项性能指标进行测试。负载测试和压力测试都属于性能测试，两者可以结合进行。通过负载测试，确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。压力测试是通过确定一个系统的<strong>瓶颈</strong>或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。</p>
</blockquote>
<p>其中有三个关键词需要关注：</p>
<ul>
<li>工具：性能测试一般需要的压力较大较复杂，单纯依靠手工很难做到，因此一般需要专业化的设备、工具，或编写自动化测试脚本完成。网关类产品一般要求的负载较高，在千兆、万兆设置更高级别，一般需要专业配置千兆万兆网卡的硬件设备，如IAXA等，价格较昂贵。而其它产品一般也需要如Loadruner、Jmeter等专业化的性能测试软件并根据场景编写脚本完成。</li>
<li>负载：性能测试有别于功能测试的点就在于使用的负载较高。而且负载的构造需要根据实际的场景才有价值，并需要使用特定的工具或自行研发软件实现。</li>
<li>瓶颈：逐渐加大负载到达瓶颈。测试中比较重要的就是各个性能拐点，因为各个拐点往往都有重要的意义。如保持最优响应的拐点、延迟急剧增加的拐点、系统彻底瘫痪的拐点。持续测试找到各个拐点，对于产品的调优、部署及运维都有很大的价值。<br><img src="/img/jmeter-result.png" alt="性能测试结果"></li>
</ul>
<h2 id="术语介绍"><a href="#术语介绍" class="headerlink" title="术语介绍"></a>术语介绍</h2><p>文章中会涉及到一些术语，现总结如下，供参考。</p>
<ul>
<li>性能测试，对产品负载压力承受能力的测试。</li>
<li>RFC，互联网及软件等的一些标准，基本的互联网通信协议都有在RFC文件内详细说明。</li>
<li>网关类产品，部署作为网关的设备及软件。</li>
<li>IDS，入侵检测系统</li>
<li>IPS，入侵防御系统</li>
<li>UTM，对防火墙、IDS\、IPS三个的综合，可以比较全面的进行管理。但是UTM通过一台物理设备集成大量功能，导致了应对大量数据的时候效率会下降，同时存在设备损坏导致全面崩溃的可能。</li>
<li>NGFW，下一代防火墙，安全设备类产品未来的发展方向。</li>
<li>DUT，devices under test，测试设备。</li>
</ul>
<h2 id="性能指标名词解释"><a href="#性能指标名词解释" class="headerlink" title="性能指标名词解释"></a>性能指标名词解释</h2><p>网络安全类产品或网关类产品常见的性能指标有：</p>
<ul>
<li>RFC2544 四项值（吞吐量、延迟、丢包率、背靠背）</li>
<li>TCP 的每秒新建连接数（CPS）</li>
<li>HTTP 的每秒处理事务数（TPS）、HTTP 有效吞吐量（HTTP Throughput）</li>
<li>最大并发连接数等</li>
</ul>
<p>除此之外，部分评测机构或客户也会根据自己的实际情况增加性能指标，如：IPS/UTM下的HTTP有效吞吐量和每秒新建，Mail协议（SMTP/POP3/IMAP）的有效吞吐量和新建，特殊场景的混合流量（如加入恶意流量）的吞吐量等。<br>可参考业界标杆Fortinet的<a href="https://www.fortinet.com/content/dam/fortinet/assets/data-sheets/Fortinet_Product_Matrix.pdf" target="_blank" rel="noopener">性能测试报告</a>。<br><img src="/img/fortinet-product-matrix-sample.png" alt="Fortinet product matrix"></p>
<p>下面我们先认识一下各性能指标名词的含义。本篇只介绍各名词的含义，测试方法后续章节中说明。</p>
<h3 id="RFC2544-四项值"><a href="#RFC2544-四项值" class="headerlink" title="RFC2544 四项值"></a>RFC2544 四项值</h3><p><a href="https://tools.ietf.org/html/rfc1242" target="_blank" rel="noopener">RFC1242</a>文档中定义了吞吐量（Throughput）、延迟（Latency）、丢包率（Frame Loss）、背靠背（Back-to-Back）四个标准术语。<br><a href="https://www.ietf.org/rfc/rfc2544.txt" target="_blank" rel="noopener">RFC2544</a>是RFC组织提出的用于评测网络互联设备（防火墙、IDS、交换机路由器等）的国际标准，其中主要对RFC1242 中定义的性能评测参数的具体测试方法、结果的提交形式作了较详细的规定。</p>
<p>下面将对这四项值是做为重点进行介绍。</p>
<h4 id="吞吐量（Throughput）"><a href="#吞吐量（Throughput）" class="headerlink" title="吞吐量（Throughput）"></a>吞吐量（Throughput）</h4><p>吞吐量是指被测设备在不丢包的情况下，所能转发的最大速率或最大流量。通常测试结果以每秒通过的最大数据包数（PPS）或比特数（Mb/s）。<br>用于反映被测设备所能够处理的最大的数据流量，重在测试被测设备的转发能力。<br>结果值越大越好。<br>吞吐量比较通用，适用于绝大多数软件系统的性能测试。</p>
<h4 id="延迟（Latency）"><a href="#延迟（Latency）" class="headerlink" title="延迟（Latency）"></a>延迟（Latency）</h4><p>发送一定数量的数据包，记录中间数据包发出的时间T1，以及经由被测设备转发后到达接收端口的时间T2：Latency＝T2－T1。延迟的测试结果以毫秒（ms）或微秒（μs）表示。<br>测试延迟是在测试过程中不存在丢包的条件下进行的，也就是说在测试延迟时，先要知道被测设备的吞吐量，从而定义发包的速率。<br>延迟用于反映被测设备处理数据包的速度。<br>延迟越小，表明设备处理速度越快。<br>延迟比较通用，是大多数软件系统性能测试的重要指标。</p>
<h4 id="丢包率（Frame-Loss）"><a href="#丢包率（Frame-Loss）" class="headerlink" title="丢包率（Frame Loss）"></a>丢包率（Frame Loss）</h4><p>丢包率是指在一定的负载下，由于缺乏资源而未能被转发的包占应该转发的包数的百分比。<br>用于反映被测设备承受特定负载能力。<br>结果值越小越好。</p>
<h4 id="背靠背（Back-to-Back）"><a href="#背靠背（Back-to-Back）" class="headerlink" title="背靠背（Back-to-Back）"></a>背靠背（Back-to-Back）</h4><p>以能够产生的最大的速率，发送一定长度的数据包，并不断改变单次发送的数据包数目，直到被测设备能够完全转发所有发送的数据包而不丢包，这个包数就是该设备的背对背值。<br>用于反映被测设备处理突发数据的缓存能力。背对背的值越大，路由器的缓存能力就越强，处理突发数据包的能力越强。</p>
<h3 id="TCP每秒新建连接数（CPS）"><a href="#TCP每秒新建连接数（CPS）" class="headerlink" title="TCP每秒新建连接数（CPS）"></a>TCP每秒新建连接数（CPS）</h3><p>TCP每秒新建是在业界提到最多的一个。这个性能指标出自<a href="https://www.ietf.org/rfc/rfc3511.txt" target="_blank" rel="noopener">RFC3511</a>文档。全称是 Maximum TCP Connection Establishment Rate（最大TCP 建立速率），大家习惯将这个指标称为CPS（TCPConnection Per Second）。<br>TCP每秒新建速率是指在被测设备能够成功建立所有请求连接的条件下，所能承受的最大TCP 连接建立速度。其测试采用迭代搜索算法，每次迭代过程中，以低于被测设备所能承受的最大并发连接数发起速率不同的TCP 连接请求，直到得到所有连接成功建立的最大速率。<br>TCP每秒新建速率以连接数/秒表示结果，其值越大越好。<br>注：TCP Connection Establishment已在<a href="https://tools.ietf.org/html/rfc2647" target="_blank" rel="noopener">RFC2647</a>文档中进行定义。</p>
<h3 id="HTTP的每秒处理事务数（TPS）"><a href="#HTTP的每秒处理事务数（TPS）" class="headerlink" title="HTTP的每秒处理事务数（TPS）"></a>HTTP的每秒处理事务数（TPS）</h3><p>TPS性能指标是反映被测设备应用层的新建速率，这个性能指标也出自RFC3511文档。全称是Maximum HTTP Transaction Rate（最大HTTP传输事务速率），大家习惯将这个指标称为TPS（HTTPTransaction Per Second）。<br>HTTP的每秒事务数是指在被测设备能够成功建立连接的条件下，所能承受的最大的HTTP 协议的请求/回应操作的速度。其测试采用反复搜索过程，每次反复过程中，以低于被测设备所能承受的最大处理速率，直到所有连接被成功建立并且有对相应的请求。<br>结果以连接数/秒表示结果。其值越大越好。</p>
<h3 id="HTTP有效吞吐量（HTTP-Good-Throughput）"><a href="#HTTP有效吞吐量（HTTP-Good-Throughput）" class="headerlink" title="HTTP有效吞吐量（HTTP Good Throughput）"></a>HTTP有效吞吐量（HTTP Good Throughput）</h3><p>HTTP有效吞吐量是反映被测设备在应用层的最大传输速率，这个性能指标在RFC3511文档中没有明确描述，但可以通过将HTTP Transaction Rate调整转化为HTTP有效吞吐量的测试方法。HTTP有效吞吐量是指在被测设备能够成功建立连接的条件下，在同一时间内所能承受的最大的有效数据量。<br>测试结果值越大越好。</p>
<h3 id="最大并发连接数"><a href="#最大并发连接数" class="headerlink" title="最大并发连接数"></a>最大并发连接数</h3><p>最大并发连接数性能指标是反映被测设备最大的会话条目数，这个性能指标也出自RFC3511文档。全称是 Concurrent TCP Connection Capacity。最大并发连接数是指在被测设备能够成功建立连接的条件下，所能同时承受的最大的链接条目数，也反映了被测设备维持多个会话的能力。<br>测试结果值越大越好。</p>
<h3 id="其它性能指标项"><a href="#其它性能指标项" class="headerlink" title="其它性能指标项"></a>其它性能指标项</h3><p>在<a href="https://www.ietf.org/rfc/rfc3511.txt" target="_blank" rel="noopener">RFC3511</a>文档中主要描述了HTTP协议的性能测试，但随着产品及技术的大幅度更新，这往往已经不能满足客户或厂商的需求。我们还需要测试其它协议的性能，通常以应用层为主：包括FTP协议、Mail协议等。但测试的内容基本都是一样的，以每秒新建（每秒会话）和吞吐量为主。只需将HTTP协议变为其它应用层协议即可。</p>
<p>随着网关产品尤其是网络安全类产品的发展，性能测试的范围不再局限于防火墙功能上的性能测试，还新增加了对其它功能如IPS、AV（防病毒）和UTM（集成安全网关）等的性能测试。但可以看到，这些功能的增加对于测试过程或者测试方法而言其实没有直接的影响，仍然要使用原来的测试过程或测试方法。下篇我们将介绍具体的测试方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要是简介及测试方法的概念介绍。所有的性能指标中，RFC2544的四项指标是其中比较重要的部分且目前基本以形成标准，下篇文章将对其进行介绍。</p>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>ips</tag>
        <tag>NGFW</tag>
        <tag>防火墙</tag>
        <tag>spi firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之十二：ftp及其他协议</title>
    <url>/2012/08/curl-ftp-usage/</url>
    <content><![CDATA[<p>在<a href="http://stackeye.com/2012/07/linux-curl-description/" target="_blank" rel="noopener">Linux下cURL使用教程之一：cURL简介</a>里，提到curl支持多种协议。本篇就以ftp协议为主，对curl对其他协议的操作进行简介。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>基本使用方法同HTTP没有区别：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl ftp://ftp.cisco.com/pub/mibs/</span><br></pre></td></tr></table></figure></p>
<p>只不过ftp一般会有用户名密码，所有在命令中要加上用户名密码：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u ftpuser:ftppass -O ftp://ftp_server/index.php</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl ftp:// ftpuser:ftppass ftp://ftp_server/index.php</span><br></pre></td></tr></table></figure></p>
<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>使用-T选项。具体请参考<a href="https://adeployblog.appspot.com/2012/08/11/linux-curl-basic-usage-upload-file.html" target="_blank" rel="noopener">Linux下cURL使用教程之六：curl基本使用之HTTP文件上传</a>。<a id="more"></a><br>上传一个文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u ftpuser:ftppass -T myfile.txt ftp://ftp.testserver.com</span><br></pre></td></tr></table></figure></p>
<p>上传多个文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u ftpuser:ftppass -T <span class="string">"&#123;file1,file2&#125;"</span> ftp://ftp.testserver.com</span><br></pre></td></tr></table></figure></p>
<p>从标准输入获得文件内容：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u ftpuser:ftppass -T - ftp://ftp.testserver.com/myfile_1.txt</span><br></pre></td></tr></table></figure></p>
<p>这个命令会将标准输入的内容保存在<a href="ftp://ftp.testserver.com/myfile_1.txt中。" target="_blank" rel="noopener">ftp://ftp.testserver.com/myfile_1.txt中。</a></p>
<h2 id="FTP四种模式"><a href="#FTP四种模式" class="headerlink" title="FTP四种模式"></a>FTP四种模式</h2><p>FTP有两种基本模式：PASV和PORT，也即主动模式和被动模式。在二者基础上分别有两种扩展：ERSV和EPRT。具体请参考相关RFC文档。<br>curl默认使用EPSV模式：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --verbose ftp://ftp_server/ --user user</span><br></pre></td></tr></table></figure></p>
<p>会看到curl执行了EPSV命令。–eprt参数显式指定使用EPRT模式。<br>使用<code>--disable-epsv</code>选项禁用EPSV而使用PASV：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --verbose --<span class="built_in">disable</span>-epsv ftp://ftp_server/ --user user</span><br></pre></td></tr></table></figure></p>
<p>使用<code>-P/--ftp-port &lt;address&gt;</code>选项指定使用EPRT，其中address参数可以指定为“-”，指定使用FTP控制连接相同的地址：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --verbose --ftp-port - ftp://ftp_server/ --user user</span><br></pre></td></tr></table></figure></p>
<p>会看到使用了EPRT命令。<br>而使用<code>--disable-epsv</code>选项，如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --verbose --ftp-port - --<span class="built_in">disable</span>-epsv ftp://ftp_server/ --user user</span><br></pre></td></tr></table></figure></p>
<p>及指定了使用PORT模式。</p>
<h2 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h2><p>以SMTP协议发邮件为例，执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --verbose --ssl --mail-rcpt <span class="built_in">test</span>@163.com --mail-from <span class="built_in">test</span>@163.com smtp://smtp.163.com -u <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<p>–ssl指定使用SSL， smtp://一定要加在url上，否则curl会使用默认的HTTP协议。</p>
<p>之后，按提示输入如下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Subject: Testing</span><br><span class="line">This is a test mail</span><br><span class="line">.</span><br></pre></td></tr></table></figure></p>
<p>即可发送邮件。<br>但是估计是有防作弊机制，测试发现163、GMAIL的SMTP发信都失败，提示“curl: (67) Access denied: 500”，追踪详细过程，发现是“MAIL FROM: <a href="mailto:test@163.com" target="_blank" rel="noopener">test@163.com</a>”这句提示语法错误。不知道是什么原因。<br>但是使用自己搭建的邮件服务器测试成功。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>buildbot实战</title>
    <url>/2014/11/buildbot-in-action/</url>
    <content><![CDATA[<p><a href="http://buildbot.net/" target="_blank" rel="noopener">Buildbot</a>是一套基于python的的持续集成系统，可方便的进行自动化构建、部署、测试和发布。类似于Jenkins，但更轻量化且易于直接使用python进行扩展。Chrome社区就使用的buildbot作为其CI系统。<br>类似于Jenkins，buildbot在一个CI系统中扮演的更多是一个任务执行者的角色，其工作流程如下：</p>
<ul>
<li>监控代码仓库</li>
<li>代码仓库有变化后，立即拉取代码</li>
<li>执行build、部署、测试及发布工作</li>
<li>反馈结果</li>
</ul>
<p>我们对这样一个工具的一般要求为：</p>
<ul>
<li>轻量级，安装、配置简单，本身耗费资源较少</li>
<li>高效率，较快的完成自动化任务</li>
<li>通用性强，在不同的操作系统，甚至与不同的代码系统兼容</li>
<li>易扩展、配置及管理，能较简单的配置自动化任务</li>
</ul>
<p>Buildbot和Jenkins都能很好的满足我们这些要求。但相比Jenkins，buildbot更轻量级，部署配置更为简单。<br>Web界面也更简单美观一些。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>buildbot架构比较简单，主要分为三部分：</p>
<ul>
<li>版本控制层<br>外部版本控制，通过插件或主动触发的方式触发buildbot执行任务。</li>
<li>任务执行层<br>master接收任务后，调度其slave执行任务，并获取到返回的结果</li>
<li>通知层<br>master获取结果后，可通过邮件、IRC等方式进行通知。</li>
</ul>
<p>其中重要的主体是master和slave，其主要采用星形拓扑结构，一个集群中可以多个master、多个slave。master主要负责任务接收、调度并通知任务，slave负责具体的任务执行。各节点本身无状态，横向扩展性很好。<br><a id="more"></a><br><img src="/img/buildbot-overview.png" alt="buildbot架构"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>建议使用pip安装，避免麻烦的依赖问题。<br>同时当前对python3版本支持不太好，建议使用python2.7版本：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install gcc python-devel </span><br><span class="line">yum install python-dateutil15 git expect</span><br><span class="line"><span class="comment"># master安装</span></span><br><span class="line">pip install buildbot</span><br><span class="line"><span class="comment"># salve安装</span></span><br><span class="line">pip install buildbot-slave</span><br></pre></td></tr></table></figure></p>
<p>如果是python2.6的话，因为最新版本的Twisted需要python2.7，所以需要提前指定版本安装：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install Twisted==15.1.0</span><br></pre></td></tr></table></figure></p>
<p>为充分利用资源，同一台机器可配置为多个master、slave：可使用不同用户或virtualenv，每个用户或virtualenv环境部署为一个节点。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure></p>
<h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><p>最近看到<a href="http://docs.buildbot.net/current/tutorial/docker.html" target="_blank" rel="noopener">buildbot官方</a>给出了Dockerfile(但Dockerfile地址是错的，可以自行在github代码中查找)，可下载后自行构建镜像使用，运行后即可使用：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Download Buildbot Dockerfile.</span></span><br><span class="line">wget https://raw.githubusercontent.com/buildbot/buildbot/master/master/Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build the Buildbot container (it will take a few minutes to download packages)</span></span><br><span class="line">docker build -t buildbot - &lt; Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run buildbot</span></span><br><span class="line">CONTAINER_ID=$(docker run -d -p 8010:8010 -p 22 buildbot)</span><br></pre></td></tr></table></figure></p>
<p>然后打开<a href="http://localhost:8010" target="_blank" rel="noopener">http://localhost:8010</a>即可。</p>
<h2 id="创建及运行"><a href="#创建及运行" class="headerlink" title="创建及运行"></a>创建及运行</h2><h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">buildbot create-master master</span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">mv master/master.cfg.sample master/master.cfg</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">buildbot start master</span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">tail -f master/twistd.log</span><br></pre></td></tr></table></figure>
<p>buildbot会在当前目录下创建master名称的目录，以上为<code>master</code>。<br>看到最后显示<code>BuildMaster is running</code>即为启动成功，此时可通过<a href="http://localhost:8010" target="_blank" rel="noopener">http://localhost:8010</a>访问，默认用户名密码都是<code>pyflakes</code>。</p>
<h3 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h3><p>创建slave时需要指定mater的地址，或者修改配置文件指定。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">buildslave create-slave slave1 localhost:9989 slave1 pass</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">buildslave start slave</span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">tail -f slave/twistd.log</span><br></pre></td></tr></table></figure></p>
<p>create-slave的参数分布是：slave目录、master、名字、密码。其中master默认都采用9989与slave通信。名字、密码必须与master的master.cfg中配置的一致：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c[<span class="string">'slaves'</span>] = [buildslave.BuildSlave(<span class="string">"example-slave"</span>, <span class="string">"pass"</span>)]</span><br></pre></td></tr></table></figure></p>
<h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p>此时打开<a href="http://localhost:8010" target="_blank" rel="noopener">http://localhost:8010</a>即可看到如下页面：<br><img src="/img/buildbot-index.png" alt="buildbot预览"><br>其中Buildslaves页面可查看到我们新添加的example-slave，且状态为<code>Idle</code>。<br>而Waterfall页面可查看到当前的builder，目前只有runtest，点进去点击forcebuild即可进行测试build。成功后记录显示为绿色。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Buildbot的配置文件为<code>.cfg</code>后缀的python脚本，使用python语法。如上文slave的定义就是一个python list的定义。</p>
<h3 id="master配置"><a href="#master配置" class="headerlink" title="master配置"></a>master配置</h3><p>主要配置如下。</p>
<ul>
<li>BUILDSLAVES<br>slave的定义，以list的形式呈现。需要主要名字和密码与slave一致。<br>其中protocols可定义与slave的通信方式，包括端口等。</li>
<li><p>CHANGESOURCES<br>指定需要监控的源代码地址。格式如下，其中可指定git地址、工作目录、分支、监控周期等。可定义多个，每个append进list即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c[&apos;change_source&apos;] = []</span><br><span class="line">c[&apos;change_source&apos;].append(changes.GitPoller(</span><br><span class="line">        &apos;git://github.com/buildbot/pyflakes.git&apos;,</span><br><span class="line">        workdir=&apos;gitpoller-workdir&apos;, branch=&apos;master&apos;,</span><br><span class="line">        pollinterval=300))</span><br></pre></td></tr></table></figure>
</li>
<li><p>SCHEDULERS<br>scheduler指定何时、如何触发执行builder，其中builder在BUILDERS中定义。下文定义了两个scheduler：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c[<span class="string">'schedulers'</span>] = []</span><br><span class="line"><span class="comment"># 定义每小时运行的scheduler</span></span><br><span class="line">hourlyscheduler = Periodic(name = <span class="string">"hourly"</span>,</span><br><span class="line">                           builderNames = [<span class="string">"simplebuild"</span>],</span><br><span class="line">                           periodicBuildTimer = <span class="number">3600</span>)</span><br><span class="line"><span class="comment"># 定义手动触发的scheduler</span></span><br><span class="line">c[<span class="string">'schedulers'</span>].append(schedulers.ForceScheduler(</span><br><span class="line">                            name=<span class="string">"force"</span>,</span><br><span class="line">                            builderNames=[<span class="string">"master"</span>]))</span><br></pre></td></tr></table></figure>
</li>
<li><p>BUILDERS<br>builder定义具体执行的任务内容，由一系列的步骤组成。每个步骤定义在step中，factory包含一系列的step，builder通过指定factory等参数创建。可定义多个builder。<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义factory</span></span><br><span class="line">factory = util.BuildFactory()</span><br><span class="line"><span class="comment"># 定义具体step</span></span><br><span class="line">factory.addStep(steps.Git(repourl=<span class="string">'git://github.com/buildbot/pyflakes.git'</span>, mode=<span class="string">'incremental'</span>))</span><br><span class="line">factory.addStep(steps.ShellCommand(command=[<span class="string">"trial"</span>, <span class="string">"pyflakes"</span>]))</span><br><span class="line"><span class="comment"># 创建builder</span></span><br><span class="line">c[<span class="string">'builders'</span>] = []</span><br><span class="line"><span class="comment"># 指定名称、使用的slave、factory</span></span><br><span class="line">c[<span class="string">'builders'</span>].append(</span><br><span class="line">    util.BuilderConfig(name=<span class="string">"master"</span>,</span><br><span class="line">      slavenames=[<span class="string">"master"</span>],</span><br><span class="line">      factory=factory))</span><br></pre></td></tr></table></figure>
</li>
<li><p>STATUS TARGETS<br>此处定义buildbot对外通知build信息的方式。最基本的方式就是显示在页面中，因此此处同时定义了页面的认证方式，即登录使用的用户名、密码在此处修改。同时可定义IRC、邮件等通知方式。</p>
</li>
<li>PROJECT IDENTITY<br>此处主要为buildbot的基本信息，如title、超链接、url等。</li>
<li>DB URL<br>此处定义使用的数据库，默认使用sqlite，地址为本地文件路径。</li>
</ul>
<h3 id="配置slave"><a href="#配置slave" class="headerlink" title="配置slave"></a>配置slave</h3><p>slave的定义主要在<code>buildbot.tac</code>文件中，可用于定义使用的master及slave基本信息。</p>
<h2 id="启动及使用"><a href="#启动及使用" class="headerlink" title="启动及使用"></a>启动及使用</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul>
<li>启动<br>master、slave的启动上文已提及，子命令为start，参数为路径。</li>
<li>停止、重启<br>stop和restart，其余同start</li>
<li>master重新加载配置<br><code>buildbot reconfig master</code>即可重新加载配置。</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>平时比较常用手动触发build，即forcebuild：web页面登录-&gt;Builders-&gt;选择builder-&gt;Force Build-&gt;在Waterfall查看打包结果及详细日志。<br><img src="/img/buildbot-waterfall.png" alt="buildbot waterfall"><br>注意：只有登录后才有build权限。</p>
<h3 id="各页面介绍"><a href="#各页面介绍" class="headerlink" title="各页面介绍"></a>各页面介绍</h3><p>Buildbot比较方便的一点是全部通过页面来进行操作。主要页面介绍如下：</p>
<ul>
<li>Waterfall，以瀑布流的方式显示build任务，可点击任务查看详情、执行操作等</li>
<li>Grid/T-Grid，以对应的方式显示build任务</li>
<li>Console，还在开发中，当前主要显示revision信息</li>
<li>Builders，定义的所有builder</li>
<li>Recent Builds，最近的build</li>
<li>Buildslaves，定义的所有slave</li>
<li>Changesources，定义的所有代码仓库</li>
<li>JSON API，对外提供的JSON API文档</li>
</ul>
<h2 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h2><h3 id="多分支build"><a href="#多分支build" class="headerlink" title="多分支build"></a>多分支build</h3><p>定义一个Changesource。<br>定义多个schedulers，分别对应不同分支。<br>定义多个factory，其中的step除branch不同外，其余step通用。通用的step可一次定义，多次使用。<br>builder分别指定分支和factory。</p>
<h3 id="多项目build"><a href="#多项目build" class="headerlink" title="多项目build"></a>多项目build</h3><p>新版本可使用此功能，但不太推荐。buildbot的一个master还是更多的擅长对一个项目的管理。<br>需要定义多个Changesource，然后在其它定义时通过<code>project</code>和<code>repository</code>参数指定项目。</p>
<h3 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h3><p>通过检查step的返回结果判断是否执行成功，规则同shell：0为成功，其它失败。<br>因此如果step中调用了自己的脚本，需要保证按上述规则返回结果。</p>
<h3 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h3><p>使用<code>util.Property</code>获得网页上指定的参数，可设置默认值：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">factory.addStep(steps.ShellCommand(command=[<span class="string">"bash"</span>, <span class="string">"autorpm.sh"</span>, util.Property(<span class="string">'project'</span>, default=<span class="string">''</span>)]))</span><br></pre></td></tr></table></figure></p>
<p>在build页面通过name/value指定，如：<br><img src="/img/buildbot-param.png" alt="buildbot指定参数"></p>
<h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><p>实际使用中发现，buildslave所创建的文件，权限都为600或700。<br>这样会造成如cp到apache目录时，apache无法读取文件。<br>通过官方文档查看到slave启动时有umask选项：</p>
<blockquote>
<p>–umask<br>This is a string (generally an octal representation of an integer) which will cause the buildslave process’ umask value to be set shortly after initialization.<br>The twistddaemonization utility forces the umask to 077 at startup (which means that all files created by the buildslave or its child processes will be unreadable by any user other than the buildslave account).<br>If you want build products to be readable by other accounts, you can add –umask=022 to tell the buildslave to fix the umask after twistd clobbers it.<br>If you want build products to be writable by other accounts too, use –umask=000, but this is likely to be a security problem.</p>
</blockquote>
<p>通过修改slave目录下的buildbot.tac，修改：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umask = 022</span><br></pre></td></tr></table></figure></p>
<p>然后重启slave解决此问题:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">buildbot stop slave1</span><br><span class="line">buildbot stop slave2</span><br></pre></td></tr></table></figure></p>
<h2 id="参考索引"><a href="#参考索引" class="headerlink" title="参考索引"></a>参考索引</h2><ul>
<li><a href="https://build.chromium.org/p/chromium/console" target="_blank" rel="noopener">chromium buildbot</a></li>
<li><a href="http://docs.buildbot.net/current/tutorial/docker.html" target="_blank" rel="noopener">docker安装buildbot</a></li>
<li><a href="http://docs.buildbot.net/current/tutorial/tour.html" target="_blank" rel="noopener">quick tour of buildbot</a></li>
<li><a href="http://docs.buildbot.net/current/tutorial/fiveminutes.html" target="_blank" rel="noopener">Buildbot in 5 minutes</a></li>
</ul>
]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>openstack</tag>
        <tag>ci</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title>网关类产品的性能测试之三：其它指标测试方法</title>
    <url>/2013/03/gateway-performance-test-others/</url>
    <content><![CDATA[<p>本篇主要介绍除RFC2544四项指标外的其它指标的测试方法。其中的性能测试项主要来源于<a href="https://www.ietf.org/rfc/rfc3511.txt" target="_blank" rel="noopener">RFC3511</a>中的定义，并根据实际需求，更新或舍弃了部分指标项。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>本系列分为以下四部分：</p>
<ol>
<li><a href="http://stackeye.com/2013/03/gateway-performance-test-desc/" target="_blank" rel="noopener">简介及性能指标介绍</a></li>
<li><a href="http://stackeye.com/2013/03/gateway-performance-test-rfc2544/" target="_blank" rel="noopener">RFC2544四项指标测试方法</a></li>
<li>其它指标测试方法 - 本篇</li>
<li><a href="http://stackeye.com/2013/04/gateway-performance-test-tools/" target="_blank" rel="noopener">测试工具、注意事项及经验总结</a></li>
</ol>
<h2 id="术语介绍"><a href="#术语介绍" class="headerlink" title="术语介绍"></a>术语介绍</h2><p>文章中会涉及到一些术语，现总结如下，供参考。</p>
<ul>
<li>性能测试，对产品负载压力承受能力的测试。</li>
<li>RFC，互联网及软件等的一些标准，基本的互联网通信协议都有在RFC文件内详细说明。</li>
<li>网关类产品，部署作为网关的设备及软件。</li>
<li>IDS，入侵检测系统</li>
<li>IPS，入侵防御系统</li>
<li>UTM，对防火墙、IDS、IPS三个的综合，可以比较全面的进行管理。但是UTM通过一台物理设备集成大量功能，导致了应对大量数据的时候效率会下降，同时存在设备损坏导致全面崩溃的可能。</li>
<li>NGFW，下一代防火墙，安全设备类产品未来的发展方向。</li>
<li>被测设备，devices under test，测试设备。</li>
</ul>
<h2 id="其它性能指标测试方法"><a href="#其它性能指标测试方法" class="headerlink" title="其它性能指标测试方法"></a>其它性能指标测试方法</h2><p>以下主要包括CPS、TPS、HTTP吞吐、TCP最大连接数及其它性能指标的测试方法。</p>
<a id="more"></a>
<h2 id="TCP每秒新建（CPS）"><a href="#TCP每秒新建（CPS）" class="headerlink" title="TCP每秒新建（CPS）"></a>TCP每秒新建（CPS）</h2><p>CPS测试的目的是确定最大的TCP连接建立速度。在RFC3511文档中对TCP每秒新建的测试方法进行了定义，同时也明确了测试过程中得参数设置。但在实际评测或客户验证时，对于CPS的配置却有一些出入。这里需要我们注意的事项请参见下列说明。</p>
<ol>
<li>TCP每秒新建的参数配置，应根据客户或评测机构的实际情况进行配置。<br>有的客户在测试CPS时，只关注TCP层的建立速度，使TCP连接建立成功即可，此关注的实际是TCP连接三次握手的过程（SYN，SYN ACK ，ACK），而且连接处于OPEN状态。而有的客户关注的是TCP的完整链接状态：包括三次握手建立、持续和关闭；而且在关闭过程中，又可以选择发送TCP FIN或者RST报文的方式。因此，在测试CPS前应与客户沟通测试的参数设置。</li>
<li>在RFC3511文档中，描述了在测试CPS时，采用HTTP1.1的协议，并且响应Get请求。<br>而在有些评测机构中，在测试CPS时确实会采用HTTP1.0甚至TCP或其它基于TCP的协议进行测试。无论是否采用HTTP协议，对于CPS的测试过程基本没有影响，只是多了一个GET请求和应答。但传输的文件大小将会占用被测设备很大的系统资源，从而导致测试结果偏小。在RFC3511中，没有明确应答数据的大小，所以这里我们可以设置为1byte甚至更小。</li>
<li>在测试过程中，应采用反复搜索的方式，以确定被测设备可以接受的TCP连接的最大请求速率。测试周期建议在10分钟以上。</li>
<li>如上文所述，基于使用协议的不同，CPS可以分为L4（传输层）CPS和L7（应用层）CPS。而且大部分的厂商和客户都基本认同这两种CPS的叫法。</li>
</ol>
<h2 id="HTTP的每秒处理事务数（TPS）"><a href="#HTTP的每秒处理事务数（TPS）" class="headerlink" title="HTTP的每秒处理事务数（TPS）"></a>HTTP的每秒处理事务数（TPS）</h2><p>TPS是指最大HTTP传输速率，考察被测设备的应用层处理能力。在RFC3511文档中要求协议使用HTTP1.0或者HTTP1.1。整个过程包括TCP三次握手以后执行HTTP事务请求（GET或者POST），并且得到答应，然后关闭TCP连接。需要注意的事项请参见下列说明。</p>
<ol>
<li>HTTP1.0和HTTP1.1协议的区别<br>在HTTP1.0 协议中，每对请求/应答都使用一个新的连接。每次请求都需要客户端与服务器建立一个TCP连接，服务器收到请求并且返回应答后，会立即断开TCP连接。<br>而HTTP1.1协议是可以保持这种连接状态，是可持久的。在一个TCP连接上可以传输多个HTTP请求/应答。当传输完成后，必须采用三次握手或四次握手的方法关闭链接（FIN，ACK，FIN ACK，ACK ） 。</li>
<li>请求/应答的文件大小<br>在RFC3511文档中没有明确说明文件的大小及类型。在测试TPS前一定要向客户或评测机构了解要求的请求文件的大小及类型。有些机构中采用1 字节或者100字节的文件，而有些机构则采用1K字节或者4K字节，文件类型也多种多样。所以，应多与客户或者评测机构进行实际的沟通。<br>建议采用文件大小为1K字节、文件类型为文本文件；当采用HTTP1.0 协议时，建议Get 1次；当采用HTTP1.1协议时，建议Get 10次或者更多。</li>
<li>通过1可以看到，在测试TPS时，采用HTTP1.0协议或采用HTTP1.1协议测试同一款被测设备，会得到两种不同的测试结果<br>因为HTTP协议本身的原因，使得在传输过程中得到的事务数会有所不同。理论上讲，HTTP1.1 协议的传输事务数要高于HTTP1.0协议。但这并不能反映HTTP1.1 的每秒连接数要高于HTTP1.0的每秒连接数。<br>同时需要注意到，测试HTTP TPS时如果采用HTTP1.0，其实和TCP的L7 CPS的性能一样。从测试方法和测试过程中看，两者基本没有区别。<br>所以，在测试HTTP TPS时，一定要了解客户的关注重点，而且要与客户沟通采用哪个版本的HTTP协议。</li>
</ol>
<h2 id="HTTP有效吞吐量（HTTP-Good-Throughput）"><a href="#HTTP有效吞吐量（HTTP-Good-Throughput）" class="headerlink" title="HTTP有效吞吐量（HTTP Good Throughput）"></a>HTTP有效吞吐量（HTTP Good Throughput）</h2><p>在RFC3511文档中没有明确描述HTTP有效吞吐量的测试方法，但通过TPS的测试方法，我们可以根据要求来编写HTTP有效吞吐量的方法。需要注意的事项请参见下列说明。</p>
<ol>
<li>在TPS节，我们知道了HTTP1.0和HTTP1.1之间的区别<br>在测试HTTP有效吞吐量时，应减少TCP的建立和关闭连接的消耗和延迟。所以在测试HTTP有效吞吐量时，建议采用HTTP1.1协议。</li>
<li>在测试HTTP有效吞吐量时，建议采用请求/应答的模式<br>而且在HTTP1.1协议中，可以执行8个或8个以上的请求命令（GET）。请求的文件大小建议为64K字节的文本文件。当然，在实际测试过程中请求文件的大小及类型，应与客户或评测机构进行沟通。当请求命令越多，请求的文件越大，那么HTTP的吞吐量也就越大。</li>
</ol>
<h2 id="最大TCP并发连接数"><a href="#最大TCP并发连接数" class="headerlink" title="最大TCP并发连接数"></a>最大TCP并发连接数</h2><p>在RFC3511文档中描述的最大TCP并发连接数测试，是采用一种反复搜索机制进行，在每次反复过程中以低于被测设备所能承受的连接速率发送不同数量的并发连接，直至得出被测设备的最大TCP并发连接数。需要注意的事项请参见下列说明。</p>
<ol>
<li>在测试最大TCP并发连接数所采用的协议<br>有些客户或厂商为了追求更高的数值，在测试此项时采用TCP层协议。而一些评测机构或客户要求在测试最大TCP并发连接数时采用HTTP协议，并且要求有请求/答应机制。</li>
<li>在测试最大TCP并发连接数时使用应用层协议(HTTP)，请求/应答的传输文件大小会直接影响测试结果<br>如果应用层流量很大，被测设备会使用很大的系统资源去处理包转发或包检查等，从而导致一些请求无法被处理，引起测试结果偏小；反之测试结果会偏大。这里建议当使用HTTP协议进行测试时，请求的文件不应过大，应在1Byte左右。</li>
<li>在测试最大TCP并发连接数时，无论采用TCP协议还是采用应用层协议，都应考虑实际测试需要<br>从1中我们知道，采用TCP协议进行测试对被测设备的压力要小，并且每条连接中的负载也比较小，被测设备在转发或处理时比较容易，从而很容易达到测试的数目要求。但这并不是说采用TCP协议就是没有意义的，它从另一角度反映了被测设备能维持TCP连接的最大数量。<br>而如2中采用HTTP协议进行测试，会加大被测设备的压力，使得占用被测设备的资源去处理包转发或包检查。而且请求文件大小的不同，会引起测试结果发生偏差。在实际测试过程中，我们应与客户或评测机构进行沟通，从而测试出被测设备的真实能力，是否满足其要求。</li>
</ol>
<h2 id="其它性能指标项"><a href="#其它性能指标项" class="headerlink" title="其它性能指标项"></a>其它性能指标项</h2><p>如上，我们可以看出在TCP或应用层测试中，主要包括<strong>三个重要的指标</strong>：每秒新建、有效吞吐量和最大并发连接数。<br>其实应用层的性能测试，无论是FTP协议、Mail协议还是其它的应用协议都离不开这三个测试指标项。所以，在对其它应用层协议进行测试时，也应像HTTP协议测试一样：明确测试文件的大小，明确每条链接的负载，明确每个请求/应答的过程等。测试过程、测试方法及测试结果的计算衡量基本都与HTTP测试类似。这就要求测试人员对应用层协议要有一定的理解，甚至对每个关键字的作用要有初步的判定。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要介绍了TCP/HTTP层的性能指标的测试方法，并由此扩展到其它所有需要的应用层的性能测试方法。</p>
<h2 id="参考索引"><a href="#参考索引" class="headerlink" title="参考索引"></a>参考索引</h2><ul>
<li><a href="https://www.ietf.org/rfc/rfc3511.txt" target="_blank" rel="noopener">RFC3511</a></li>
</ul>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>ips</tag>
        <tag>NGFW</tag>
        <tag>防火墙</tag>
        <tag>spi firewall</tag>
        <tag>CPS</tag>
        <tag>TPS</tag>
      </tags>
  </entry>
  <entry>
    <title>网关类产品的性能测试之二：RFC2544四项指标测试方法</title>
    <url>/2013/03/gateway-performance-test-rfc2544/</url>
    <content><![CDATA[<p>前面我们介绍了各性能指标项的含义，下面我们针对各性能指标项是如何测试的进行详细描述。<br>对于每家评测机构、客户和安全厂商，同一个性能指标在测试方法上可能有所区别。建议在测试之前首先了解客户的需求，了解客户的性能关注点在哪里，并根据实际的需求适当的调整测试方法。虽然RFC2544文档和RFC3511文档描述了相关的测试方法，但这样的测试方法并不一定能满足客户的需求，而且RFC 文档中对测试细节并没有太详细的描述。下面以我在实际测试中积累的经验和向业界学习到的知识，描述我理解的性能测试方法。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>本系列分为以下四部分：</p>
<ol>
<li><a href="http://stackeye.com/2013/03/gateway-performance-test-desc/" target="_blank" rel="noopener">简介及性能指标介绍</a></li>
<li>RFC2544四项指标测试方法 - 本篇</li>
<li><a href="http://stackeye.com/2013/03/gateway-performance-test-others/" target="_blank" rel="noopener">其它指标测试方法</a></li>
<li><a href="http://stackeye.com/2013/04/gateway-performance-test-tools/" target="_blank" rel="noopener">测试工具、注意事项及经验总结</a></li>
</ol>
<h2 id="术语介绍"><a href="#术语介绍" class="headerlink" title="术语介绍"></a>术语介绍</h2><p>文章中会涉及到一些术语，现总结如下，供参考。</p>
<ul>
<li>性能测试，对产品负载压力承受能力的测试。</li>
<li>RFC，互联网及软件等的一些标准，基本的互联网通信协议都有在RFC文件内详细说明。</li>
<li>网关类产品，部署作为网关的设备及软件。</li>
<li>IDS，入侵检测系统</li>
<li>IPS，入侵防御系统</li>
<li>UTM，对防火墙、IDS、IPS三个的综合，可以比较全面的进行管理。但是UTM通过一台物理设备集成大量功能，导致了应对大量数据的时候效率会下降，同时存在设备损坏导致全面崩溃的可能。</li>
<li>NGFW，下一代防火墙，安全设备类产品未来的发展方向。</li>
<li>被测设备，devices under test，测试设备。</li>
</ul>
<h2 id="RFC2544四项值测试方法"><a href="#RFC2544四项值测试方法" class="headerlink" title="RFC2544四项值测试方法"></a>RFC2544四项值测试方法</h2><p>RFC2544文档对四项值的定义和测试方法描述还是比较全面的，但在细节上没有过多的描述。下面我将描述一下实际测试中总结的RFC2544四项值的性能测试方法。</p>
<a id="more"></a>
<h2 id="吞吐量（Throughput）测试方法"><a href="#吞吐量（Throughput）测试方法" class="headerlink" title="吞吐量（Throughput）测试方法"></a>吞吐量（Throughput）测试方法</h2><p>吞吐量主要是反映设备的最大转发速率，在测试过程中需要明确测试条件。需要考虑的有：</p>
<ol>
<li>测试周期：在恒定的速率下数据包的测试时长。为测试出被测设备的真实转发能力，建议测试周期不要太短，应在60秒以上，我们日常选用的是100 秒。在实际的测试中，也发现测试周期的长短对测试结果确实有一定的影响，特别是x86系统。<br>在测试周期上，RFC2544文档中指出测试周期不应少于60秒。</li>
<li>测试次数：增加测试次数以避免被测设备在数据转发中存在随机性或波动性，同时可以验证产品在数据转发中是否可靠。在实际测试中，确实也发现一些产品在进行多次测试时，每次的结果都不一样，这同时也反映了产品的可靠性。</li>
<li>测试粒度：可采用较大的变化粒度来测试吞吐量。一般多用二分查找算法或冒泡算法。</li>
<li>测试帧长：对以太网来说，一般测试帧长为：64B、128B、256B、512B、1024B、1280B、1518B。在评测机构或者客户选评时多采用上述的7 种单一帧长做为测试项。在实际测试中，除上述7种单一帧长以外，还应加入混合帧长的测试。</li>
<li>单双向测试：现在的网络设备的端口（接口）多数都是千兆起，而且工作模式基本都是全双工。测试过程中为了能更好的反映产品性能，多数测试过程中都会进行双向测试：端口上有TX流量也有RX流量。在测试方向上，RFC2544文档中的吞吐量介绍中没有明确的说明，因此单向还是双向取决于测试设计。但建议采用双向进行测试。</li>
<li>被测设备端口：吞吐量的测试都是反映被测设备的转发能力，往往一对接口无法满足测试需求，这时就要进行多端口测试。在RFC2544文档中描述了在多端口测试时，端口中最开始的一半被设计为输入端口，另一半则被设计为输出端口。这些端口应该被平均分配到测试设备结构中。这里我们建议一对一即可，前提是端口或网卡的芯片组应相同、驱动相同、在硬件设计中相同。如果任意配置有区别，都要遍历每个接口的吞吐量性能。</li>
<li>测试协议：在测试被测设备的吞吐量时，应明确数据包承载的协议。在RFC2544文档中没有明确说明在测试吞吐量时应选用哪种协议。评测机构和客户多选择UDP协议做为标准测试协议，但不排除选用IP协议或TCP协议。在实际测试中，多选择UDP协议，但也遇到过选择TCP协议的。所以，在测试开始前应沟通明确此项。</li>
<li>被测设备的转发模式：在测试时，我们需要知道被测设备是路由转发，还是透明转发。如果是路由转发在测试前要发送“学习帧”和路由更新信息等。一般这些动作不需要我们干预，测试仪表都能帮我们完成，我们需要做的是明确网关。</li>
</ol>
<h3 id="吞吐量其它注意事项"><a href="#吞吐量其它注意事项" class="headerlink" title="吞吐量其它注意事项"></a>吞吐量其它注意事项</h3><ol>
<li>在同等带宽下，长度越小的帧，数量就越大，那么被测设备处理数据帧所花费的时间就越多；相反，帧长度越大，所处理的时间就越少。</li>
<li>在计算吞吐量结果时，需要注意帧与帧的间隔长度（12byte）和前导码（8byte）。在实际测试中，发现有些测试仪表在计算结果中没有计算帧间隔和前导码。这时得出的吞吐量结果为真实数据包的结果。举例，千兆接口在测试64B性能时，线速的pps为148.8万，计算成bytes为760Mbps 左右。所以，我们在查看和统计结果时，除了记录Mbps数据，也应注意pps结果和测试出的百分比。<br>（IXIA 的IxAutomate 软件在计算吞吐量，给出的是数据结果。）</li>
<li>在测试过程中，被测设备出现测试结果波动的情况下，应增加测试次数并计算波动范围。最高值与最低值的浮动不应超过平均值的5％。并且结果记录应取最低值。</li>
</ol>
<h2 id="延迟（Latency）"><a href="#延迟（Latency）" class="headerlink" title="延迟（Latency）"></a>延迟（Latency）</h2><p>延迟（也叫做时延）的性能是反映被测设备在转发数据包时所耗用的时间。需要考虑的测试条件有：</p>
<ol>
<li>测试周期：延迟的测试周期与吞吐量的测试周期概念上是一样的，建议与吞吐量的测试周期一致。</li>
<li>测试次数：延迟的测试次数在RFC2544文档中有明确的定义：至少要在20次以上，并取被记录的平均值做为结果。但建议取被记录的结果中与平均值最接近的值做为测试结果。</li>
<li>测试结果计算方法：在测试网关产品的延迟，特别是防火墙的延迟时包括两种计算方法，一种是直通交换转发（cut throughput latency,CT），另一种是存储转发（store and forward latency,S&amp;F）：<ul>
<li>直通交换转发：入口处输入帧第1个比特到达被测设备至出口处输出帧的第1个比特输出时所用的时间间隔。</li>
<li>存储转发：入口处输入帧最后1个比特到达被测设备至出口处输出帧的第1个比特输出时所用的时间间隔。<br>建议在测试延迟时选择<strong>直通交换方式</strong>计算延迟。</li>
</ul>
</li>
<li>测试帧长：延迟测试与吞吐量测试不同，不能在同一个测试中把所有被测帧长测试完成，我们知道延迟的发包速率与吞吐量有关。所以，在测试延迟时先要知道该字节的吞吐量。一次执行脚本只进行一种帧长度的延迟测试。测试帧的长度应与吞吐量的测试帧长一致。</li>
<li>单双向测试：与吞吐量测试方法及配置一致。</li>
<li>被测设备端口：在测试延迟时，一般为两个端口或接口的延迟结果，很少有测试多端口或接口的结果。这个与吞吐量的配置是一致的。</li>
<li>测试协议：与吞吐量测试方法及配置一致。</li>
<li>被测设备转发模式：与吞吐量测试方法及配置一致。</li>
</ol>
<h3 id="延迟其它注意事项"><a href="#延迟其它注意事项" class="headerlink" title="延迟其它注意事项"></a>延迟其它注意事项</h3><ol>
<li>在测试延迟时准备的过程和内容与测试吞吐量时保持一致即可，比如数据包的协议类型、数据包帧长、被测设备的配置等。</li>
<li>在测试延迟的过程中出现丢包的话，可能导致延迟结果变得很大。所以测试延迟时不应出现丢包，否则严重影响测试结果的准确性。因此在测试延迟时先要知道吞吐量的结果。对于一些x86架构的平台，吞吐量一般都不是特别的稳定（特别是64字节的吞吐量），建议在测试延迟时发包速率使用吞吐量速率的95％。</li>
<li>在计算延迟结果时，RFC2544给出的方法是计算被记录结果的平均值。单这样计算出的结果很可能在被记录结果中找不到，建议测试结果采用被记录结果与平均值最接近的值。此外，测试次数上RFC2544要求20次以上，也建议在测试延迟时不少于20次。</li>
</ol>
<h2 id="丢包率（Frame-Loss）"><a href="#丢包率（Frame-Loss）" class="headerlink" title="丢包率（Frame Loss）"></a>丢包率（Frame Loss）</h2><p>丢包率测试过程是以特定速率发送特定数量的数据包通过被测设备，并记录被测设备转发的数据包。<br>丢包率的计算公式：<code>((输入量－输出量) * 100) / 输入量</code><br>需要考虑的测试条件：</p>
<ol>
<li>测试周期：在进行丢包率的测试时，可以选择数据包总量或者时间两种方式进行测试。数据包总量是指在测试过程中发送的数据总数，是一个恒定的值，建议数据总数不应少于10万个。测试时间这个概念与吞吐量和延迟的测试周期一样。</li>
<li>测试次数：丢包率的测试与吞吐量或延迟有所区别，一般只需要进行一次测试即可。</li>
<li>测试过程：丢包率在测试开始前，无论选择是数据包总量方式还是时间方式，在第一次测试时，都是以100％的速率进行发送数据包到被测设备上，并且记录输入量与输出量；第二次测试时，再以90％的速率发送数据包；然后以80％，每次递减10%的间隔测试速率。直到出现输入量与输出量相等，没有丢包时即为最终测试结果。</li>
<li>测试帧长：测试帧的长度应与吞吐量的测试帧长一致。</li>
<li>单双向测试：与吞吐量测试方法及配置一致。</li>
<li>被测设备端口：在测试丢包率时，一般都是测试两个端口（或接口）的延迟结果，很少有测试多端口的结果。这个与吞吐量的配置是一致的。</li>
<li>测试协议：与吞吐量测试方法及配置一致。</li>
<li>被测设备的转发模式：与吞吐量测试方法及配置一致。</li>
</ol>
<h3 id="丢包率其它注意事项"><a href="#丢包率其它注意事项" class="headerlink" title="丢包率其它注意事项"></a>丢包率其它注意事项</h3><ol>
<li>在测试丢包率时准备的过程和内容与测试吞吐量时保持一致即可，比如数据包的协议类型、数据包帧长、被测设备的配置等。</li>
<li>在测试丢包率时，可在选择以总量方式或者时间方式进行测试。选择总量方式时数据包不应少于10万个；选择时间方式时应与吞吐量的测试周期一致。</li>
<li>丢包率的报告格式有别于吞吐量和延迟，应以图形方式标出。<br>RFC2544文档中给出了报告格式的标注方法，设定X轴是输入帧速率，Y轴是输入帧速率下的丢失百分比。X轴的左端点和Y轴的底部必须是零，X轴的右端点和Y轴的顶底必须是100％。图形上的多线条可以用于报告不同帧长、协议、数据流类型的帧丢失率。</li>
</ol>
<h2 id="背靠背（Back-to-Back）"><a href="#背靠背（Back-to-Back）" class="headerlink" title="背靠背（Back-to-Back）"></a>背靠背（Back-to-Back）</h2><p>背靠背的测试过程是使用最小的数据帧间隔发送一串帧序列到被测设备，记录被测试设备转发的帧数量。背靠背的值是测试设备可以不带任何帧损失处理的帧流量串的最大长度。</p>
<ol>
<li>测试周期：背靠背的测试周期在RFC2544中规定，周期必须在2秒以上。建议测试周期与测试吞吐量的周期一致。</li>
<li>测试次数：背靠背的测试次数在RFC2544中规定，必须重复至少50次以上。取被记录的平均值做为结果。在这里同样建议取被记录的结果中与平均值最接近的值做为测试结果。同时建议测试次数可以适当減少，如果不够充足，至少要测试3次或3次以上。</li>
<li>测试计算方法：背靠背的测试方法与吞吐量的有些类似，如果记录的发送帧数量与转发的帧数量相同，帧流量串的长度被增加，并重新运行测试。如果转发的帧数量小于发送的帧数量，突发帧流量串的长度被减少，并重新运行测试。背靠背的值是在不丢帧情况下被测设备所能处理的最长突发数据帧量。</li>
<li>测试帧长：测试帧的长度应与吞吐量的测试帧长一致。</li>
<li>单双向测试：与吞吐量测试方法及配置一致。</li>
<li>被测设备端口：与吞吐量的配置一致。</li>
<li>测试协议：与吞吐量测试方法及配置一致。</li>
<li>被测设备的转发模式：与吞吐量测试方法及配置一致。</li>
</ol>
<h3 id="背靠背其它注意事项"><a href="#背靠背其它注意事项" class="headerlink" title="背靠背其它注意事项"></a>背靠背其它注意事项</h3><ol>
<li>在测试背靠背时准备的过程和内容与测试吞吐量时保持一致即可，比如数据包的协议类型、数据包帧长、被测设备的配置等。</li>
<li>测试背靠背主要是测试被测试设备缓冲处理突发（Burst）数据的能力，考验的是被测试设备处理突发数据流缓存数据并快速处理的能力。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>RFC2544四项值是当前网络互联设备性能测试的普遍使用标准，包括吞吐量、延迟、丢包率和背靠背。其中多数厂商或评测机构将吞吐量和延迟做为重要指标进行测试，但并不是说丢包率和背靠背不重要，而是制定了一种快速测试的策略。所以当我们想了解一个产品的基本性能，就可以优先测试吞吐量和延迟。</li>
<li>RFC2544四项值的测试是被运用最广泛的测试指标项，而且也是最基本的测试指标项。在测试过程中，多数的厂商或客户都会选用UDP 协议做为承载协议进行测试，很少有用TCP协议或者只用IP层进行测试。</li>
<li>RFC2544文档是定义四项值的测试方法，RFC1242文档中定义了四项值的名词解释。</li>
</ol>
<h2 id="参考索引"><a href="#参考索引" class="headerlink" title="参考索引"></a>参考索引</h2><ul>
<li><a href="https://www.ietf.org/rfc/rfc2544.txt" target="_blank" rel="noopener">RFC2544</a></li>
<li><a href="https://tools.ietf.org/html/rfc1242" target="_blank" rel="noopener">RFC1242</a></li>
<li><a href="https://www.fortinet.com/content/dam/fortinet/assets/data-sheets/Fortinet_Product_Matrix.pdf" target="_blank" rel="noopener">Fortigate产品性能指标</a></li>
</ul>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>ips</tag>
        <tag>NGFW</tag>
        <tag>防火墙</tag>
        <tag>spi firewall， rfc2544</tag>
      </tags>
  </entry>
  <entry>
    <title>网关类产品的性能测试之四：测试工具、注意事项及经验总结</title>
    <url>/2013/04/gateway-performance-test-summary/</url>
    <content><![CDATA[<p>前面我们介绍了各性能指标项的测试方法。本篇主要概述测试工具、测试拓扑及经验总结。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>本系列分为以下四部分：</p>
<ol>
<li><a href="http://stackeye.com/2013/03/gateway-performance-test-desc/" target="_blank" rel="noopener">简介及性能指标介绍</a></li>
<li><a href="http://stackeye.com/2013/03/gateway-performance-test-rfc2544/" target="_blank" rel="noopener">RFC2544四项指标测试方法</a></li>
<li><a href="http://stackeye.com/2013/03/gateway-performance-test-others/" target="_blank" rel="noopener">其它指标测试方法</a></li>
<li><a href="http://stackeye.com/2013/04/gateway-performance-test-tools/" target="_blank" rel="noopener">测试工具、注意事项及经验总结</a></li>
</ol>
<h2 id="术语介绍"><a href="#术语介绍" class="headerlink" title="术语介绍"></a>术语介绍</h2><p>文章中会涉及到一些术语，现总结如下，供参考。</p>
<ul>
<li>性能测试，对产品负载压力承受能力的测试。</li>
<li>RFC，互联网及软件等的一些标准，基本的互联网通信协议都有在RFC文件内详细说明。</li>
<li>网关类产品，部署作为网关的设备及软件。</li>
<li>IDS，入侵检测系统</li>
<li>IPS，入侵防御系统</li>
<li>UTM，对防火墙、IDS、IPS三个的综合，可以比较全面的进行管理。但是UTM通过一台物理设备集成大量功能，导致了应对大量数据的时候效率会下降，同时存在设备损坏导致全面崩溃的可能。</li>
<li>NGFW，下一代防火墙，安全设备类产品未来的发展方向。</li>
<li>被测设备，devices under test，测试设备。</li>
</ul>
<h2 id="性能测试工具"><a href="#性能测试工具" class="headerlink" title="性能测试工具"></a>性能测试工具</h2><p>对于网关类产品，一般要求的性能值比较高，因此测试一般使用专用的硬件设备。<br>常用硬件设备有IAXA等。<br>常用的测试软件有：</p>
<ul>
<li><a href="https://iperf.fr/" target="_blank" rel="noopener">iperf</a></li>
<li><a href="http://jmeter.apache.org/" target="_blank" rel="noopener">Jmeter</a>使用Java编写，主要用于软件的性能测试，但也可扩展用于网络性能测试。机器配置足够的情况下，流量可打到上百M。</li>
<li><a href="http://tomahawk.sourceforge.net/" target="_blank" rel="noopener">tomahawk</a>是一个回放数据包的工具，也可完成部分性能测试。</li>
<li>而软件的性能测试常用的LoadRunner，一般难以用于网络的性能测试。</li>
</ul>
<a id="more"></a>
<h2 id="测试拓扑"><a href="#测试拓扑" class="headerlink" title="测试拓扑"></a>测试拓扑</h2><p>前文主要介绍了2－7层的性能测试方法，除此之外我们还需要注意测试拓扑结构。<br>从物理环境上看，性能测试拓扑是比较单一的，没有多少复杂度：测试仪表连接被测设备，就可开始测试。需要注意的是测试仪中的制定的测试拓扑，在每次性能测试开始前，我们都需要明确客户端数目、服务器数目、源IP、目的IP和NAT等。以下为根据实际的测试经验简单总结一下性能测试在拓扑制定上需要注意的事项。</p>
<ol>
<li>在测试2－7层的性能时，测试仪和被测设备的转发模式我们一般会选择透明模式或者路由模式。<br>透明模式相当于二层，被测设备的配置相对简单，配置相应的转发规则即可。测试仪表的配置中源IP地址和目的IP地址要在相同的地址网段中，客户端和服务器的数目不应大于IP地址数，客户端的数目建议大于服务器端数目。<br>路由模式相当于三层，被测设备的配置相对复杂一些，需要配置接口的IP地址、路由表及相应的转发规则等。测试仪表的配置中源IP地址和目的IP地址要与被测设备的接口IP地址相对应，并且需要配置ARP响应机制或IPv6地址的学习机制，其它与配置透明模式的一致。</li>
<li>在测试2－3层的性能，特别是RFC2544四项值时，建议测试仪采用UDP协议做为测试的承载协议。<br>当然，也有一些客户会选择IP层或者TCP层做为承载协议。这里没有硬性的规定，但大部分评测机构或者客户都会选择UDP协议进行测试。<br>当选择UDP协议进行测试时，UDP协议的端口号应避免已知的常用协议，如DNS的53端口，TFTP的69端口等，当然也没有硬性的规定。建议使用UDP端口7或0做为源和目的端口，或者直接使用测试仪的默认端口即可。</li>
<li>在测试4－7层的性能时，需要注意客户端与服务器之间的对应关系。TODO<br>在测试需求或测试要求中，我们可能会遇到多个客户端对应一台服务器或者多个客户端对应多台服务器的情况。<br>在多对一的环境中，控制客户端数目不要过多，应根据被测设备应用的实际场景确定数目，源IP地址和目的IP地址建议使用一个C类网段。<br>在多对多的环境中，会出现两种测试拓扑结构。其中一种是多对一的单一叠加方式，另一种是全部混搭方式。这两者的客户端请求方式存在很大的差异。全部混搭方式要比单一叠加的方式更接近实际的应用场景，而这正是我们搭建测试拓扑的关键。如果被测设备足够好，无论采用哪种方式，性能结果都不应该有变化。因此，建议在测试4－7层的性能时，应采用全部混搭的方式搭建拓扑结构。</li>
<li>在测试4－7层的性能时，还应注意源IP地址与目的IP地址的数目。<br>前面我们提到在多对一的测试拓扑中，建议使用一个C类地址段。在多对多的测试拓扑中，可以使用一个C类地址段，也可以使用多个C类地址段或一个B类地址段。<br>这里建议在多对多的测试拓扑结构中，决定使用几个地址段时，应参考被测设备在实际应用场景所能承受的最大负载。比如，将一个百兆的网关类设备放在一个数据中心的出口处显然不太适合，所以在测试时给它分配一个B类地址段或多个C类地址段，也显然不适合。<br>在设计和搭建测试拓扑时，应充分考虑被测设备所应用的场景，从而给它量身定做源IP地址和目的IP地址、甚至是客户端与服务器的数量等。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本篇相信大家对性能测试有了一更深入的理解，以下是一些经验总结及注意事项。</p>
<ol>
<li>对于网络安全类产品或网关类产品，RFC2544四项值一直作为性能测试的首要测试指标，从1999年发布一直使用至今。<br>业界有人认为RFC2544四项值已经不太适用于现代的产品，特别是对于IPS、AV和UTM的产品。但无可否认的是，RFC2544四项值是最能反映产品在底层转发的性能，而且从侧面反映了产品在低层转发过程中的稳定性。所以，RFC2544四项值将会被一直延用，并且作为一个重要测试指标一直延用下去。</li>
<li>在网络安全类产品或网关类产品中，RFC3511对于4－7层的性能测试方法的定义过于模糊。<br>这使得4－7层的性能测试存在很大的争议，比如请求文件的大小、每条连接中请求的次数、协议版本、客户端与服务器数目等，都是争义的内容。特别是当产品集成了IPS、AV 和UTM功能后，在测试的细节上争义更为严重。比如URL地址是否相同、文件类型的变化、文件内容是否相同、IP地址端口的遍历、客户端与服务器所使用的软件及软件版本等。一个细微的不同，可能就会导致测试结果不同。所以，在对4－7层进行性能测试时，一定要与客户或评测机构沟通，指定相关的细节，从而验证产品的真实性能。同时，做为性能测试人员，在制定测试方法和测试拓扑时，应充分考虑被测设备所能应用的场景。这样的测试结果才是真实、可信并且有意义的。</li>
<li>在此系列文章中没有介绍混合流量的性能测试，特别是应用层协议的混合流量性能测试。<br>首先无论是单一协议还是混合协议，主要关注新建速率和吞吐量值。而且混合流量中吞吐量的结果，可能是大家最为关注的。但混合流量中各协议的分配比例，没有一个权威的机构支撑，也难有哪个机构能够支撑。因为网络环境中的应用千变万化，网络实际应用场景也大不相同，比如教育网、中小企业、政府机构、金隔业场景等。混合流量没有一个统一的模板，所以在指定协议分配比例时，多数是参考评测机构发布的数据或者凭借自身经验指定的模板。因此，混合流量的性能测试没有在本篇中涉及。</li>
<li>对于性能测试人员，不仅要了解产品特性，还要对协议有一定的了解。<br>特别是应用层的协议，了解各协议的数据处理流程，从而指定客户端请求与服务器的应答等过程。</li>
<li>性能测试也要有需求意识。<br>性能测试人员要懂得倾听，明白哪些是客户最想了解的，哪些是评测机构最想知道的。只有了解到需求，才能制定一份符合产品的测试方法，才能得出产品的真实性能结果。</li>
</ol>
<h2 id="参考索引"><a href="#参考索引" class="headerlink" title="参考索引"></a>参考索引</h2><ul>
<li><a href="https://www.ietf.org/rfc/rfc3511.txt" target="_blank" rel="noopener">RFC3511</a></li>
<li><a href="http://wenku.baidu.com/link?url=Ih8o0RQ8OcRMoiJHO4yaJTDqPKz5NYt--mc63aeUQCQlrruS_KXQsnWf_AG7U73vo5ciytSLZNyGQTB5kPY9-xn7E4rScqtQGAy8U8ucD_O###" target="_blank" rel="noopener">网络安全产品的性能测试研究</a> - 阐述较为全面的硕士论文</li>
</ul>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>ips</tag>
        <tag>NGFW</tag>
        <tag>防火墙</tag>
        <tag>spi firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之九：代理的使用</title>
    <url>/2012/08/linux-curl-basic-usage-proxy/</url>
    <content><![CDATA[<p>这个时代估计很少有人不知道Facebook，也很少有人不知道为啥国内无法直接访问Facebook。<br>因此，实际应用中，我们会经常使用到代理。<br>本篇着重讲述在curl命令行中对代理的使用。</p>
<h2 id="代理环境"><a href="#代理环境" class="headerlink" title="代理环境"></a>代理环境</h2><p>本篇中，我们将代理分为HTTP代理和socks代理。<br>可是使用wallproxy+GAE的方式搭建个属于自己的代理，具体请百度或wallproxy官网。wallproxy设置完成后，代理默认为<code>127.0.0.1:8086</code>。</p>
<h2 id="选项-x-–proxy"><a href="#选项-x-–proxy" class="headerlink" title="选项-x/–proxy"></a>选项-x/–proxy</h2><p>参数格式为： <code>-x/--proxy &lt;proxyhost[:port]&gt;</code><br>1、使用指定的HTTP代理<br>如果未指定端口，默认端口为1080。比如使用我们本机wallproxy搭建的代理：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x 127.0.0.1:8086 -e http://www.ip138.com/ http://iframe.ip138.com/city.asp</span><br></pre></td></tr></table></figure></p>
<p>即可看到我们的IP变成了代理服务器的IP。<br><a id="more"></a><br>2、此选项优先级高于环境变量中的代理设置。<br>因此当环境变量中设置使用代理时，可以指定代理为”“而跳过代理。</p>
<p>3、所有通过HTTP代理的操作都会被显示的转化为HTTP，因此某些协议的特殊操作可能无法正常使用。<br>此问题可以通过使用<code>-p/--proxytunnel</code>选项构建基于代理的通信隧道得到解决。</p>
<p>4、在版本7.14.1之后，可以通过和环境变量相同的方式指定代理。<br>如使用协议头（http://），或使用内嵌的用户名密码（见下节）。</p>
<p>5、如果有多个-x使用，只有最后一个有效。</p>
<p>6、<code>--proxy1.0 &lt;proxyhost[:port]&gt;</code><br>使用HTTP1.0版本的代理。默认使用-x/–proxy时，使用的HTTP/1.1版本的代理。</p>
<h2 id="选项-U-–proxy-user"><a href="#选项-U-–proxy-user" class="headerlink" title="选项-U/–proxy-user"></a>选项-U/–proxy-user</h2><p>参数格式为： <code>-U/--proxy-user &lt;user:password&gt;</code><br>1、指定用于HTTP代理认证的用户名密码。curl语句如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x proxy.xxx.com:8080 -U username:password -e http://www.ip138.com/ \</span><br><span class="line">http://iframe.ip138.com/city.asp</span><br></pre></td></tr></table></figure></p>
<p>此语句等价于使用内嵌用户名密码的形式：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x <span class="string">'http://username:password@proxy.xxx.com'</span> -e http://www.ip138.com/ \</span><br><span class="line">http://iframe.ip138.com/city.asp</span><br></pre></td></tr></table></figure></p>
<p>注：</p>
<ul>
<li>curl中每个需要用户名+密码的参数，你都可以只指定用户名，curl会自动提示你输入密码，这样更安全。</li>
<li>用户名密码中如果有shell特殊字符，如$、引号等，建议放在单引号中，这样不会转义。特殊字符经常造成难以察觉的错误。如密码为<code>$password</code>，则执行以下代码会提示密码错误，因为shell把$password理解为取变量password的值了：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x http://username:<span class="variable">$password</span>@proxy.xxx.com -e http://www.ip138.com/ \</span><br><span class="line">http://iframe.ip138.com/city.asp</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2、如果使用了支持SSIP的curl库而使用NTLM方式认证的话，可以在-U后使用冒号，如”-U :“，从而强制curl从环境中读取用户名密码。</p>
<p>3、同-x，如果有多个-U使用，只有最后一个有效。</p>
<h2 id="认证方式类选项"><a href="#认证方式类选项" class="headerlink" title="认证方式类选项"></a>认证方式类选项</h2><p>认证方式介绍请参见HTTP认证模式。</p>
<ol>
<li><p><code>--proxy-anyauth</code><br>让curl自动选择合适的认证方法。这时curl会先发出一次请求来查询认证类型。</p>
</li>
<li><p><code>--proxy-basic</code><br>让curl使用HTTP基本认证（HTTP  Basic authentication）模式与代理服务器通信。这是默认模式。此模式下用户名密码作为明文传递。<br>使用–basic选项启用HTTP基础模式。</p>
</li>
<li><p><code>--proxy-digest</code><br>使用HTTP摘要认证（HTTP Digest authentication）。此模式避免将密码作为明文在网络上传递，相对提高了HTTP认证的安全性。<br>使用–digest选项启用HTTP摘要认证模式。</p>
</li>
<li><p><code>--proxy-negotiate</code><br>使用HTTP协商认证（HTTP Negotiate authentication）。<br>使用–negotiate选项启用此模式。</p>
</li>
<li><p><code>--proxy-ntlm</code><br>使用HTTP NTLM认证（HTTP NTLM authentication）。<br>同样，–ntlm启用此模式。</p>
</li>
</ol>
<h2 id="socks代理类选项"><a href="#socks代理类选项" class="headerlink" title="socks代理类选项"></a>socks代理类选项</h2><p>因为socks代理与-x选项指定的代理冲突，因此指定socks后，会覆盖掉之前使用-x指定的代理。<br>同-x，如果多次指定socks代理，只有最后一次有效。<br>在7.21.7版本之后，可以通过-x使用协议头指定代理类型的方式使用socks代理。</p>
<h3 id="1-socks4-lt-host-port-gt"><a href="#1-socks4-lt-host-port-gt" class="headerlink" title="1. --socks4 &lt;host[:port]&gt;"></a>1. <code>--socks4 &lt;host[:port]&gt;</code></h3><p>使用socks4代理。<br>在7.21.7版本之后，可以使用<code>-x socks4://</code> 代替此参数。<br>我们可以采用ssh的-D选项构建转发环境搭建socks代理实际测试一下。</p>
<p>1）Linux机器A：10.1.1.2，有PHP服务器，开启ssh<br>/var/www下新建ip.php:<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$onlineip = $_SERVER[<span class="string">'REMOTE_ADDR'</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"ip:"</span>.$onlineip;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>2）Linux机器B：10.1.1.3，已安装curl、ssh客户端<br>执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -D 8086 10.1.1.2</span><br></pre></td></tr></table></figure></p>
<p>开启转发，搭建socks代理<br>3）机器B<br>执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://10.1.1.2/ip.php</span><br></pre></td></tr></table></figure></p>
<p>可看到本机IP为10.1.1.3。<br>执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --socks4 127.0.0.1:8086 http://10.1.1.2/ip.php</span><br></pre></td></tr></table></figure></p>
<p>可看到代理IP为10.1.1.2。</p>
<h3 id="2-socks4a-lt-host-port-gt"><a href="#2-socks4a-lt-host-port-gt" class="headerlink" title="2. --socks4a &lt;host[:port]&gt;"></a>2. <code>--socks4a &lt;host[:port]&gt;</code></h3><p>socks4a是socks4的扩展，主要增加了域名解析，其余相同。<br><code>--socks4a</code>参数指定使用代理服务器解析域名，其余使用方法相同。<br>在7.21.7版本之后，可以使用<code>-x socks4a://</code> 代替。</p>
<h3 id="3-socks5-lt-host-port-gt"><a href="#3-socks5-lt-host-port-gt" class="headerlink" title="3. --socks5 &lt;host[:port]&gt;"></a>3. <code>--socks5 &lt;host[:port]&gt;</code></h3><p>socks5在socks4的基础上增加了各种验证的支持。参数使用方法相同。<br>在7.21.7版本之后，可以使用<code>-x socks5://</code> 代替。</p>
<h3 id="4-socks5-hostname-lt-host-port-gt"><a href="#4-socks5-hostname-lt-host-port-gt" class="headerlink" title="4. --socks5-hostname &lt;host[:port]&gt;"></a>4. <code>--socks5-hostname &lt;host[:port]&gt;</code></h3><p>基本同–socks5参数，但是此参数指定使用代理服务器解析域名，而不是本地解析。而–socks5是使用本地域名解析。<br>在7.21.7版本之后，可以使用<code>-x socks5h://</code> 代替。</p>
<h3 id="5-socks5-gssapi-service-lt-servicename-gt"><a href="#5-socks5-gssapi-service-lt-servicename-gt" class="headerlink" title="5. --socks5-gssapi-service &lt;servicename&gt;"></a>5. <code>--socks5-gssapi-service &lt;servicename&gt;</code></h3><p>设置使用gssapi的socks5代理服务器的服务名。</p>
<h3 id="6-socks5-gssapi-nec"><a href="#6-socks5-gssapi-nec" class="headerlink" title="6. --socks5-gssapi-nec"></a>6. <code>--socks5-gssapi-nec</code></h3><p>设置对NEC代理服务器的兼容性。</p>
<h2 id="环境变量及相关选项"><a href="#环境变量及相关选项" class="headerlink" title="环境变量及相关选项"></a>环境变量及相关选项</h2><h3 id="1-环境变量"><a href="#1-环境变量" class="headerlink" title="1. 环境变量"></a>1. 环境变量</h3><p><code>http_proxy [protocol://]&lt;host&gt;[:port]</code><br>设置HTTP协议使用的代理，大小写敏感，只能小写。<br>继续使用wallproxy+GAE搭建的代理，编写脚本curlvariable.sh如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8086</span><br><span class="line">curl -e http://www.ip138.com/ http://iframe.ip138.com/city.asp;<span class="built_in">echo</span></span><br></pre></td></tr></table></figure></p>
<p>执行<code>bash curlvariable.sh</code>后将会看到ip变成了代理服务器的IP。</p>
<p>其它常用相关环境变量如下：</p>
<ul>
<li><code>HTTPS_PROXY [protocol://]&lt;host&gt;[:port]</code><br>设置HTTPS协议使用的代理，大小写都可以，小写优先。</li>
<li><code>FTP_PROXY [protocol://]&lt;host&gt;[:port]</code><br>设置FTP协议使用的代理，大小写都可以，小写优先。</li>
<li><code>ALL_PROXY [protocol://]&lt;host&gt;[:port]</code><br>如果某协议没有指定代理，则使用此代理。大小写都可以，小写优先。</li>
<li><code>NO_PROXY &lt;comma-separated list of hosts&gt;</code><br>后跟host（服务器）列表，访问在列表中的host时，不使用代理。如果列表使用通配符”*“，则匹配所有host。</li>
</ul>
<p>如使用<code>NO_PROXY</code>, 可更改curlvariable.sh如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">!/bin/sh</span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8086</span><br><span class="line"><span class="built_in">export</span> no_proxy=ip138.com</span><br><span class="line">curl -e http://www.ip138.com/ http://iframe.ip138.com/city.asp;<span class="built_in">echo</span></span><br></pre></td></tr></table></figure></p>
<p>执行<code>bash curlvariable.sh</code>后将会看到ip不是代理服务器的IP。</p>
<h3 id="2-命令选项"><a href="#2-命令选项" class="headerlink" title="2. 命令选项"></a>2. 命令选项</h3><p><code>--noproxy &lt;no-proxy-list&gt;</code><br>指定不使用环境变量中代理的host列表<br>更改curlvariable.sh如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8086</span><br><span class="line">curl --noproxy ip138.com -e http://www.ip138.com/ http://iframe.ip138.com/city.asp;<span class="built_in">echo</span></span><br></pre></td></tr></table></figure></p>
<p>执行<code>bash curlvariable.sh</code>后将会看到ip不是代理服务器的IP。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要介绍与代理相关的curl选项。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP认证模式</title>
    <url>/2012/08/http-auth-schemes/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在研究curl和httpclient，用到了HTTP认证相关的知识。<br>但是搜索之后发现，网上居然没有很全面的HTTP认证模式的介绍，尤其是中文的文章。<br>因此结合MS的<a href="http://msdn.microsoft.com/en-us/library/ms789031.aspx" target="_blank" rel="noopener">Understanding HTTP Authentication</a>和<a href="http://hc.apache.org/httpcomponents-client-ga/tutorial/html/authentication.html" target="_blank" rel="noopener">HttpClient Tutorial</a>翻译加个人理解写了一篇。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇博文简介了几种HTTP认证模式。文章内容要求读者对HTTP请求、响应的基本结构，HTTP状态码和HTTP协议头有一定的了解。<br>请参考<a href="http://stackeye.com/2012/07/linux-curl-http-protocol/" target="_blank" rel="noopener">Linux下cURL使用教程之二：HTTP协议概述</a>。</p>
<h2 id="HTTP访问认证框架"><a href="#HTTP访问认证框架" class="headerlink" title="HTTP访问认证框架"></a>HTTP访问认证框架</h2><p>HTTP协议（RFC2616）定义了一个简单的访问认证模式框架。此框架假设有若干页面（被保护资源，也称作realm，区域），只能被特定的人访问，这些人可以在服务器要求时提供凭证。<br>当客户端如浏览器访问一个位于保护区域（protected realm）中的页面时，服务器返回包含401未认证状态码和www认证头（WWW-Authenticate header field）的响应。返回的认证头中必须含有至少一个适用于请求页面的认证要求（challenge）。<br>然后客户端发起第二次请求，此次请求在请求头中包含了试用于服务器认证要求的认证头域。<br>如果服务器接受了客户端提供的凭证，它将返回客户端请求的页面。否则，服务端会返回另一个401未认证响应以提示客户端认证失败。<br>具体认证响应头和请求头的内容取决于认证的方式。RFC2616中定义了两种广泛使用的认证模式：<br>HTTP基本认证（HTTP  Basic authentication）和HTTP摘要认证（HTTP Digest authentication）。<br>此外常用的还有NTLM、SPNEGO（HTTP协商认证，HTTP Negotiate authentication，是其一种）和Kerberos认证方式。<br><a id="more"></a></p>
<h2 id="认证模式"><a href="#认证模式" class="headerlink" title="认证模式"></a>认证模式</h2><h3 id="1-基本认证Basic-Access-Authentication"><a href="#1-基本认证Basic-Access-Authentication" class="headerlink" title="1. 基本认证Basic Access Authentication"></a>1. 基本认证Basic Access Authentication</h3><p>基本认证是基于用户名密码的。<br>服务端的401响应中包含一个认证要求（authentication challenge），此认证要求中含有“Basic”关键字和一个用以表明访问的被保护资源名称的“名称=值”对，如下：<br><code>WWW-Authenticate: Basic realm=&quot;Protected page&quot;</code><br>如果你使用的浏览器，浏览器在接收到401响应时，将会弹出窗口让你输入用户名密码，然后发送认证请求。认证请求中同样包含”Basic”关键字，此外还有Base64编码后的用户名密码，如下：<br><code>Authorization: Basic QWRlcGxveSdzIGJsb2c=</code><br>服务器将用户名密码解码后比对，成功匹配后即认证成功。<br>因为Base64不算是一种加密方法：无密钥的可逆加密，任何人都可解密（百度搜索一下”在线解码“一大堆）。因此基本认证被认为是明文传输，安全性不好。极易出现密码被窃听和重放攻击等安全性问题。<br>如果资源需要更高强度的保护，请使用其他认证方法。</p>
<h3 id="2-摘要认证HTTP-Digest-authentication"><a href="#2-摘要认证HTTP-Digest-authentication" class="headerlink" title="2. 摘要认证HTTP Digest authentication"></a>2. 摘要认证HTTP Digest authentication</h3><p>摘要认证被设计用来弥补基本认证的缺点。摘要认证基于请求-响应（challenge-response）模式，而且使用了哈希加密算法（常用为MD5），从而某些程度上解决了基本认证安全性的问题。<br>服务器返回的初始401响应的www认证头（WWW-Authenticate header）中多出了一个称为nonce的随机数的字段。服务端保证每个401响应中的nonce值唯一。如：<br><code>Authorization: Digest username=&quot;admin&quot;, realm=&quot;HiPER&quot;</code><br>接下来的客户端响应中将包含由用户名、密码、nonce和其他信息组成的数据的哈希值（如使用MD5加密）。所有被加密的数据服务端也具有，因此服务端执行同样加密过程。如果二者一直则认证成功。<br>因为如MD5等哈希加密算法是不可逆的，因此用户名密码明文无法被窃听破解。因为服务器对同一个nonce的请求只接受一次客户端请求，从而能避免重放攻击。<br>但是，digest的安全性也有缺点：</p>
<ul>
<li>只有密码密码被加密，而客户端最终请求的被保护资源是明文传送的，可被窃听</li>
<li>客户端无法确认服务端的正确身份，缺少对服务端的认证方式</li>
<li>近年来，随着计算机性能的提高等因素，传统高强度加密算法的破解已成可能。而MD5更是已有破解方法。</li>
</ul>
<p>更多安全性问题请参考RFC2617。</p>
<h3 id="3-NTML"><a href="#3-NTML" class="headerlink" title="3. NTML"></a>3. NTML</h3><p>NTML由微软开发，使用于Windows平台。被认为是比摘要认证更安全的认证方式。<br>它使用Windows凭证（Windows credentials）来传递认证数据，而不是使用未编码的用户名密码。<br>NTML要求服务器与客户端做出多次数据交换，服务器和所有其中的代理都必须支持永久连接（persistent connections）才能完成认证。</p>
<h3 id="4-Kerberos"><a href="#4-Kerberos" class="headerlink" title="4. Kerberos"></a>4. Kerberos</h3><p>服务器与客户端通过第三方的Kerberos服务器完成认证。具体请参见<a href="http://baike.baidu.com/view/306687.htm" target="_blank" rel="noopener">百度百科条目</a>和<a href="http://zh.wikipedia.org/wiki/Kerberos" target="_blank" rel="noopener">维基百科条目</a>。<br>Kerberose相比NTML有很大改善：速度快，而且允许相互认证、认证代理和简单的信任关系。参考<a href="http://msdn.microsoft.com/en-us/library/aa480475.aspx" target="_blank" rel="noopener">KERBEROS vs NTLM</a>。</p>
<h3 id="5-SPNEGO"><a href="#5-SPNEGO" class="headerlink" title="5. SPNEGO"></a>5. SPNEGO</h3><p>全称是Simple and Protected GSS-API Negotiation，是微软提供的一种使用<a href="http://baike.baidu.com/view/1551940.htm" target="_blank" rel="noopener">GSS-API</a>认证机制的安全协议，用于使Webserver共享Windows Credentials，它扩展了Kerberos(一种网络认证协议)。<br>SPNEGO适用于客户端需要认证，但是客户端服务端都不清楚对方支持什么认证协议的场合。<br>SPENGO其实是一种”伪认证机制“（pseudo-mechanism），用以协商出真正的认证机制。<br>最常见的是微软的HTTP协商认证扩展（HTTP Negotiate authentication extension），协商的最终机制在NTML和Kerberos中选择。Kerberos因其优点优先使用。<br>百度词条对此认证的解释是不够准确的，准确的解释可以参考<a href="http://en.wikipedia.org/wiki/SPNEGO" target="_blank" rel="noopener">维基百科条目</a>。</p>
<h2 id="认证方式选择"><a href="#认证方式选择" class="headerlink" title="认证方式选择"></a>认证方式选择</h2><p>选择何种认证方式取决于资源要被保护的程度。不需要保护的资源使用基本认证方式。因为认证会导致更多的数据传输，可能影响用户体验。<br>认证方式最弱的是基本认证，最强的是协商认证。服务端在WWW-Authentication提供自己支持的认证方式，供客户端任意选择。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>RFC2616-HTTP协议<br>RFC2617-HTTP认证：基本认证和摘要认证<br>RFC1321-MD5摘要加密逻辑<br><a href="http://frontier.userland.com/stories/storyReader$2159" target="_blank" rel="noopener">HTTP Authentication Schemes</a></p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之五：curl基本使用之提交表单</title>
    <url>/2012/08/linux-curl-basic-usage-forms/</url>
    <content><![CDATA[<p>很多时候，我们想获得的内容或者想进行的操作，只有在登陆之后才有权限，此时就需要用到提交表单。<br>表单以HTML的形式呈现给用户，用户使用表单提交数据后，服务端获得表单数据进行处理，然后进行后续操作。比如我们登录的过程，登录的表单呈现给我们，输入用户名密码提交后，服务端获得用户名密码在数据库中查询，以查询结果判定密码正确与否。<br>向HTTP服务器提交数据常用的有GET和POST两种方法。下文针对这两种方法，结合实例说明curl的使用。</p>
<h2 id="PHP程序"><a href="#PHP程序" class="headerlink" title="PHP程序"></a>PHP程序</h2><p>同前篇，服务端所有代码通过php实现。</p>
<ul>
<li>post.php，显示表单用于POST提交数据：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">PHP POST Demo <span class="keyword">for</span> curl basic usage By Stackeye</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">This is a post form demo.&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;form action=<span class="string">"welcome.php"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">Name: &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span> /&gt;</span><br><span class="line">Age: &lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span> /&gt;</span><br><span class="line">&lt;input type=<span class="string">"submit"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;a href=<span class="string">"http://www.stackeye.com"</span> target=<span class="string">"_blank"</span>&gt;Stackeye<span class="string">'s Blog&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li>welcome.php，处理POST或GET的数据并显示：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">PHP Form Demo <span class="keyword">for</span> curl basic usage By Stackeye</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">This is a PHP Form Demo.&lt;br /&gt;</span><br><span class="line">It can parse both GET <span class="keyword">and</span> POST data.&lt;br /&gt;</span><br><span class="line">This is a &lt;strong&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span>(count($_POST) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"POST"</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"GET"</span>; </span><br><span class="line"><span class="meta">?&gt;</span>&lt;/strong&gt; Request.&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">Welcome &lt;strong&gt;<span class="meta">&lt;?php</span> <span class="keyword">echo</span> $_REQUEST[<span class="string">"name"</span>]; <span class="meta">?&gt;</span>&lt;/strong&gt;.&lt;br /&gt;</span><br><span class="line">You are &lt;strong&gt;<span class="meta">&lt;?php</span> <span class="keyword">echo</span> $_REQUEST[<span class="string">"age"</span>]; <span class="meta">?&gt;</span>&lt;/strong&gt; years old.</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;a href=<span class="string">"http://www.stackeye.com"</span> target=<span class="string">"_blank"</span>&gt;Stackeye<span class="string">'s Blog&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="跟踪表单提交的过程"><a href="#跟踪表单提交的过程" class="headerlink" title="跟踪表单提交的过程"></a>跟踪表单提交的过程</h2><p>提交表单的过程比GET网页的过程要复杂些。GET一个网页一般只会对Referer、User-Agent等字段进行限制。而提交表单的过程，需要知道提交的数据的字段名称、字段值的格式等。而且某些表单还含有隐藏字段。因此使用curl提交表单一般需要我们分析网页源代码，甚至采用抓包工具等进行数据包的分析。</p>
<p>我们分析的一般都是HTTP协议，chrome自带的Developer Tools可以更容易的分析HTTP协议，因此我们使用此工具（Firefox上的Firebug插件提供类似功能）。<br>以下分析基于chrome浏览器。Firefox浏览器需要自行安装firebug插件。</p>
<p>使用chrome打开网页（注意360急速浏览器下要使用“极速模式”，不要使用“兼容模式”），然后右键“审核元素”即可，如下图：<br><img src="/img/developertools.jpg" alt="chrome developer tools"><br>几个比较重要的tab页：</p>
<ul>
<li>Element标签用于显示当前元素，如想看到一个按钮的源码，对按钮右键审核元素即可看到。</li>
<li>Network标签用于显示数据包，对于协议的分析，我们最常用此标签。</li>
</ul>
<h2 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h2><h3 id="1-d-data-lt-data-gt"><a href="#1-d-data-lt-data-gt" class="headerlink" title="1. -d/--data &lt;data&gt;"></a>1. <code>-d/--data &lt;data&gt;</code></h3><p>指定HTTP请求时发送的数据（主要为POST请求），使用和用户通过浏览器提交表单时一样的方式。使用的content-type是<code>application/x-www-form-urlencoded</code>。<br>相当于<code>--data-ascii</code>。发送纯粹二进制的数据（data purely binary），需要使用<code>--data-binary</code>。URL-encode编码要发送的数据，需要使用<code>--data-urlencode</code>。<br>当有多个-d时，curl会自动将发送的数据段是用“&amp;”符号拼接，如：<code>-d name=Stackeye -d age=100</code>将自动拼接为name=Stackeye&amp;age=100作为post数据块（post chunk）发送。<br>如果想指定文件中的内容，可以使用-d @filename的形式。如文件foobar中内容为<code>name=Stackeye</code>，使用-d @foobar即可达到<code>-d name=Stackeye</code>一样的效果（只有第一个=作为特殊字符）。从文件读入时要注意=、@等特殊字符的异常情况。<br>而-d @-可以指定要发送的内容来自标准输入（stdin）。如执行<code>curl -d @- http://127.0.0.1/welcome.php</code>，在终端输入数据后回车、Ctrl+D后达到相同效果。<br>对于文件的使用，对于其他类似选项适用。<br>但<code>-d/--data</code>不会对数据进行url编码，而实际场景中我们最常用的还是发送url编码后的数据。</p>
<h3 id="2-data-urlencode-lt-data-gt"><a href="#2-data-urlencode-lt-data-gt" class="headerlink" title="2. --data-urlencode &lt;data&gt;"></a>2. <code>--data-urlencode &lt;data&gt;</code></h3><p>使用URL-encode编码要发送的数据。除此之外，其余同-d。<br>-d选项默认是不会对要发送数据进行编码的，在旧版本没有<code>--data-urlencode</code>选项的curl时，要发送编码的数据，必须手动对数据进行编码，或者将数据存放在编码的文件中。<br>比如要发送数据为”Stackeye blog”，必须手动把空格变为”%20”：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d name=Stackeye%20blog -d age=100 http://127.0.0.1/welcome.php</span><br></pre></td></tr></table></figure></p>
<p>而<code>--data-urlencode</code>自动完成此过程:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --data-urlencode name=Stackeye%20blog --data-urlencode age=100 \</span><br><span class="line">http://127.0.0.1/welcome.php</span><br></pre></td></tr></table></figure></p>
<p>wireshark抓包后显示如下：<br><img src="/img/curl_encode.jpg" alt="curl urlencode post数据抓包"><br>在我们的程序中，直接使用-d发送需urlencode编码的数据（一般为除字母数字外的其他字符，如空格，汉字等），程序也会正常处理，那我们为什么还需要使用-<code>-data-urlencode</code>呢？原因如下：</p>
<ul>
<li>能正常处理是apache服务器的原因。实际使用中服务器、程序语言不同，很可能出现无法处理不urlencode编码的数据，尤其是汉字和jsp程序，容易出现乱码</li>
<li>我们在使用浏览器操作时，浏览器会自动进行urlencode操作。为了尽可能逼真，我们使用<code>--data-urlencode</code>尽可能模仿浏览器的操作</li>
</ul>
<p><code>--data-urlencode</code>同样可以使用@指定从文件中输入。而且可以使用<code>name@filename</code>的形式。如使用<code>--data-urlencode name@foobar</code>，文件foobar中内容为Stackeye，即可达到<code>--data-urlencode name=Stackeye</code>的效果。这在-d选项中是不行的。需要注意的是此用法不会对name进行编码，所以需要预先编码好name字段。实际场景中一般name字段都是固定的，so it’s not too much trouble.</p>
<h3 id="3-data-binary-lt-data-gt"><a href="#3-data-binary-lt-data-gt" class="headerlink" title="3. --data-binary &lt;data&gt;"></a>3. <code>--data-binary &lt;data&gt;</code></h3><p>发送指定的不做任何处理的数据（This posts data exactly as specified with no extra processing whatsoever），其余同-d。</p>
<h3 id="4-G-get"><a href="#4-G-get" class="headerlink" title="4. -G/--get"></a>4. <code>-G/--get</code></h3><p>和-d/–data、–data-binary一块使用时，表示强制使用GET的方式提交表单。<br>和 -I/–head 一块使用时，表示把提交的数据加在url中，而不是加在数据头中。</p>
<h2 id="参数使用实例"><a href="#参数使用实例" class="headerlink" title="参数使用实例"></a>参数使用实例</h2><h3 id="1-POST"><a href="#1-POST" class="headerlink" title="1. POST"></a>1. POST</h3><p>分析post.php可知，此php脚本提交了两个字段：name和age。<br>打开Developer Tools，填写表单提交后，可看到Network标签下显示出HTTP的POST数据包：<br><img src="/img/developertools_post.jpg" alt="chrome developer tools post分析"><br>注意图中红圈处，可以在“view source”和”view parsed”直接切换，Request Header此时正以source模式显示，此模式下更利于我们的分析。<br>由此图可看到当前页面(post.php)向welcome.php提交了两个字段name和age，值分别为“Stackeye”和“100”，并可看到服务器的返回信息。</p>
<p>我们可使用curl命令的-d选项模拟此POST过程：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o welcome.html \</span><br><span class="line">-e http://127.0.0.1/post.php -d name=Stackeye -d age=100 http://127.0.0.1/welcome.php</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o welcome.html \</span><br><span class="line">-e http://127.0.0.1/post.php -d <span class="string">"name=Stackeye;age=100"</span> http://127.0.0.1/welcome.php</span><br></pre></td></tr></table></figure></p>
<p>因为POST提交表单的过程，一定会有显示表单的页面，因此一般都会有来源页面。因此使用-e指定了post页面为来源页面。<br>分析可得到curl命令需要使用的几乎所有信息。</p>
<p>注：“几乎所有”的原因是如有些字段是在别的网页传递而来，或者由当前页面的js脚本等生成，此时就需要进一步的分析网页源代码等内容。</p>
<h3 id="2-GET"><a href="#2-GET" class="headerlink" title="2. GET"></a>2. GET</h3><p>GET的提交我们直接使用网址后面加参数的形式，使用浏览器打开如下网址：<br><code>http://XXX.XXX.XXX.XXX/welcome.php?name=StackeyeGet&amp;age=101</code><br>同样使用Developer Tools抓包分析如下：<br><img src="/img/developertools_get.jpg" alt="Developer Tools GET分析"><br>由此图可看到GET向welcome.php提交了两个字段name和age，值分别为“StackeyeGet”和“101”。<br>我们可以使用curl的-G选项提交：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o welcome.html \</span><br><span class="line">-e http://127.0.0.1/post.php -G -d name=Stackeye -d age=100 http://127.0.0.1/welcome.php</span><br></pre></td></tr></table></figure></p>
<p>此时可看到welcome.html中有“This is a GET Request.”表明是由GET提交数据。</p>
<p>实际场景中，表单中指定使用GET提交数据的情况很少。因此-G较少使用。<br>但我们更常用的还是直接curl带参数的url，此时与手动操作更接近：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o welcome.html \</span><br><span class="line"><span class="string">"http://127.0.0.1/welcome.php?name=StackeyeGet&amp;age=101"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要为curl提交表单的相关命令参数。<br>实际应用中，我们可能还需要使用curl上传文件，相关命令请看下篇。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之三：curl基本使用</title>
    <url>/2012/08/linux-curl-basic-usage/</url>
    <content><![CDATA[<p>在介绍完<a href="http://stackeye.com/2012/07/linux-curl-description/" target="_blank" rel="noopener">cURL简介</a>和需要的<a href="http://stackeye.com/2012/07/linux-curl-http-protocol/" target="_blank" rel="noopener">HTTP协议概述</a>之后。终于可以回归正题，进入curl的使用方法。</p>
<h2 id="curl命令格式"><a href="#curl命令格式" class="headerlink" title="curl命令格式"></a>curl命令格式</h2><p>基本的使用用法如下：<br><code>curl [选项] [URL...]</code></p>
<h2 id="GET一个网页"><a href="#GET一个网页" class="headerlink" title="GET一个网页"></a>GET一个网页</h2><p><code>curl http://www.baidu.com</code><br>网页源码将被打印出来。</p>
<h3 id="o-output-lt-file-gt-指定保存目录"><a href="#o-output-lt-file-gt-指定保存目录" class="headerlink" title="-o/--output &lt;file&gt;指定保存目录"></a><code>-o/--output &lt;file&gt;</code>指定保存目录</h3><p>为便于后续处理，我们将网页内容保存在文件中：<br><code>curl -o stackeye.html http://www.stackeye.com</code><br>此时仍会显示进度条等信息。</p>
<h3 id="s-silent静默模式"><a href="#s-silent静默模式" class="headerlink" title="-s/--silent静默模式"></a><code>-s/--silent</code>静默模式</h3><p>通过脚本结合curl可以实现很复杂的功能，而在脚本中调用curl，我们不需要进度条等信息。如执行：<br><code>curl -s -o stackeye.html http://www.stackeye.com</code><br>将不会显示任何信息。<br><a id="more"></a></p>
<h2 id="v-–verbose查看通信过程、调试。"><a href="#v-–verbose查看通信过程、调试。" class="headerlink" title="-v/–verbose查看通信过程、调试。"></a>-v/–verbose查看通信过程、调试。</h2><p>这个参数可以清晰的查看到curl的通信过程，以便于调试，如执行：<br><code>curl -v http://www.baidu.com</code><br>返回结果如下，可以清晰的看到curl发出的HTTP请求及服务器返回的HTTP响应：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* About to connect() to www.baidu.com port 80 (#0)</span><br><span class="line">*   Trying 119.75.218.77... connected</span><br><span class="line">* Connected to www.baidu.com (119.75.218.77) port 80 (#0)</span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; User-Agent: curl/7.21.0 (i686-pc-linux-gnu) libcurl/7.21.0 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18</span><br><span class="line">&gt; Host: www.baidu.com</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Date: Wed, 01 Aug 2012 12:39:15 GMT</span><br><span class="line">&lt; Server: BWS/1.0</span><br><span class="line">&lt; Content-Length: 8216</span><br><span class="line">&lt; Content-Type: text/html;charset=gbk</span><br><span class="line">&lt; Cache-Control: private</span><br><span class="line">&lt; Expires: Wed, 01 Aug 2012 12:39:15 GMT</span><br><span class="line">&lt; Set-Cookie: BAIDUID=AF0E3C36DBB60C0D7C29DE11705028D7:FG=1; expires=Wed, 01-Aug-42 12:39:15 GMT; path=/; domain=.baidu.com</span><br><span class="line">&lt; P3P: CP=&quot; OTI DSP COR IVA OUR IND COM &quot;</span><br><span class="line">&lt; Connection: Keep-Alive</span><br><span class="line">&lt;</span><br><span class="line">&lt;!doctype html&gt;以下为HTML内容，略</span><br></pre></td></tr></table></figure></p>
<p>以下所有命令都可以通过加入-v选项，查看具体通信过程。<br>更详细的调试信息可以使用–trace-ascii选项，如：<br><code>curl --trace-ascii debug.txt http://www.baidu.com</code></p>
<h2 id="A-–user-agent指定User-Agent字段"><a href="#A-–user-agent指定User-Agent字段" class="headerlink" title="-A/–user-agent指定User-Agent字段"></a>-A/–user-agent指定User-Agent字段</h2><p>此选项字段用于指定HTTP请求头的User-Agent字段，即客户端（如浏览器）类型。<br>很多网站为了防止自动化程序采集，仅允许浏览器访问，最简单的办法就是通过User-Agent字段识别客户端类型做出处理。而如下命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span></span><br><span class="line"> http://www.stackeye.com</span><br></pre></td></tr></table></figure></p>
<p><code>&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)&quot;</code>为firefox的UserAgent值。<br>通过-A指定User-Agent字段，使curl伪装成Firefox，从而绕过网站的检测。<br>User-Agent字段可以通过抓包分析得到，或者通过chrome的Developer Tools、Firefox的Firebug等工具得到。<br>而如果一个网站对浏览器的限制也很严格的话，那我们甚至可以通过修改User-Agent伪装成百度蜘蛛或者googlebot突破限制，因为基于SEO的考虑，网站对搜索引擎蜘蛛的限制很小。</p>
<h2 id="e-–referer-设置Referer"><a href="#e-–referer-设置Referer" class="headerlink" title="-e/–referer 设置Referer"></a>-e/–referer <url>设置Referer</url></h2><p>此选项字段用于指定HTTP请求头中的Referer字段，即来源网页。<br>为了防盗链，很多网页尤其是图片等可下载资源会检测Referer字段，对于非自己站内的来源全部屏蔽掉，此时我们就需要这个参数。<br>通过执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span></span><br><span class="line"> -e http://www.baidu.com http://www.stackeye.com</span><br><span class="line">http://www.stackeye.com将检测到来源网站为http://www.baidu.com</span><br></pre></td></tr></table></figure></p>
<h2 id="cookie使用"><a href="#cookie使用" class="headerlink" title="cookie使用"></a>cookie使用</h2><p>cookie的介绍参考上一篇。<br>我们登录网站后，为保持登录状态，需要使用cookie信息。</p>
<h3 id="D-–dump-header-保存协议头部信息"><a href="#D-–dump-header-保存协议头部信息" class="headerlink" title="-D/–dump-header 保存协议头部信息"></a>-D/–dump-header 保存协议头部信息</h3><p><code>-D/--dump-header &lt;file&gt;</code>保存协议头部信息<br>头部信息中包含最常使用的cookie信息，如执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span></span><br><span class="line"> -e http://www.baidu.com -D stackeyecookie.txt http://www.stackeye.com</span><br></pre></td></tr></table></figure></p>
<p>会将头部信息保存至stackeyecookie.txt中。</p>
<h3 id="b-–cookie-指定cookie"><a href="#b-–cookie-指定cookie" class="headerlink" title="-b/–cookie 指定cookie"></a>-b/–cookie 指定cookie</h3><p><code>-b/--cookie &lt;name=data&gt;/&lt;file&gt;</code>指定cookie<br>-b后可直接加-D保存的文件，curl会自动从中读取出cookie值，而且-b选项不会修改此文件。如执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span></span><br><span class="line"> -e http://www.baidu.com -b stackeyecookie.txt http://www.stackeye.com</span><br></pre></td></tr></table></figure></p>
<p>会自动将stackeyecookie.txt中cookie信息附加至HTTP请求头中。</p>
<p>结合-D和-b参数，即可完成cookie的保存和后续使用。</p>
<p>cookie的形式就是“属性:值”对形式，-b后可直接以“属性=值”的形式给出cookie，当有多个属性时以分号间隔且包含在双引号中。如执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span></span><br><span class="line"> -b <span class="string">"user=Adeploy;pass=password"</span> http://www.stackeye.com</span><br></pre></td></tr></table></figure></p>
<p>会将cookie信息<code>user=Adeploy;pass=password</code>附加在HTTP请求头中。</p>
<h2 id="Redirects重定向"><a href="#Redirects重定向" class="headerlink" title="Redirects重定向"></a>Redirects重定向</h2><p>打开某些网页，网页会显示“ 3XX Moved Permanently ”，即网页被移动到其他位置，新位置一般由HTTP响应头中的Location字段给出。<br>重定向一般是因为网站结构调整后，避免用户访问原来页面出现404错误。<br>而另一类常见的用法就是在登陆成功后，网页显示成功信息，然后将用户重定向至内容页面。<br><code>-L/--location</code>选项可以自动跟踪重定向。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇只介绍简单的curl使用选项，下篇将结合实例具体说明。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之四：curl基本使用实例</title>
    <url>/2012/08/linux-curl-basic-usage-example/</url>
    <content><![CDATA[<p>本篇主要结合编写的PHP程序实例对上篇<a href="http://stackeye.com/2012/08/linux-curl-basic-usage/" target="_blank" rel="noopener">curl基本使用</a>进行具体说明。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h3><p>建议<code>Ubuntu+Apache+PHP</code>，方便简洁:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2 php5</span><br></pre></td></tr></table></figure></p>
<p>即可。</p>
<h3 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h3><p>以下为测试使用的服务器端代码，全部使用php实现。</p>
<ul>
<li>curldemo.php，用于输出User-Agent、Referer、Cookie信息：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">PHP Demo <span class="keyword">for</span> curl basic usage By Stackeye</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;strong&gt;User-Agent:&lt;/strong&gt;&lt;br&gt;"</span>.$_SERVER[<span class="string">'HTTP_USER_AGENT'</span>].<span class="string">"&lt;br&gt;\n"</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>($_SERVER[<span class="string">'HTTP_REFERER'</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;strong&gt;Referer:&lt;/strong&gt;&lt;br&gt;"</span>.$_SERVER[<span class="string">'HTTP_REFERER'</span>].<span class="string">"&lt;br&gt;\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>($_COOKIE[<span class="string">'user'</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;strong&gt;Cookie:&lt;/strong&gt;&lt;br&gt;user="</span>.$_COOKIE[<span class="string">'user'</span>].<span class="string">"&lt;br&gt;\n"</span>;</span><br><span class="line">        setcookie(<span class="string">"user"</span>,<span class="string">""</span>,time()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">&lt;a href=<span class="string">"http://www.stackeye.com"</span> target=<span class="string">"_blank"</span>&gt;Stackeye<span class="string">'s Blog&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>curlfollow.php，设置cookie后跳转至curldemo.php（使用js跳转，curl不会执行js函数，因此只有在浏览器中才会自动跳转）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    setcookie(<span class="string">"user"</span>,<span class="string">"Stackeye"</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;script&gt;window.location =\"curldemo.php\";&lt;/script&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>curl301.php，重定向至curldemo.php（header重定向后Referer字段为空，设置的cookie也不保存）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    Header( <span class="string">"HTTP/1.1 301 Moved Permanently"</span> ) ;</span><br><span class="line">    Header( <span class="string">"Location: curldemo.php"</span> );</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>curldeny.php，对User-Agent/Referer/cookie有严格要求，才会显示最终内容：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">CurlDeny-PHP Demo <span class="keyword">for</span> curl basic usage By Stackeye</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	I<span class="string">'ll deny all http requests,&lt;br&gt;</span></span><br><span class="line"><span class="string">	except your User-agent contains "Mozilla/4.0",&lt;br&gt;</span></span><br><span class="line"><span class="string">	your referer contains "www.baidu.com",&lt;br&gt;</span></span><br><span class="line"><span class="string">	and your cookie user is "Stackeye"!&lt;br&gt;</span></span><br><span class="line"><span class="string">	If you succeed,you will see "You finally get it"!&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;?php</span></span><br><span class="line"><span class="string">    if(strpos($_SERVER['</span>HTTP_USER_AGENT<span class="string">'],"Mozilla/4.0")!==false)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">    	echo "&lt;strong&gt;User-Agent:&lt;/strong&gt;&lt;br&gt;".$_SERVER['</span>HTTP_USER_AGENT<span class="string">']."&lt;br&gt;\n";</span></span><br><span class="line"><span class="string">    	if(isset($_SERVER['</span>HTTP_REFERER<span class="string">'])</span></span><br><span class="line"><span class="string">         &amp;&amp;strpos($_SERVER['</span>HTTP_REFERER<span class="string">'],"www.stackeye.com")!==false)</span></span><br><span class="line"><span class="string">    	&#123;</span></span><br><span class="line"><span class="string">    		echo "&lt;strong&gt;Referer:&lt;/strong&gt;&lt;br&gt;".$_SERVER['</span>HTTP_REFERER<span class="string">']."&lt;br&gt;\n";</span></span><br><span class="line"><span class="string">    		if(isset($_COOKIE['</span>user<span class="string">'])&amp;&amp;strcmp($_COOKIE['</span>user<span class="string">'],"Stackeye")==0)</span></span><br><span class="line"><span class="string">    		&#123;</span></span><br><span class="line"><span class="string">    	      echo "&lt;strong&gt;Cookie:&lt;/strong&gt;&lt;br&gt;user=".$_COOKIE['</span>user<span class="string">']."&lt;br&gt;\n";</span></span><br><span class="line"><span class="string">            setcookie("user","",time()-1);</span></span><br><span class="line"><span class="string">            echo "You finally get it!&lt;br&gt;\n";</span></span><br><span class="line"><span class="string">    		&#125;</span></span><br><span class="line"><span class="string">    		else</span></span><br><span class="line"><span class="string">    		    echo "\n&lt;br&gt;&lt;br&gt;I'</span>m sorry but you are so close!&lt;br&gt;\n<span class="string">";</span></span><br><span class="line"><span class="string">    	&#125;</span></span><br><span class="line"><span class="string">    	else</span></span><br><span class="line"><span class="string">    	    echo "</span>\n&lt;br&gt;&lt;br&gt;I<span class="string">'m sorry but you are so close!&lt;br&gt;\n";</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    else</span></span><br><span class="line"><span class="string">        echo "\n&lt;br&gt;&lt;br&gt;I'</span>m sorry but you are so close!&lt;br&gt;\n<span class="string">" ;</span></span><br><span class="line"><span class="string">?&gt;</span></span><br><span class="line"><span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;a href="</span>http:<span class="comment">//www.stackeye.com" target="_blank"&gt;Stackeye's Blog&lt;/a&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>setcookie.php，设置cookie的user字段，用以访问curldeny.php:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">SetCookie-PHP Demo <span class="keyword">for</span> curl basic usage By Stackeye</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	I just set the cookie,&lt;br&gt; </span><br><span class="line">	with which you can get the curldeny.php.&lt;br&gt;&lt;br&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    setcookie(<span class="string">"user"</span>,<span class="string">"Stackeye"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;a href=<span class="string">"http://www.stackeye.com"</span> target=<span class="string">"_blank"</span>&gt;Stackeye<span class="string">'s Blog&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上PHP文件放入服务器根目录下即可（Ubuntu+Apache下默认为<code>/var/www</code>）。以下默认服务器地址为本机127.0.0.1。</p>
<h2 id="curl访问任务"><a href="#curl访问任务" class="headerlink" title="curl访问任务"></a>curl访问任务</h2><p>使用curl命令完成如下任务。</p>
<h3 id="1-伪装成Firefox访问curldemo-php"><a href="#1-伪装成Firefox访问curldemo-php" class="headerlink" title="1. 伪装成Firefox访问curldemo.php"></a>1. 伪装成Firefox访问curldemo.php</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o curldemo.html http://127.0.0.1/curldemo.php</span><br></pre></td></tr></table></figure>
<p>保存的html文件可以用浏览器打开查看。</p>
<h3 id="2-伪装来源页面为www-stackeye-com访问curldemo-php"><a href="#2-伪装来源页面为www-stackeye-com访问curldemo-php" class="headerlink" title="2. 伪装来源页面为www.stackeye.com访问curldemo.php"></a>2. 伪装来源页面为<a href="http://www.stackeye.com访问curldemo.php" target="_blank" rel="noopener">www.stackeye.com访问curldemo.php</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -o curlex.html -e http://www.stackeye.com http://127.0.0.1/curldemo.php</span><br></pre></td></tr></table></figure>
<h3 id="3-伪装成Firefox访问curlfollow-php，并保存cookie文件"><a href="#3-伪装成Firefox访问curlfollow-php，并保存cookie文件" class="headerlink" title="3. 伪装成Firefox访问curlfollow.php，并保存cookie文件"></a>3. 伪装成Firefox访问curlfollow.php，并保存cookie文件</h3><p>然后使用保存的cookie文件，伪装成firefox，访问curldemo.php<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o curlfollow.html -D cookie001.txt http://127.0.0.1/curlfollow.php</span><br><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o curldemo.html -D cookie002.txt -b cookie001.txt http://127.0.0.1/curldemo.php</span><br></pre></td></tr></table></figure></p>
<p>curldemo.html将显示user的值为Stackeye。</p>
<h3 id="4-伪装成Firefox并直接使用cookie值访问curldemo-php"><a href="#4-伪装成Firefox并直接使用cookie值访问curldemo-php" class="headerlink" title="4. 伪装成Firefox并直接使用cookie值访问curldemo.php"></a>4. 伪装成Firefox并直接使用cookie值访问curldemo.php</h3><p>cookie中user值为Stackeye，pass值为password<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o curldemo.html -D cookie002.txt -b “user=Stackeye;pass=password” \</span><br><span class="line">http://127.0.0.1/curldemo.php</span><br></pre></td></tr></table></figure></p>
<p>curldemo.html将显示user的值为Stackeye，pass值为password。</p>
<h3 id="5-不自动跟踪重定向访问curl301-php"><a href="#5-不自动跟踪重定向访问curl301-php" class="headerlink" title="5. 不自动跟踪重定向访问curl301.php"></a>5. 不自动跟踪重定向访问curl301.php</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -v -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o curl301.html http://127.0.0.1/curl301.php</span><br></pre></td></tr></table></figure>
<p>因为此时curl301.html文件内容为空，我们只能通过-v查看具体内容。<br>可以看到curl只访问了curl301.php</p>
<h3 id="6-自动跟踪重定向访问curl301-php"><a href="#6-自动跟踪重定向访问curl301-php" class="headerlink" title="6. 自动跟踪重定向访问curl301.php"></a>6. 自动跟踪重定向访问curl301.php</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -L -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o curl301.html http://127.0.0.1/curl301.php</span><br></pre></td></tr></table></figure>
<p>此时打开curl301.html会看到curldemo.php的内容，说明curl自动根据重定向去访问了curldemo.php。</p>
<h3 id="7-访问setcookie-php和curldeny-php，使curldeny-php显示“You-finally-get-it-”"><a href="#7-访问setcookie-php和curldeny-php，使curldeny-php显示“You-finally-get-it-”" class="headerlink" title="7. 访问setcookie.php和curldeny.php，使curldeny.php显示“You finally get it!”"></a>7. 访问setcookie.php和curldeny.php，使curldeny.php显示“You finally get it!”</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o setcookie.html -D cookie001.txt http://127.0.0.1/setcookie.php</span><br><span class="line">curl -s -A <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-o curldeny.html -e http://www.adeploy.com -D cookie002.txt -b cookie001.txt \</span><br><span class="line">http://127.0.0.1/curldeny.php</span><br></pre></td></tr></table></figure>
<p>打开curldeny.html文件，可看到“You finally get it!”信息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要是针对curl基本用法的实例以加深理解和掌握。实际操作中，登陆、发帖等操作还会用到提交表单相关操作，下篇将进行讲解。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之七：curl基本使用实例之发布文章到百度空间</title>
    <url>/2012/08/linux-curl-example-post-to-baidu-hi/</url>
    <content><![CDATA[<p>前六篇之后，我们对curl的基本使用已经有了一定的了解。下面我们就在实际场景中使用我们的所学。<br>本篇实例目标为编写linux脚本,使用curl完成发布文章至百度空间。<br>下文将从百度空间登陆到发表文章，对每个过程的HTTP进行分析，并编写脚本实现。</p>
<h2 id="工欲善其事，必先利其器"><a href="#工欲善其事，必先利其器" class="headerlink" title="工欲善其事，必先利其器"></a>工欲善其事，必先利其器</h2><p>抓包分析我们使用chrome自带的Developer Tools。<br>实际分析过程中最好把Developer Tools的Network标签左下角的“Preserve Log upon Navigation”选中，如下图圈中处：<br><img src="/img/developertoolspreserve.jpg" alt="Chrome Developer Tools Preserve Log upon Navigation"><br>单击变为红色即可。<br>此选项的作用在于当当前页面跳转到其他网页时，保存原来的日志记录。<br>默认不保存，比如在登陆成功一个网站后，自动跳转到其他网页，这样登陆网站过程中的记录都不保存。我们就没有办法对登陆过程进行具体分析。</p>
<h2 id="POST登陆"><a href="#POST登陆" class="headerlink" title="POST登陆"></a>POST登陆</h2><h3 id="1-操作过程"><a href="#1-操作过程" class="headerlink" title="1. 操作过程"></a>1. 操作过程</h3><p>登陆我们采用网址<code>https://passport.baidu.com/?login</code>，而不使用网址<code>http://hi.baidu.com/index.htm</code>或<code>http://hi.baidu.com/go/login</code> 右侧的登陆框。<br>这是因为后者可能因为百度空间改版等原因改变，而前者是百度账号的登陆界面，变化的几率要小。而且后者界面很多图片等元素，不利于我们抓包分析。</p>
<h3 id="2-登陆过程分析"><a href="#2-登陆过程分析" class="headerlink" title="2. 登陆过程分析"></a>2. 登陆过程分析</h3><p>登陆成功后找到<code>/?login</code>的POST包，如下图：<br><img src="/img/DeveloperToolsBaiduLogin.jpg" alt="Developer Tools Baidu Login HTTP Analy"><br>主要显示了状态信息、请求头部（Request Headers）、POST数据（Form Data）和响应头部（Response Heades）。<br>Query String Parameters是对GET的参数的解析，即网址中的?login。一般网址中“?”后面的都应该是参数，具体请参考Linux下cURL使用教程之二：HTTP协议概述中“GET命令”一节。<br><a id="more"></a><br>请求头部如下（view source模式）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /?login HTTP/1.1 Host: passport.baidu.com Connection: keep-alive Content-Length: 215 Cache-Control: max-age=0 Origin: https://passport.baidu.com User-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.168 Safari/535.19 Content-Type: application/x-www-form-urlencoded Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Referer: https://passport.baidu.com/?login Accept-Encoding: gzip,deflate,sdch Accept-Language: zh-CN,zh;q=0.8 Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3 Cookie: BAIDU_WISE_UID=...无关cookie代码，很长，略去</span><br></pre></td></tr></table></figure></p>
<p>POST数据如下（view decoded模式，因为curl可以完成urlencode，我们发送明文即可）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tpl_ok:</span><br><span class="line">next_target:</span><br><span class="line">tpl:</span><br><span class="line">skip_ok:</span><br><span class="line">aid:</span><br><span class="line">need_pay:</span><br><span class="line">need_coin:</span><br><span class="line">pay_method:</span><br><span class="line">u: .%2F</span><br><span class="line">return_method: get</span><br><span class="line">more_param:</span><br><span class="line">return_type:</span><br><span class="line">psp_tt: 0</span><br><span class="line">password: youcan&apos;tsee</span><br><span class="line">safeflg: 0</span><br><span class="line">isphone: false</span><br><span class="line">username: Stackeye</span><br><span class="line">verifycode:</span><br><span class="line">mem_pass: on</span><br></pre></td></tr></table></figure></p>
<h3 id="3-登陆过程curl脚本"><a href="#3-登陆过程curl脚本" class="headerlink" title="3. 登陆过程curl脚本"></a>3. 登陆过程curl脚本</h3><p>百度要求的不严格，因此我们不考虑来源页面（Referer）等信息，只注意隐藏User-Agent字段。同时保存cookie供后续使用。脚本如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o baidu001.html -D bdcookie001.txt \</span><br><span class="line">--data-urlencode username=<span class="variable">$username</span> \</span><br><span class="line">--data-urlencode password=<span class="variable">$password</span> \</span><br><span class="line">--data-urlencode mem_pass=on \</span><br><span class="line">https://passport.baidu.com/?login</span><br></pre></td></tr></table></figure></p>
<p>实验发现其他字段非必要，因此舍弃。</p>
<h2 id="POST发表文章"><a href="#POST发表文章" class="headerlink" title="POST发表文章"></a>POST发表文章</h2><h3 id="1-操作过程-1"><a href="#1-操作过程-1" class="headerlink" title="1. 操作过程"></a>1. 操作过程</h3><p>点击“我的空间”，进入<a href="http://hi.baidu.com/home，然后点击“文字“，进入到`http://hi.baidu.com/pub/show/createtext`，随便写些内容，右侧加些标签，发表即可。" target="_blank" rel="noopener">http://hi.baidu.com/home，然后点击“文字“，进入到`http://hi.baidu.com/pub/show/createtext`，随便写些内容，右侧加些标签，发表即可。</a></p>
<h3 id="2-过程分析"><a href="#2-过程分析" class="headerlink" title="2. 过程分析"></a>2. 过程分析</h3><p>找到对createtext的POST包。POST的url为<code>http://hi.baidu.com/pub/submit/createtext</code>。<br>请求头中没有我们关心的字段：cookie不用具体分析，Referer等字段我们不去关注。</p>
<p>POST数据如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Stackeye&apos;s title</span><br><span class="line">tags[]: stackeyetag</span><br><span class="line">content: &lt;p&gt;Stackeye&amp;#39;s&amp;nbsp;content&lt;/p&gt;&lt;p&gt;This&amp;nbsp;is&amp;nbsp;for&amp;nbsp;curl&amp;nbsp;learning&amp;nbsp;test.&lt;/p&gt;</span><br><span class="line">private: 0</span><br><span class="line">imgnum: 0</span><br><span class="line">bdstoken: 01ae260f7a99a896a16dfa8d9f75cf16</span><br><span class="line">qbid:</span><br><span class="line">refer: http://hi.baidu.com/home</span><br><span class="line">multimedia[]: undefined#undefined#undefined#undefined</span><br><span class="line">private1: 0</span><br><span class="line">qing_request_source:</span><br></pre></td></tr></table></figure></p>
<p>title是文章标题，tags是标签，content是内容。<br>除此之外还有一个bdstoken字段猜不出其含义。多次测试发现，其他字段基本固定，而bdstoken字段在每次退出重新登陆后就会发生变化。<br>这种字段来源有三种可能性：</p>
<ul>
<li>此字段没有实际意义<br>比如只是个简单的标志，服务器端并不校验此字段值。</li>
<li>服务器生成，然后在POST之前传给客户端<br>需要我们分析POST之前数据包的响应数据。因为可能的数据包不多（一般来讲，图片、css、js等的包可以直接排除）。</li>
<li>POST之前的某个网页动态生成<br>比如此网页或之前的某个网页上的js、Ajax等在客户端执行的函数生成。<br>这个需要审视此网页和之前的每个网页中的js等代码，甚至需要动态调试，比较麻烦。因此我们最后考虑这种情况。</li>
</ul>
<h3 id="3-寻找bdstoken字段"><a href="#3-寻找bdstoken字段" class="headerlink" title="3. 寻找bdstoken字段"></a>3. 寻找bdstoken字段</h3><p>编写脚本，bdstoken传递格式类似的随机值，文章发表失败。<br>寻找之前的数据包，我们从后向前找，查找每个text/html等网页类型的数据包的Response内容。<br>Developer Tools的搜索功能搜索不到，可以右键数据包”save all as har“保存为har文件，用记事本打开即可查找。但是不能批量保存，比较繁琐。<br>更简单的解决方式是使用wireshark抓包，wireshark的字符串搜索可以搜索到。<br>我们很快找到在GET的createtext页面（<code>http://hi.baidu.com/pub/show/createtext</code>）里有bdstoken字段，GET及bdstoken取出语句：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#get bdstoken</span></span><br><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o baidu002.html \</span><br><span class="line">-D bdcookie002.txt -b bdcookie001.txt \</span><br><span class="line">http://hi.baidu.com/pub/show/createtext</span><br><span class="line">bdstoken=<span class="string">""</span></span><br><span class="line"><span class="comment">#`cat baidu002.html |grep bdstoken=|awk -F "bdstoken=" '&#123;print $2&#125;'|awk -F "\&amp;" '&#123;print $1&#125;'`</span></span><br><span class="line"><span class="built_in">echo</span> bdstoken=<span class="variable">$bdstoken</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#check before submit</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$bdstoken</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"error in getting bdstoken"</span>;</span><br><span class="line">    <span class="built_in">exit</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p>脚本中使用了awk用于从html代码中提取bdstoken字段，HTML中相关内容为：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://passport.baidu.com?logout&amp;bdstoken=393d8ef656bf74c8f739aa3ae5262f94&amp;u=http://hi.baidu.com/pub/show/createtext"</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>“bdstoken=”作为前分割标志，“&amp;”作为结束标志即可。</p>
<h3 id="4-curl脚本"><a href="#4-curl脚本" class="headerlink" title="4. curl脚本"></a>4. curl脚本</h3><ul>
<li><p>POST过程<br>使用的cookie是第一版步产生的bdcookie001<br>这是因为基本上只有第一步登陆的过程产生重要的cookie信息，其他步产生的cookie是非必须的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title=<span class="string">"Stackeye's title"</span></span><br><span class="line">content=<span class="string">"Stackeye's content!&lt;p&gt;This is for curl learning test."</span></span><br><span class="line">tags=<span class="string">"testtags"</span></span><br><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -e http://hi.baidu.com/pub/show/createtext \</span><br><span class="line">-o baidu003.html -D bdcookie003.txt -b bdcookie001.txt \</span><br><span class="line">--data-urlencode title=<span class="string">"<span class="variable">$title</span>"</span> \</span><br><span class="line">--data-urlencode tags[]=<span class="variable">$tags</span> \</span><br><span class="line">--data-urlencode content=<span class="string">"<span class="variable">$content</span>"</span> \</span><br><span class="line">--data-urlencode private=0 \</span><br><span class="line">--data-urlencode imgnum=0 \</span><br><span class="line">--data-urlencode bdstoken=<span class="variable">$bdstoken</span> \</span><br><span class="line">--data-urlencode qbid= \</span><br><span class="line">--data-urlencode refer=http://hi.baidu.com/home \</span><br><span class="line">--data-urlencode multimedia[]=:undefined<span class="comment">#undefined#undefined#undefined \</span></span><br><span class="line">--data-urlencode private1=0 \</span><br><span class="line">--data-urlencode qing_request_source= \</span><br><span class="line">http://hi.baidu.com/pub/submit/createtext</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证成功与否：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#result</span></span><br><span class="line">result=`cat baidu003.html |awk -F <span class="string">": \""</span> <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"\""</span> <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$result</span> -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Success!"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Fail!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>资源清理语句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -f baidu001.html baidu002.html baidu003.html</span><br><span class="line">rm -f bdcookie001.txt bdcookie002.txt bdcookie003.txt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="1-POST文章时，title、content中不能含有特殊字符"><a href="#1-POST文章时，title、content中不能含有特殊字符" class="headerlink" title="1. POST文章时，title、content中不能含有特殊字符"></a>1. POST文章时，title、content中不能含有特殊字符</h3><p>title、content中不能含有双引号不能转义的特殊字符，如$,\,<code>。
单引号不转义除单引号之外的所有特殊字符。而且在title=&quot;Stackeye&#39;s title&quot;和--data-urlencode title=&quot;$title&quot; \两处都使用单引号的会出现错误。
因此如果实际应用的话，还需要另外一个特殊字符替换函数，替换$,\,</code>和双引号。<br>shell脚本对大批量文字的处理比较繁琐吃力。<br>因此实际场景中，遇到对文字处理较多的场景，shell脚本+curl的方式只作为测试手段探究原理与逻辑，程序使用Java、PHP、Python、C等更强大的语言实现。</p>
<h3 id="2-没有错误重试"><a href="#2-没有错误重试" class="headerlink" title="2. 没有错误重试"></a>2. 没有错误重试</h3><p>可以使用如下循环进行错误重试：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#retry after fail</span></span><br><span class="line">COUNTER=0</span><br><span class="line"><span class="comment">#当失败时循环5次</span></span><br><span class="line"><span class="keyword">while</span> [ fail ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$COUNTER</span> -gt 5 ];<span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> error</span><br><span class="line">                <span class="built_in">exit</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        sleep 60</span><br><span class="line">        <span class="comment">#curl语句</span></span><br><span class="line">        COUNTER=`expr <span class="variable">$COUNTER</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-文件权限"><a href="#3-文件权限" class="headerlink" title="3. 文件权限"></a>3. 文件权限</h3><p>文件中保存有账户密码，记得设置文件属性为700，避免密码泄露。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>完整脚本如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"By Stackeye's blog"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"www.stackeye.com"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Change the file mod to 700 to keep your password safe!"</span></span><br><span class="line"></span><br><span class="line">username=<span class="string">""</span></span><br><span class="line">password=<span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#login</span></span><br><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o baidu001.html -D bdcookie001.txt \</span><br><span class="line">--data-urlencode username=<span class="variable">$username</span> \</span><br><span class="line">--data-urlencode password=<span class="variable">$password</span> \</span><br><span class="line">--data-urlencode mem_pass=on \</span><br><span class="line">https://passport.baidu.com/?login</span><br><span class="line"></span><br><span class="line"><span class="comment">#get bdstoken</span></span><br><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o baidu002.html \</span><br><span class="line">-D bdcookie002.txt -b bdcookie001.txt \</span><br><span class="line">http://hi.baidu.com/pub/show/createtext</span><br><span class="line">bdstoken=`cat baidu002.html |grep bdstoken=|awk -F <span class="string">"bdstoken="</span> <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"\&amp;"</span> <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"><span class="built_in">echo</span> bdstoken=<span class="variable">$bdstoken</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#submit the article</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$bdstoken</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"error in getting bdstoken"</span>;</span><br><span class="line">    <span class="built_in">exit</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">title=<span class="string">"Stackeye's title"</span></span><br><span class="line">content=<span class="string">"Stackeye's content!&lt;p&gt;This is line2!"</span></span><br><span class="line">tags=<span class="string">"testtags"</span></span><br><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -e http://hi.baidu.com/pub/show/createtext \</span><br><span class="line">-o baidu003.html -D bdcookie003.txt -b bdcookie001.txt \</span><br><span class="line">--data-urlencode title=<span class="string">"<span class="variable">$title</span>"</span> \</span><br><span class="line">--data-urlencode tags[]=<span class="variable">$tags</span> \</span><br><span class="line">--data-urlencode content=<span class="string">"<span class="variable">$content</span>"</span> \</span><br><span class="line">--data-urlencode private=0 \</span><br><span class="line">--data-urlencode imgnum=0 \</span><br><span class="line">--data-urlencode bdstoken=<span class="variable">$bdstoken</span> \</span><br><span class="line">--data-urlencode qbid= \</span><br><span class="line">--data-urlencode refer=http://hi.baidu.com/home \</span><br><span class="line">--data-urlencode multimedia[]=:undefined<span class="comment">#undefined#undefined#undefined \</span></span><br><span class="line">--data-urlencode private1=0 \</span><br><span class="line">--data-urlencode qing_request_source= \</span><br><span class="line">http://hi.baidu.com/pub/submit/createtext</span><br><span class="line"><span class="comment">#result</span></span><br><span class="line">result=`cat baidu003.html |awk -F <span class="string">": \""</span> <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"\""</span> <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$result</span> -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Success!"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Fail!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#delete temp files</span></span><br><span class="line">rm -f baidu001.html baidu002.html baidu003.html</span><br><span class="line">rm -f bdcookie001.txt bdcookie002.txt bdcookie003.txt</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之六：curl基本使用之HTTP文件上传</title>
    <url>/2012/08/linux-curl-basic-usage-upload-file/</url>
    <content><![CDATA[<p>有些时候，不只需要提交表单，还需要上传附件。本篇针对上传文件，对上篇<a href="http://stackeye.com/2012/08/linux-curl-basic-usage-forms/" target="_blank" rel="noopener">curl提交表单</a>进行补充。<br>注：本篇只针对HTTP上传文件部分。</p>
<h2 id="PHP程序"><a href="#PHP程序" class="headerlink" title="PHP程序"></a>PHP程序</h2><p>同前，所有服务端代码通过php实现。</p>
<ul>
<li>file.php，显示文件上传表单：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">PHP FileUpload Demo <span class="keyword">for</span> curl basic usage By Adeploy</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">This is a PHP File Upload Demo.&lt;br /&gt;</span><br><span class="line">Select a file <span class="keyword">and</span> Submit.&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;form action=<span class="string">"upload_file.php"</span> method=<span class="string">"post"</span></span><br><span class="line">enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">"file"</span>&gt;Filename:&lt;/label&gt;</span><br><span class="line">&lt;input type=<span class="string">"file"</span> name=<span class="string">"file"</span> id=<span class="string">"file"</span> /&gt; </span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;input type=<span class="string">"submit"</span> name=<span class="string">"submit"</span> value=<span class="string">"Submit"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;a href=<span class="string">"http://www.adeploy.com"</span> target=<span class="string">"_blank"</span>&gt;Adeploy<span class="string">'s Blog&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>upload_file.php，处理上传的文件。<br>上传文件后，文件先缓存在临时目录中，脚本结束时临时文件被删除。upload_file.php只是简单输出上传文件的信息，而不做实际场景中将临时文件保存至永久目录等进一步处理。但此差异对我们进行curl实验没有任何影响。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">PHP FileUpload Demo <span class="keyword">for</span> curl basic usage By Adeploy</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">This is a File Upload Process Demo.&lt;br /&gt;</span><br><span class="line">It only shows the information of the file you uploaded.&lt;br /&gt;</span><br><span class="line">The file you uploaded remains temporary,&lt;br /&gt;</span><br><span class="line"><span class="keyword">and</span> is deleted when this script is finished.&lt;br /&gt;&lt;br /&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> ($_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Error: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] . <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Upload: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>] . <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Type: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] . <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Size: "</span> . ($_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] / <span class="number">1024</span>) . <span class="string">" Kb&lt;br /&gt;"</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Stored in: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">&lt;a href=<span class="string">"http://www.adeploy.com"</span> target=<span class="string">"_blank"</span>&gt;Adeploy<span class="string">'s Blog&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>put.php，处理通过HTTP PUT方法上传的文件。<br>同上，为了安全只输出上传文件信息，不做实际转存处理。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">PHP Form Demo <span class="keyword">for</span> curl basic usage By Adeploy</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">This is a PHP PUT Demo.&lt;br&gt;</span><br><span class="line">It reads the file you upload using PUT,&lt;br&gt;</span><br><span class="line"><span class="keyword">and</span> prints the content out.&lt;br&gt;&lt;br&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* PUT data comes in on the stdin stream */</span></span><br><span class="line">$putdata = fopen(<span class="string">"php://input"</span>, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the data 1 KB at a time</span></span><br><span class="line"><span class="comment">   and print the content out */</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"The contents of the file you upload:&lt;br&gt;&lt;br&gt;\n"</span>;</span><br><span class="line"><span class="keyword">while</span> ($data = fread($putdata, <span class="number">1024</span>))</span><br><span class="line">    <span class="keyword">echo</span> $data;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="comment">/* Close the streams */</span></span><br><span class="line">fclose($putdata);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;a href=<span class="string">"http://www.adeploy.com"</span> target=<span class="string">"_blank"</span>&gt;Adeploy<span class="string">'s Blog&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h2><h3 id="F-–form"><a href="#F-–form" class="headerlink" title="-F/–form"></a>-F/–form</h3><p><code>-F/--form &lt;name=content&gt;</code><br>使用<code>Content-Type  multi‐part/form-data</code>的方式提交数据，可用于上传二进制文件。</p>
<ol>
<li><p>@的使用<br>一般使用<code>-F file=@filename</code>的形式，其中file为文件表单的name，filename为文件名。@后面的文件作为文件上传处理。</p>
</li>
<li><p>&lt;的使用<br>对于&lt;后的文件，curl会读取其内容，而不会作为文件上传。类似-d选项中@的作用。<br>如<br><code>curl -F name=&lt;foobar.txt -Fage=100 http://127.0.0.1/welcome.php</code><br>foobar.txt内容为Adeploy，则此命令与以下命令等价：<br><code>curl -F name=Adeploy -Fage=100 http://127.0.0.1/welcome.php</code><br>而-F @foobar.txt表示将foobar.txt作为文件上传。</p>
</li>
<li><p>-F不进行url编码<br>-F与-d类似，都是不对数据进行urlencode编码，而且-F不能与-d或–data-urlencode共用。<br>因此如果上传文件的同时还需要提交其他需要urlencode编码的字段（如中文用户名），就会出现问题。<br>除手动编码外，实用的解决办法是自己编写urlencode函数（网上可以找到Linux脚本实现的urlencode函数或C语言版本、Perl版本、Python），调用即可。</p>
</li>
<li><p>使用”type=”指定Content-Type<br>如<code>curl -F &quot;web=@index.html;type=text/html&quot; url.com</code><br>将index.html以text/html的Content-Type上传。</p>
</li>
<li><p>使用”filename=”修改上传文件的名字<br>如<code>curl -F &quot;file=@localfile;filename=nameinpost&quot; url.com</code><br>上传localfile并修改文件名字为nameinpost。</p>
</li>
</ol>
<h3 id="–form-string"><a href="#–form-string" class="headerlink" title="–form-string"></a>–form-string</h3><p><code>--form-string &lt;name=string&gt;</code><br>基本同-F，但是此参数后面跟”@”、”&lt;”、”;type=”时，不做特殊含义解析。</p>
<h3 id="T-–upload-file"><a href="#T-–upload-file" class="headerlink" title="-T/–upload-file"></a>-T/–upload-file</h3><p><code>-T/--upload-file &lt;file&gt;</code><br>使用HTTP的PUT方法上传文件，需要目标URL支持HTTP的PUT方法。<br>可以与-d、–data-urlencode、-F同时使用。</p>
<h2 id="参数使用实例"><a href="#参数使用实例" class="headerlink" title="参数使用实例"></a>参数使用实例</h2><h3 id="F文件上传"><a href="#F文件上传" class="headerlink" title="-F文件上传"></a>-F文件上传</h3><p>打开file.php选择文件后submit，Developer Tools抓包截图如下：<br><img src="/img/developertools_file.jpg" alt="Developer Tools file上传"><br>注意此时的Content-Type字段是<code>multipart/form-data</code>，主要用于上传文件，具体可参考<a href="http://www.ietf.org/rfc/rfc1867.txt" target="_blank" rel="noopener">RFC1867</a>。<br>分析file.php的源代码可知，表单中file类型的input元素name=file，所以命令如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -o file.html -F file=@a.txt http://127.0.0.1/upload_file.php</span><br></pre></td></tr></table></figure></p>
<h3 id="T文件上传"><a href="#T文件上传" class="headerlink" title="-T文件上传"></a>-T文件上传</h3><p>没有找到正确的PUT表单，因此无法使用Developer Tools跟踪实际提交过程。<br>命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -o put.html -T a.txt http://127.0.0.1/put.php</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要为使用curl上传文件的操作方法。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之二：HTTP协议概述</title>
    <url>/2012/07/linux-curl-http-protocol/</url>
    <content><![CDATA[<p>虽然cURL支持多种协议，但日常我们最常用的还是HTTP协议，下文中着重介绍HTTP的相关使用方法，因此我们要对HTTP协议有所了解。</p>
<blockquote>
<p>HTTP，超文本传送协议，通过因特网传送万维网文档的数据传送协议。</p>
</blockquote>
<p>我们访问一个网页的实际过程如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端C===HTTP请求===&gt;服务端S：GET index.html http/1.1</span><br><span class="line">客户端C&lt;==HTTP响应====服务端S：HTTP/1.1 200 OK HTML文件内容</span><br></pre></td></tr></table></figure></p>
<p>HTTP协议本身是个无状态协议，它不像其他基于会话的协议那样去不断追踪、记忆事务处理过程。而它要做的就只是简单的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">连接=&gt;发起HTTP请求(HTTP Request)=&gt;得到HTTP响应(HTTP Response)=&gt;断开连接</span><br></pre></td></tr></table></figure></p>
<p>而平常我们通过浏览器浏览网页这个过程，浏览器自动完成发送HTTP请求及对服务端应答的数据进行解析的工作，从而将网页呈现给我们。</p>
<p>我们使用cURL要做的就是模仿浏览器的动作，因此要对HTTP请求的格式进行进一步的解析。</p>
<h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p>在你向HTTP服务器请求一个资源（比如简单的使用浏览器打开一个网页），TCP三次握手建立连接后，HTTP请求发出。<br>HTTP请求信息由3部分组成：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l 请求行(Request Line)</span><br><span class="line">l 请求头(Request Header)</span><br><span class="line">l 请求正文(Message Body)</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="HTTP请求行"><a href="#HTTP请求行" class="headerlink" title="HTTP请求行"></a>HTTP请求行</h3><p>典型的HTTP请求行格式为：<br><code>HTTP命令 请求资源的URI HTTP版本号</code><br>HTTP请求行例子如下：<br><code>GET / HTTP/1.1\r\n</code></p>
<p>这个请求行的意思是：请求得到（GET）/路径下的默认主页文件，使用HTTP协议1.1版本。</p>
<p>根据HTTP标准，HTTP请求可以使用多种请求方法。例如：HTTP1.1支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE和TARCE。而服务器也可以自定义请求命令供客户端使用。具体请参考HTTP的RFC文档。而我们最常用的是GET和POST命令：</p>
<h4 id="GET命令"><a href="#GET命令" class="headerlink" title="GET命令"></a>GET命令</h4><p>GET主要用于取得URL指定的资源信息，也可用来提交表单。GET提交的信息实际上是附加在url之后作为URL的一部分。<br>当年盛行一时的SQL注入，最常见的检测手段就是在GET提交的链接后加单引号来检测是否存在注入漏洞。<br>如提交username和password两个字段，正常的GET网址如下：<br><code>http://www.xxx.com/login.php?username=user&amp;password=pass</code><br>网站后台就会在_GET数组中取得username和password的值，从而组建SQL语句：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> user_table <span class="keyword">where</span> username=<span class="keyword">user</span> <span class="keyword">and</span> <span class="keyword">password</span>=pass</span><br></pre></td></tr></table></figure></p>
<p>如果返回的count值大于0即为用户名密码正确。<br>而添加单引号后：<br><code>http://www.xxx.com/login.php?username=user&amp;password=pass&#39;</code><br>组建的SQL语句为<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> user_table <span class="keyword">where</span> username=<span class="keyword">user</span> <span class="keyword">and</span> <span class="keyword">password</span>=pass<span class="string">'</span></span><br></pre></td></tr></table></figure></p>
<p>这个SQL语句执行出错，网页显示错误信息，黑客从而得知网页有SQL注入漏洞。<br>因此使用GET提交表单是不安全的，只进行了简单的编码无法加密，可以很容易的从网址猜出各字段的意思。而且受限于URL长度限制，GET提交表单能携带的数据也有限。</p>
<h4 id="POST命令"><a href="#POST命令" class="headerlink" title="POST命令"></a>POST命令</h4><p>POST主要用于提交表单，尤其是提交大批量的表单数据。<br>POST方法克服了GET方法的一些缺点。通过POST方法提交表单数据时，数据不是作为URL请求的一部分而是作为标准数据传送给Web服务器，这就克服了GET方法中的信息无法加密和数据量太小的缺点。</p>
<p>HTTP请求的下一段数据为HTTP请求头。</p>
<h3 id="HTTP请求头"><a href="#HTTP请求头" class="headerlink" title="HTTP请求头"></a>HTTP请求头</h3><p>HTTP请求头中主要包含关于请求本身或者客户端的有用信息，比如浏览器的类型、浏览器语言、编码、压缩算法等信息。服务器上的动态脚本如PHP等可以利用请求头信息生成动态的网页内容。</p>
<p>典型的HTTP请求头例子如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.168 Safari/535.19 QIHU 360EE</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Referer: http://www.adeploy.com/</span><br><span class="line">Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3</span><br></pre></td></tr></table></figure></p>
<p><code>\r\n</code>表示换行。由此可以看到HTTP请求头是由几行“属性:值”对组成的，例如属性Accept的值为<code>*/*\r\n</code> ，表示客户端可以接受任意数据类型。<br>而我们最常用的是<code>User-Agent</code>字段和<code>Referer</code>字段，分别用于指定客户端类型和来源页面。<br>最末行额外多出的一对<code>\r\n</code>表示一个空白行，此空白行表示HTTP请求头结束，以下部分为请求正文。</p>
<h3 id="HTTP请求正文"><a href="#HTTP请求正文" class="headerlink" title="HTTP请求正文"></a>HTTP请求正文</h3><p>HTTP请求正文经常为空，除非需要向服务端提交信息，如在使用POST向网站提交表单的时候。<br>例如如下是一个完整的HTTP请求的例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.adeploy.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.168 Safari/535.19 QIHU 360EE</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Referer: http://www.adeploy.com/</span><br><span class="line">Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3</span><br></pre></td></tr></table></figure></p>
<h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>当收到HTTP请求之后，HTTP服务器会进行处理然后返回一个HTTP响应给客户端（典型的客户端为浏览器）。HTTP响应中包含几乎与HTTP请求同样类型的数据。<br>HTTP响应信息也由3部分组成：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l 响应行(Response Status Line)</span><br><span class="line">l 响应头(Response Header)</span><br><span class="line">l 响应正文(Message Body)</span><br></pre></td></tr></table></figure></p>
<p>响应行以服务端使用的HTTP协议版本号开始，后加响应状态码，表示请求结果状态，例如：<br><code>HTTP/1.1 200 OK</code><br>状态码200表示请求成功。</p>
<p>紧接着的是响应头。响应头与请求头十分相似，也是由几行“属性:值”对组成。其中包含关于服务器的有用信息、响应数据等。典型响应头如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Expires: Fri, 01 Jan 1990 00:00:00 GMT</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Date: Tue, 31 Jul 2012 07:20:31 GMT</span><br><span class="line">Server: Google Frontend</span><br><span class="line">Content-Length: 10387</span><br></pre></td></tr></table></figure></p>
<p>如果请求成功，响应正文中将包含请求的数据，如图片文件的二进制数据、HTML文件等。一旦响应正文传输完毕，服务端又没有使用HTTP 1.1/2版本的Keep-Alive请求，HTTP连接将会断开。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie是服务器为了辨别用户身份、进行session跟踪用户识别，而储存在客户端的数据。用以判断在HTTP传输中的状态，从而弥补HTTP协议无状态的缺陷。</p>
<p>比如我们登录一个网站后，关闭网页后重新打开网页，服务端就可以通过cookie信息判断我们曾经登录过，从而跳过重新登录的过程，让用户感觉到亲切、方便、人性化。</p>
<p>当客户端向服务端发起请求时，浏览器会自动将cookie信息添加在HTTP请求头中。例子如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cookie: __utmc=90639562; __utma=90639562.1273157993.1343361841.1343361841.1343718828.2; __utmb=90639562.1.10.1343718828; __utmz=90639562.1343361841.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none)</span><br></pre></td></tr></table></figure></p>
<p>在我们使用cURL时，每次访问网页都相当于浏览器打开关闭一次，因此cookie会起到很大的作用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇介绍后续会使用的HTTP协议知识，只做简要概括，具体请参考RFC文档。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>http协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之十四：libcurl编程</title>
    <url>/2012/09/linux-curl-libcurl/</url>
    <content><![CDATA[<p>在<a href="http://127.0.0.1:4000/2012/09/curl-vs-wget/" target="_blank" rel="noopener">Linux下cURL使用教程之十三：curl vs wget</a>中我们谈到，curl是基于libcurl库实现的。<br>而libcurl库是开源免费跨平台的，可用于多种语言。<br>有时候linux的功能不足以满足我们的要求，或者是需要在特殊环境下实现某些功能（比如在PHP服务器上完成抓取），这时候就需要用到libcurl编程。</p>
<p>官方提供了一些demo代码，大家下载查看。<br>本篇文章我们只谈谈各种语言下的使用，及一些参考。</p>
<h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><p>C/C++语言下使用libcurl有些繁琐，但功能很强大、稳定高效。而且尤其C下本身开源库相比其它语言较少，因此libcurl库使用较多。<br>参考：<br><a href="http://curl.haxx.se/libcurl/c/libcurl-tutorial.html" target="_blank" rel="noopener">http://curl.haxx.se/libcurl/c/libcurl-tutorial.html</a><br><a href="http://curl.haxx.se/libcurl/c/" target="_blank" rel="noopener">http://curl.haxx.se/libcurl/c/</a></p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p>PHP的libcurl库使用较多。<br><a id="more"></a><br>参考：<br><a href="http://cn2.php.net/curl" target="_blank" rel="noopener">http://cn2.php.net/curl</a><br><a href="http://curl.haxx.se/libcurl/php/" target="_blank" rel="noopener">http://curl.haxx.se/libcurl/php/</a></p>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>python中也有curl库：PycURL。<br>但更易用使用更普遍的还是<a href="https://pypi.python.org/pypi/requests" target="_blank" rel="noopener">requests</a>。</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>Java下的curl库一度被抛弃：<a href="https://curl.haxx.se/libcurl/java/" target="_blank" rel="noopener">accessing libcurl from Java</a>。<br>不知道目前github上的版本是否稳定。<br>更建议使用apache httpclient(貌似现在叫做httpcomponents)，参考：<a href="http://hc.apache.org/" target="_blank" rel="noopener">Apache HttpComponents</a>。</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>如果作为日常请求工作使用，如在测试接口时，更建议使用带有GUI界面的postman，功能很强大，而且自带分组、回归等CI功能。<br>参考：<a href="http://www.getpostman.com/" target="_blank" rel="noopener">Postman | Supercharge your API workflow</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果需要编写shell脚本进行功能更强大的CI测试，curl仍是首选。<br>此系列告一段落。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
        <tag>libcurl</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之一：cURL简介</title>
    <url>/2012/07/linux-curl-description/</url>
    <content><![CDATA[<p>随着网络应用的盛行，HTTP脚本编程成为一项流行的技术：<br>你可能需要到某个web页面自动的下载一些信息（采集）或请求某个接口；<br>可能还需要模仿成一个正常浏览器的样子，或者使用代理；<br>甚至需要上传或POST数据。</p>
<p>而cURL就是HTTP脚本编程的利器。</p>
<h2 id="什么是cURL"><a href="#什么是cURL" class="headerlink" title="什么是cURL"></a>什么是cURL</h2><p>cURL的官方网站上这样解释：“The name is a play on ‘Client for URLs’”。意思为“访问URL的客户端”。<br>“cURL is a command line tool for doing all sorts of URL manipulations and transfers”，cURL是用于进行各种对URL的操作和访问传输的命令行工具。<br>而在Linux man手册里这样解释：“cURL - transfer a URL”，意思是对URL的访问传输。<br>今天我们要讲的curl是Linux下一个强大的对URL进行操作的命令行工具。<br>而cURL的写法，URL突出大写，也正是强调对URL的操作。<br><a id="more"></a></p>
<h2 id="cURL主要特点"><a href="#cURL主要特点" class="headerlink" title="cURL主要特点"></a>cURL主要特点</h2><ol>
<li>支持多协议<br>URL的定义为“统一资源定位符”（详见RFC 3986），是不局限于HTTP协议的。<br>因此cURL支持多种协议，如DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS,IMAP, IMAPS,LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, TELNET and TFTP等。</li>
<li>命令行操作，简单强大<br>CURL是无GUI界面的，全部基于命令行操作，这无疑使它可以很方便的集成在像Linux脚本等程序中，<br>而通过我们进一步编程处理，就可以完成非常强大的功能。</li>
<li>开源跨平台<br>cURL工具是由<a href="http://curl.haxx.se/" target="_blank" rel="noopener">libcurl开源项目组</a>提供，此项目组提供开源的libcurl库，此库是由C语言实现客户端URL操作库，提供对URL的访问等操作功能，cURL工具就是采用libcurl实现。<br>而因为libcurl库是适用于多个平台的，因此cURL也适用于多个平台，如Win、Linux、OS/400、TPF等平台。<br>这成为cURL比GNU官方的wget更强大的原因之一。</li>
</ol>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之八：curl基本使用实例之115网盘自动摇一摇脚本</title>
    <url>/2012/08/linux-curl-example-115/</url>
    <content><![CDATA[<p>上一篇使用shell+curl的方式完成了登陆百度空间并发表文章。但是奈何shell脚本对大批量文字的处理太弱，因此脚本显得鸡肋。<br>而本篇则完成一个实际可用的脚本程序：115网盘自动摇一摇脚本。</p>
<h2 id="115网盘简介"><a href="#115网盘简介" class="headerlink" title="115网盘简介"></a>115网盘简介</h2><p>115网盘容量和速度都算不错的。注册送15G，然后可通过每天摇一摇等方式获得容量。<br>免费会员每天可以摇一次，可以获得几十M到一百多M的空间，和几百“雨露”。雨露可用于升级，升级后增加空间，但是貌似现在没有了。<br>可以在淘宝上搜一下115账号的价格。<br>（注：当初写这个脚本的时候，还在网盘大战前后，如今的115早已不如当前，摇一摇这个功能早已消失。）</p>
<h2 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h2><p>登陆过程我们仍然使用Developer Tools分析。<br>简单的办法是使用谷歌官方的chrome浏览器或Firefox+Firebug。</p>
<h2 id="登陆过程"><a href="#登陆过程" class="headerlink" title="登陆过程"></a>登陆过程</h2><p>登陆，使用Developer Tools抓包，很容易看到第一个POST包。</p>
<h3 id="1、POST地址"><a href="#1、POST地址" class="headerlink" title="1、POST地址"></a>1、POST地址</h3><p><code>https://passport.115.com/?ac=login</code></p>
<h3 id="2、三部分数据"><a href="#2、三部分数据" class="headerlink" title="2、三部分数据"></a>2、三部分数据</h3><ul>
<li>Request Headers，没特殊需要注意的字段。</li>
<li>Query String Parameters，没用。</li>
<li>Form Data，有两个数据：用户名、密码，字段名分别为login[account]、login[passwd]，参数明文。<a id="more"></a>
<h3 id="3、curl脚本"><a href="#3、curl脚本" class="headerlink" title="3、curl脚本"></a>3、curl脚本</h3>伪造User-Agent，伪装来源页面，登陆保存cookie：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#username/passwd are the parameters of this script</span></span><br><span class="line">username=<span class="variable">$1</span></span><br><span class="line">passwd=<span class="variable">$2</span></span><br><span class="line"><span class="comment">#save to log</span></span><br><span class="line">date&gt;&gt;yaoyao.log</span><br><span class="line"><span class="built_in">echo</span> Log <span class="variable">$1</span>&gt;&gt;yaoyao.log</span><br><span class="line"><span class="comment">#login post</span></span><br><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> -o 1151.html -D 115cookie001.txt http://www.115.com/</span><br><span class="line">curl -s -L -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line"> -e http://www.115.com/ -o 1152.html -D 115cookie002.txt -b 115cookie001.txt \</span><br><span class="line"> --data-urlencode back=http://www.115.com \</span><br><span class="line"> --data-urlencode goto=http://115.com \</span><br><span class="line"> --data-urlencode login[account]=<span class="variable">$username</span> \</span><br><span class="line"> --data-urlencode login[passwd]=<span class="variable">$passwd</span> \</span><br><span class="line"> <span class="string">'http://passport.115.com/?ac=login'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>为了更逼真，我们先访问了下首页，完整模仿实际用户行为。<br>登陆成功与否不在此处检测，原因见下节。</p>
<h2 id="摇一摇过程"><a href="#摇一摇过程" class="headerlink" title="摇一摇过程"></a>摇一摇过程</h2><h3 id="1、摇一摇抓包分析"><a href="#1、摇一摇抓包分析" class="headerlink" title="1、摇一摇抓包分析"></a>1、摇一摇抓包分析</h3><p>在“网盘”页面下，点击摇一摇，摇成功后抓包分析。<br>很快发现摇一摇的GET数据包。</p>
<h3 id="2、字段分析"><a href="#2、字段分析" class="headerlink" title="2、字段分析"></a>2、字段分析</h3><p>GET网址为：<code>http://115.com/?ct=ajax_user&amp;ac=pick_space&amp;token=dfcce64ebe71051a732d7943068ab***&amp;_=1345093324***</code><br>多次试验发现，URL中有两个变化的参数，token和<em>。没有其它特殊字段。<br>token和</em>字段，按上篇文章思路，我们先考虑这两个字段没有实际意义的情况。</p>
<h3 id="3、curl脚本-1"><a href="#3、curl脚本-1" class="headerlink" title="3、curl脚本"></a>3、curl脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -L -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-e http://www.115.com/ -o 1153.html -D 115cookie003.txt -b 115cookie002.txt \</span><br><span class="line">http://115.com/?ct=ajax_user\&amp;ac=pick_space\&amp;token=dfcce64ebe71051a756f7943068ab147\&amp;_=1331178826515</span><br></pre></td></tr></table></figure>
<p>成功后会有跳转，所有我们使用了-L选项自动跟踪跳转。<br>token和_字段处，填入格式相同的随机值，打开1153.html发现失败。</p>
<h3 id="4、寻找token字段"><a href="#4、寻找token字段" class="headerlink" title="4、寻找token字段"></a>4、寻找token字段</h3><p>同上篇相同思路，从后向前寻找。或者抓包，然后搜索token值。<br>1）最终发现在GET网页<code>http://115.com/?ct=file&amp;ac=userfile&amp;aid=1&amp;cid=0&amp;tpl=list_pg&amp;limit=35的Response</code>里有：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span> window["INDEX_HOME_DATA"] = &#123;take_token: '164d32f6fc1e668c0769eff1235e83ff',is_take: Number('1') &#125;;</span><br></pre></td></tr></table></figure></p>
<p>2）我们使用curl脚本：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-e http://115.com/ -o 1153.html -D 115cookie003.txt -b 115cookie002.txt \</span><br><span class="line"><span class="string">'http://115.com/?ct=file&amp;ac=userfile&amp;aid=1&amp;cid=0&amp;tpl=list_pg&amp;limit=35'</span></span><br></pre></td></tr></table></figure></p>
<p>cat 1153.html|grep token即可看到token字段。</p>
<p>3）增加curl语句GET此页面提取token即可。<br>与上文POST摇一摇的代码合并后脚本如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#get token</span></span><br><span class="line">curl -s -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-e http://115.com/ -o 1153.html -D 115cookie003.txt -b 115cookie002.txt \</span><br><span class="line"><span class="string">'http://115.com/?ct=file&amp;ac=userfile&amp;aid=1&amp;cid=0&amp;tpl=list_pg&amp;limit=35'</span></span><br><span class="line">token=`cat 1153.html | grep Yao|awk -F <span class="string">"'"</span> <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"'"</span> <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"token="</span><span class="variable">$token</span></span><br><span class="line"><span class="comment">#check before post</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$token</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"error in getting bdstoken"</span>&gt;&gt;yaoyao.log;</span><br><span class="line">    <span class="built_in">exit</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#yao post</span></span><br><span class="line">curl -s -L -A  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"</span> \</span><br><span class="line">-e http://www.115.com/ -o 1154.html -D 115cookie004.txt -b 115cookie002.txt \</span><br><span class="line">http://115.com/?ct=ajax_user\&amp;ac=pick_space\&amp;token=<span class="variable">$token</span>\&amp;_=1331178977515</span><br></pre></td></tr></table></figure></p>
<p>测试成功，证明_字段没有实际作用。估计是个时间戳之类的，服务器并不对其正确唯一与否做出很严格的校验。<br>我们只需要在获得token后检验token是否为空即可，不需要在登陆后检测登陆是否成功。因为即使登陆成功后获得token识别，脚本也会终止。</p>
<h2 id="后续处理"><a href="#后续处理" class="headerlink" title="后续处理"></a>后续处理</h2><h3 id="1、结果处理"><a href="#1、结果处理" class="headerlink" title="1、结果处理"></a>1、结果处理</h3><p>摇一摇POST页面<code>http://115.com/?ct=ajax_user&amp;ac=pick_space&amp;token=164d32f6fc1e668c0769eff1235e8***&amp;_=1345094656***</code>得到的结果中，有三个字段有意义：</p>
<ul>
<li>picked：摇一摇获得空间数</li>
<li>total_size：总空间数</li>
<li>exp：获得的雨露数</li>
</ul>
<p>提取脚本如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#get the result</span></span><br><span class="line">cat 1154.html |awk -F<span class="string">"picked\":\""</span> <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"\""</span> <span class="string">'&#123;print $1&#125;'</span>&gt;&gt;yaoyao.log</span><br><span class="line">cat 1154.html |awk -F<span class="string">"total_size\":\""</span> <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"\""</span> <span class="string">'&#123;print $1&#125;'</span>&gt;&gt;yaoyao.log</span><br><span class="line">cat 1154.html |awk -F<span class="string">"exp\":"</span> <span class="string">'&#123;print $2&#125;'</span>|awk -F <span class="string">"&#125;"</span> <span class="string">'&#123;print $1&#125;'</span>&gt;&gt;yaoyao.log</span><br></pre></td></tr></table></figure></p>
<p>结果保存在日志中。我们只需要查看日志即可判断成功与否。</p>
<h3 id="2、资源清理"><a href="#2、资源清理" class="headerlink" title="2、资源清理"></a>2、资源清理</h3><p>脚本如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -f 1151.html 1152.html 1153.html 1154.html</span><br><span class="line">rm -f 115cookie001.txt 115cookie002.txt 115cookie003.txt 115cookie004.txt</span><br></pre></td></tr></table></figure></p>
<p>除115cookie002.txt之外，其余的cookie其实不用保存。<br>稳妥的办法是在开头结尾都添加资源清理语句。</p>
<h3 id="3、容错处理"><a href="#3、容错处理" class="headerlink" title="3、容错处理"></a>3、容错处理</h3><p>脚本中没有做太完备的容错处理。<br>因为在网络好的情况下，一般只会一次成功，失败的概率很小。没必要添加逻辑复杂的容错处理。</p>
<h2 id="Linux设置自动执行"><a href="#Linux设置自动执行" class="headerlink" title="Linux设置自动执行"></a>Linux设置自动执行</h2><p>可设置crotab自动执行。<br>如<code>vim /etc/crontab</code>添加如下字段：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30 5    * * *   root   bash yaoyao.sh username password</span><br></pre></td></tr></table></figure></p>
<p>表示每天5:30以root用户自动执行”bash yaoyao.sh username password“。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>完整的脚本请下载yaoyao.sh<br>使用方法：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash yaoyao.sh username password</span><br></pre></td></tr></table></figure></p>
<p>使用bash执行的原因是，其他shell可能有不支持的shell语法。<br>日志保存在yaoyao.log中。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之十一：HTTPS及证书使用简介</title>
    <url>/2012/08/linux-curl-usage-https-cert/</url>
    <content><![CDATA[<p>某些HTTPS网站对证书的要求比较严格，使用curl直接访问时会出现如下错误：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl: (60) SSL certificate problem, verify that the CA cert is OK. Details:</span><br><span class="line">error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed</span><br><span class="line">More details here: http://curl.haxx.se/docs/sslcerts.html</span><br></pre></td></tr></table></figure></p>
<p>此时就需要使用证书。<br>因此本篇只对curl相关选项做出介绍，详细原理请参考HTTPS协议。</p>
<h2 id="使用到的选项"><a href="#使用到的选项" class="headerlink" title="使用到的选项"></a>使用到的选项</h2><h3 id="E-–cert-导入证书"><a href="#E-–cert-导入证书" class="headerlink" title="-E/–cert 导入证书"></a>-E/–cert 导入证书</h3><p><code>-E/--cert &lt;certificate[:password]&gt;</code>导入证书。curl默认使用PEM格式的证书。<br>一般我们从浏览器导出的cert都是X.509格式。可以使用openssl转化为PEM格式。<br><a id="more"></a></p>
<h3 id="–cert-type-指定证书类型"><a href="#–cert-type-指定证书类型" class="headerlink" title="–cert-type 指定证书类型"></a>–cert-type 指定证书类型</h3><p><code>--cert-type &lt;type&gt;</code>指定证书类型，可以为PEM、 DER 或 ENG类型。</p>
<h3 id="–cacert-指定CA证书"><a href="#–cacert-指定CA证书" class="headerlink" title="–cacert 指定CA证书"></a>–cacert 指定CA证书</h3><p><code>--cacert &lt;CA certificate&gt;</code><br>指定使用的CA证书。CA证书必须是PEM格式。<br>默认情况下，curl使用一个自带的CA文件。可以在<a href="http://curl.haxx.se/docs/caextract.html" target="_blank" rel="noopener">这里</a>下载curl提供的最新的CA证书。<br>curl通过读取环境变量CURL_CA_BUNDLE的值作为CA证书库（CA cert bundle）的路径。此选项优先级高于此环境变量被使用。</p>
<h3 id="–capath-指定CA路径"><a href="#–capath-指定CA路径" class="headerlink" title="–capath 指定CA路径"></a>–capath 指定CA路径</h3><p><code>--capath &lt;CA certificate directory&gt;</code><br>指定使用的CA证书路径目录。证书必须为PEM格式，且此目录已被curl自带的c_rehash工具处理过。<br>在需要指定多个CA证书的时候，使用–capath指定CA目录更高效。</p>
<h3 id="k-–insecure-跳过验证"><a href="#k-–insecure-跳过验证" class="headerlink" title="-k/–insecure 跳过验证"></a>-k/–insecure 跳过验证</h3><p><code>-k/--insecure</code><br>指定允许使用不安全的ssl连接传输。<br>所有的连接都是试图通过使用默认安装的CA证书库（CA certificate bundle）来验证是安全的。非安全的连接默认是不允许的。</p>
<h3 id="指定私钥"><a href="#指定私钥" class="headerlink" title="指定私钥"></a>指定私钥</h3><p><code>--key &lt;key&gt;</code><br>指定私钥文件名。</p>
<p><code>--key-type &lt;type&gt;</code><br>指定私钥文件类型，可以为DER、PEM 或 ENG。默认使用PEM。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://curl.haxx.se/docs/sslcerts.html" target="_blank" rel="noopener">Details on Server SSL Certificates</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，curl脚本HTTP相关部分告一段落。<br>后续会介绍些curl使用其他协议的例子，及在编程中使用libcurl库。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下cURL使用教程之十：HTTP文件下载</title>
    <url>/2012/08/linux-curl-usage-download-file/</url>
    <content><![CDATA[<p>其实每次我们使用curl去打开一个url都是执行一次下载操作，因此我们甚至可以认为curl是一个下载工具。<br>而且curl的某些选项及特性，使得curl能完成非常强大的下载功能。<br>基本命令及一些有用的参数如下。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>使用<code>curl [URL...]</code>下载URL，并输出在终端。<br>可指定多个URL。多个URL时，下载内容同时在终端显示。</p>
<h2 id="–progress-bar-进度条"><a href="#–progress-bar-进度条" class="headerlink" title="-#/–progress-bar 进度条"></a>-#/–progress-bar 进度条</h2><p>添加参数<code>-#/--progress-bar</code>查看下载进度条。</p>
<h2 id="o-–output-输出文件"><a href="#o-–output-输出文件" class="headerlink" title="-o/–output 输出文件"></a>-o/–output 输出文件</h2><p>使用参数<code>-o/--output &lt;file&gt;</code>下载并保存至文件file。<br>可同时下载多个URL，每个-o对应一个URL。<br>如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o a.html http://www.a.com http://www.b.com</span><br></pre></td></tr></table></figure></p>
<p>会下载<a href="http://www.a.com的内容在a.html中，并在终端输出www.b.com的内容。而" target="_blank" rel="noopener">www.a.com的内容在a.html中，并在终端输出www.b.com的内容。而</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o a.html http://www.a.com -o b.html http://www.b.com</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o a.html -o b.html http://www.a.com http://www.b.com</span><br></pre></td></tr></table></figure></p>
<p>会分别下载两个URL至两个文件中。<br><a id="more"></a></p>
<h2 id="O-–remote-name"><a href="#O-–remote-name" class="headerlink" title="-O/–remote-name"></a>-O/–remote-name</h2><p>下载并从url中提取文件名。<br>多个URL的情况同-o选项相同：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O -O http://www.xxx.com/a.html http://www.xxx.com/b.html</span><br><span class="line">curl -O http://www.xxx.com/a.html -O http://www.xxx.com/b.html</span><br></pre></td></tr></table></figure></p>
<p>都会将两个URL分别保存在a.html和b.html中。</p>
<h2 id="C-–continue-at-断点续传"><a href="#C-–continue-at-断点续传" class="headerlink" title="-C/–continue-at 断点续传"></a>-C/–continue-at 断点续传</h2><p>使用参数<code>-C/--continue-at &lt;offset&gt;</code>进行断点续传。offset参数指定跳过多少bytes。<br>“-C -”指定自动检测断点续传开始位置。<br>使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -<span class="comment"># -O http://dl_dir.qq.com/qqfile/qd/QQ2012Beta3_QQProtect2.8.exe</span></span><br></pre></td></tr></table></figure></p>
<p>下载QQ安装程序，在下载未完成时Ctrl+C结束下载，然后使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -<span class="comment"># -C - -O http://dl_dir.qq.com/qqfile/qd/QQ2012Beta3_QQProtect2.8.exe</span></span><br></pre></td></tr></table></figure></p>
<p>进行断点续传。可看到第二次下载时并不是重新下载，而是从上次结束的地方下载。</p>
<h2 id="r-–range-分块下载"><a href="#r-–range-分块下载" class="headerlink" title="-r/–range 分块下载"></a>-r/–range 分块下载</h2><p>使用<code>-r/--range &lt;range&gt;</code>分块下载，指定每块下载的字节范围。如上例中下载qq，分块下载如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -r 0-10240 -o qq.exe.part1 http://dl_dir.qq.com/qqfile/qd/QQ2012Beta3_QQProtect2.8.exe</span><br></pre></td></tr></table></figure></p>
<p>下载前10240bytes。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -r 10241-20480 -o qq.exe.part2 http://dl_dir.qq.com/qqfile/qd/QQ2012Beta3_QQProtect2.8.exe</span><br></pre></td></tr></table></figure></p>
<p>下载10241-20480bytes。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -r 20481- -o qq.exe.part3 http://dl_dir.qq.com/qqfile/qd/QQ2012Beta3_QQProtect2.8.exe</span><br></pre></td></tr></table></figure></p>
<p>下载20481bytes及之后的字节。<br>下载完后可使用<code>cat qq.exe.part&gt;qq.exe</code>的形式得到完整文件（win下需要使用copy /b）。<br>此选项适用于HTTP/FTP/SFTP及本地文件。</p>
<h2 id="–limit-rate-限速下载"><a href="#–limit-rate-限速下载" class="headerlink" title="–limit-rate 限速下载"></a>–limit-rate 限速下载</h2><p>使用参数<code>--limit-rate &lt;speed&gt;</code>限速下载。默认单位为bytes/s，’k’或’K’指定使用单位KB/s，可以使用’m’或’M’指定使用单位MB/s，’g’或’G’指定使用单位GB/s。如<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -<span class="comment"># -O --limit-rate 100K http://dl_dir.qq.com/qqfile/qd/QQ2012Beta3_QQProtect2.8.exe</span></span><br></pre></td></tr></table></figure></p>
<p>指定限速为100KB/s。<br>限速是限制平均速度，某时刻的突发速度可能超过限制速度，但平均速度会低于限制速度。<br>如果同时使用了-Y/–speed-limit限制了最低下载速度，-Y/–speed-limit选择优先级更高。因此如果-Y/–speed-limit指定的值高于限制的速度，那么限制的速度回被突破，以保证最低下载速度有效（因为如果低于-Y/–speed-limit指定的最低下载速度，下载会被取消）。</p>
<h2 id="y-Y-限制速度"><a href="#y-Y-限制速度" class="headerlink" title="-y/-Y 限制速度"></a>-y/-Y 限制速度</h2><p>使用参数<code>-y/--speed-time &lt;time&gt;</code>或<code>-Y/--speed-limit &lt;speed&gt;</code>限制速度。<br>网速太慢时取消下载。</p>
<ul>
<li>-Y指定最低速度。使用-y指定超时时间而未指定最低速度时，最低速度默认为1.</li>
<li>-y指定超时时间，即低于最低速度多次时间时取消下载。使用-Y指定最低速度而未指定超时时间时，超时时间默认为30。</li>
</ul>
<h2 id="z-–time-cond-更新下载"><a href="#z-–time-cond-更新下载" class="headerlink" title="-z/–time-cond 更新下载"></a>-z/–time-cond 更新下载</h2><p>使用参数<code>-z/--time-cond &lt;date expression&gt;</code>设置只在更新时下载。具体的时间格式请参考<code>man 3 curl_getdate</code>（这个只有在安装了libcurl开发库之后才有），或者<a href="http://curl.haxx.se/libcurl/c/curl_getdate.html" target="_blank" rel="noopener">curl_getdate在线文档</a>。<br>如果时间格式解析失败，curl将会把此字段理解为文件名，从文件中读取时间。<br>需要网页中有相关字段表明最后更新日期。<br>如curl_getdate在线文档网页内有字段:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page updated June 20, 2012.</span><br></pre></td></tr></table></figure></p>
<p>表明网页最后更新日期是2012-06-20，因此执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -z 20-jun-12 http://curl.haxx.se/libcurl/c/curl_getdate.html</span><br></pre></td></tr></table></figure></p>
<p>curl_getdate.html在2012-06-20以后被更新，会被下载。而在日期前加上”-“，则表示相反意思，如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -z -20-jun-12 http://curl.haxx.se/libcurl/c/curl_getdate.html</span><br></pre></td></tr></table></figure></p>
<p>只有 curl_getdate.html 在2012-06-20之前被更新才会下载。因此此命令不会下载curl_getdate.html。</p>
<h2 id="文件批量下载"><a href="#文件批量下载" class="headerlink" title="文件批量下载"></a>文件批量下载</h2><p>通过使用正则表达式，可以对有一定规律的文件批量下载。如我们在PHP服务器的/var/www下新建a、b两个目录，新建如下文件：<br><code>a/1.php a/2.php...a/7.php,b/1.php b/2.php...b/5.php</code><br>PHP文件内容相同，都为输出绝对路径，用以标志文件的不同：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">__FILE__</span> ;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可以使用命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O http://127.0.0.1/&#123;a,b&#125;/[1-7].php</span><br></pre></td></tr></table></figure></p>
<p>批量下载文件。<br>a/1.php-a/7.php会保存在当前目录下的1.php-7.php中。b/1.php-b/5.php如果也保存在当前目录下的1.php-5.php的话，会覆盖以前的文件。因此curl会把b/1.php-b/5.php的内容在终端输出而不会保存文件。而执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="string">"http://10.1.1.103/&#123;a,b&#125;/[1-7].php"</span> -o <span class="string">"#1_#2.php"</span></span><br></pre></td></tr></table></figure></p>
<p>则会使用“目录<em>文件”的形式命名文件，避免文件名冲突。<br>{}、[]类似于正则表达式中的语法，用以取得多个文件。#加数字的形式用以取得正则表达式的当前值。<br>如#1表示第一个正则表达式的当前值，上例中即为{a,b}的值。<br>当下载<code>http://10.1.1.103/a/1.php</code>时，#1为“a”，#2为“1”，#1</em>#2.php即为“a_1.php”。从而完成批量文件的自动命名。</p>
<p>注：注意此时网址包含在双引号中，这是因为如果不被包含在引号中，{}中的内容无法使用#1的形式引用，会出现如下错误<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal error: invalid pattern type (0)</span><br><span class="line">Warning: bad output glob!</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实日常使用，我们更多使用wget下载文件。相比wget，curl功能更具体一些。<br>关于二者的区别，请参考后续文章。</p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>解密Redis持久化</title>
    <url>/2017/04/redis-persistence-demystified/</url>
    <content><![CDATA[<p>本文主要是对<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html" target="_blank" rel="noopener">antirez博客</a>的翻译。其实<a href="http://blog.nosqlfan.com/html/3813.html" target="_blank" rel="noopener"></a>nosqlfan已经有一篇译文，但不知道为什么省略了很多重要的细节，因此完整翻译了本篇。</p>
<p>首先antirez感觉到，他看到的所有针对Redis的文章和讨论中，对Redis持久化的误解是最大的。因此在这篇文章中，他将尝试真正的公正一些：不做Redis的广告，不尝试跳过任何细节以避免使Redis模糊不清。作者想做的仅是提供一个清晰易懂的描绘，介绍Redis持久化的工作原理，Redis的持久化如何可靠，以及与其它数据库的对比。</p>
<h2 id="操作系统和磁盘"><a href="#操作系统和磁盘" class="headerlink" title="操作系统和磁盘"></a>操作系统和磁盘</h2><h3 id="写操作的流程"><a href="#写操作的流程" class="headerlink" title="写操作的流程"></a>写操作的流程</h3><p>我们应该考虑的第一件事是对于数据库的持久化，我们的期望是什么。因此我们将一个简单的写操作中发生的事情可视化：</p>
<ol>
<li>客户端发送写命令到数据库（数据库在客户端内存中）</li>
<li>数据库接收到写操作（数据在服务器内存中）</li>
<li>数据库调用系统调用，将数据写入磁盘（数据在内核缓冲区中）</li>
<li>操作系统将写缓冲区的数据转移到磁盘控制器上（数据在磁盘缓存中）</li>
<li>磁盘控制器真正将数据写入到物理介质（数据真正落在磁盘上）<a id="more"></a>
<blockquote>
<p>注意：以上是一个各方面简单化的版本，因为实际有更多的cache和buffer。<br>步骤2经常被实现为数据库内部的一个复杂缓存系统。写操作也经常被不同的线程或进程处理。然而数据库或早或晚要将数据写入磁盘，而这就是我们关心的。也就是说，内存中的数据在某个节点必须要被传输到内核（步骤3）。<br>另外一个大的细节省略在步骤3.现实要更复杂，因为大多数高级操作系统内核实现了不同级别的缓存，其中通常包含文件系统级别的chache和一个略小一些的buffer cache。</p>
</blockquote>
</li>
</ol>
<h3 id="故障分析"><a href="#故障分析" class="headerlink" title="故障分析"></a>故障分析</h3><p>在这个流程中什么时候我们的写操作才是安全的呢？</p>
<p>如果我们考虑一个仅涉及数据库软件的失效（例如进程被管理员杀掉或崩溃），而不涉及操作系统内核，那成功执行完成步骤3的写操作就被认为是安全的。也就是在write这个系统调用（或其它用于将数据转移到内核的系统调用）返回成功后。在此步骤之后，即使数据库进程崩溃，内核仍然会负责将数据转移到磁盘控制器。</p>
<p>如果我们考虑一个更灾难性的事件，如电力中断，只有在步骤5执行完成后我们才是安全的。也就是在数据真正被转移到物理设备中时。</p>
<p>我们可以总结为，数据安全的重要阶段位于步骤3、4、5：</p>
<h3 id="POSIX-API"><a href="#POSIX-API" class="headerlink" title="POSIX API"></a>POSIX API</h3><h3 id="我们无法控制的部分"><a href="#我们无法控制的部分" class="headerlink" title="我们无法控制的部分"></a>我们无法控制的部分</h3><h3 id="数据损坏"><a href="#数据损坏" class="headerlink" title="数据损坏"></a>数据损坏</h3><h2 id="Redis持久化实现"><a href="#Redis持久化实现" class="headerlink" title="Redis持久化实现"></a>Redis持久化实现</h2><h3 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h3><h3 id="AOF文件"><a href="#AOF文件" class="headerlink" title="AOF文件"></a>AOF文件</h3><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>appendfsync no<br>appendfsync everysec<br>appendfsync always<br>为什么pipeline不同<br>AOF和Redis事务</p>
<h3 id="与PostgreSQL和MySQL的对比"><a href="#与PostgreSQL和MySQL的对比" class="headerlink" title="与PostgreSQL和MySQL的对比"></a>与PostgreSQL和MySQL的对比</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h2><h2 id="附录：关于重启阶段的笔记"><a href="#附录：关于重启阶段的笔记" class="headerlink" title="附录：关于重启阶段的笔记"></a>附录：关于重启阶段的笔记</h2>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>nosql</tag>
        <tag>aof</tag>
        <tag>rdb</tag>
      </tags>
  </entry>
  <entry>
    <title>Kolla：Openstack容器化部署简介</title>
    <url>/2016/03/openstack-kolla-intro/</url>
    <content><![CDATA[<p><a href="https://github.com/openstack/kolla" target="_blank" rel="noopener">Kolla</a>是Openstack的容器化部署项目。</p>
<p>本文主要对Kolla项目进行简单介绍，对其诞生的意义、内部的大概实现做出介绍，以便于读者快速理解项目以投入使用、快速进行自定义开发。</p>
<p>以下主要针对Kolla的Mitaka版本。开始写这篇文章时，Mitaka还尚未发布，因此使用的其实是master版本。</p>
<h2 id="为什么要做容器化部署"><a href="#为什么要做容器化部署" class="headerlink" title="为什么要做容器化部署"></a>为什么要做容器化部署</h2><h3 id="Openstack之美"><a href="#Openstack之美" class="headerlink" title="Openstack之美"></a>Openstack之美</h3><p>参考下图，OpenStack的架构设计是很漂亮的：清晰定义的服务，完美的原子操作，独立运行的可能，组件尽量无状态易于扩展。这是一个几乎做到极致的分布式架构。<br><img src="/img/the-beauty-of-openstack.png" alt="the beauty of openstack"></p>
<h3 id="Openstack之殇"><a href="#Openstack之殇" class="headerlink" title="Openstack之殇"></a>Openstack之殇</h3><p>但是现实是残酷的：</p>
<ul>
<li>服务之间往往有严重的依赖，使得部署复杂，修改麻烦，服务的管理困难；</li>
<li>配置复杂，有时候可能仅仅是一个微小的配置错误，就会导致整个集群功能异常；</li>
<li>而且随着OpenStack的发展，架构及配置只会越来越复杂。</li>
</ul>
<p>运维成本很高，效率低，严重影响了使用体验。<br><a id="more"></a><br><img src="/img/the-reality-of-openstack.png" alt="The Reality of OpenStack"><br>生产环境一旦部署完成很难去做大的升级。所以虽然每半年社区更新一个版本（目前马上M版本），但是真正生产环境可能还是I甚至E版本。对于每个组件，只做微小bug的升级，而且升级流程会非常谨慎。对于私有云产品也许还可以，但对于有大量用户严格SLA的公有云产品这是无法容忍的。这也是为什么说Openstack厂商离AWS、阿里云甚至UCloud这些大的公有云厂商还有很大的距离。<br>举个例子，如果我们要升级keystone这个基础组件——它是Openstack的认证组件，负载整个Openstack集群的鉴权，因此非常重要。<br>我们首先需要去判断这个版本的keystone和环境中使用的其它组件的当前版本是否完全兼容。而事实证明官方文档介绍很少，也是靠不住的，社区等着你发现bug做贡献呢；开发人员做出的估计有些也是不靠谱的，可以自行统计下每个组件的代码量；甚至简单的测试都不足够可靠，用例库也是逐渐总结出来的。这也说明了引入灰度上线和回滚机制是很有必要的。但是以现有的运维工具，回滚比较困难而且代价很大。因此一般在升级前都要做严格的升级测试，会有资源和人力的成本。</p>
<h3 id="容器的崛起"><a href="#容器的崛起" class="headerlink" title="容器的崛起"></a>容器的崛起</h3><p>虽然使用已有的一些OpenStack自动化部署工具，如puppet、fuel等，但往往只能部分解决这些问题，如不支持回滚、太重而导致资源浪费、体积太大速度缓慢等。<br>而docker在解决所有这些问题上具有很大的优势：</p>
<ul>
<li>服务直接的相互隔离</li>
<li>轻量级，节省资源，体积小便捷易携带迁移</li>
<li>容易描述的运行时关系</li>
<li>容易升级回滚，可灰度上线，对服务完整的生命周期管理</li>
<li>不只局限于OpenStack，对其它服务如HA等也适用</li>
<li>而通过与Kubernetes、服务发现等容器技术栈的高级工具组合，能提供更强大的解决方案</li>
</ul>
<p>当然还有容器的火爆发展，OpenStack社区怎么可能错过。</p>
<p><strong>下图对以上所有做了个很好的总结：</strong><br><img src="/img/docker-background.png" alt="Kolla Backgroud"></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>Kolla中使用到的技术栈总结如下。</p>
<ul>
<li>Docker，容器化基础工具</li>
<li>Ansible，配置管理，主要用于生成配置文件</li>
<li>Jinja，模板工具</li>
<li>Kubernetes/Mesos，Openstack社区或者说很多开源社区的特点就是：大而全的策略，可以预言：容器领域内所有火的组件慢慢都会在Kolla中出现，而且它们确实能组合出强大的功能。</li>
</ul>
<h3 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h3><p>Docker是通过Linux内核如LXC、namespace等实现的容器化技术。关于Docker的详细请参考docker系列文章或官方文档。<br><img src="/img/docker-internal.png" alt="docker内部组件"><br>通过Docker镜像，可以方便的对image进行版本管理。而且因为image的分层特性，体积较小，容易携带和分享。Docker的这些特性使得它非常适合于CI（持续集成/持续）/CD（持续部署/交付）系统，替换原来较重效率低得物理机或虚拟机方案。<br><img src="/img/docker-stages.png" alt="docker"><br>在Kolla中，用到了超权限容器（super privileged containers），因为部分组件直接访问宿主机的资源而不是使用自己的命名空间，如libvirt需要访问宿主机的网络空间来创建虚拟机。但是除非必要，对容器需要严格的权限控制以保证安全。<a href="http://developers.redhat.com/blog/2014/11/06/introducing-a-super-privileged-container-concept/" target="_blank" rel="noopener">参考</a></p>
<h3 id="Ansible简介"><a href="#Ansible简介" class="headerlink" title="Ansible简介"></a>Ansible简介</h3><h4 id="Ansible-组成"><a href="#Ansible-组成" class="headerlink" title="Ansible 组成"></a>Ansible 组成</h4><p>Ansible主要由以下部分组成：</p>
<ul>
<li>Inventory: 资产配置库,定义可管控的主机列表</li>
<li>Modules: core modules（自带模块）、custom modules(自定义模块)</li>
<li>Playbooks: 按照所设定编排的顺序执行完成安排任务</li>
</ul>
<p><img src="/img/ansible-arch.png" alt="ansible架构"></p>
<h4 id="Inventory"><a href="#Inventory" class="headerlink" title="Inventory"></a>Inventory</h4><p>资产配置文件,用来定义你要管理的主机,文件采用 INI 格式。 </p>
<ul>
<li>被管理的机器可以通过其IP或域名指定</li>
<li>未分组的机器需保留在hosts的顶部</li>
<li>分组可以使用<code>[]</code>指定</li>
<li>分组也能嵌套</li>
<li>也可以通过数字和字母模式来指定一系列连续主机，支持从一些外围组件获取动态的Inventory,如Ansible Tower。</li>
</ul>
<h4 id="Playbook"><a href="#Playbook" class="headerlink" title="Playbook"></a>Playbook</h4><p>Playbook为YMAL格式，语法简单：</p>
<ul>
<li>在ansible中几乎所有的yaml文件都是以list开始,每个item是键值对的list。</li>
<li>所有的yaml文件都以<code>---</code>开头表示开始一个document,所有的列表元素以-开头,键值对用冒号,冒号后面的空格是必须的</li>
<li>键值对中的值如果是bool类型的字符串<code>true/false</code>(首字母不论大小写),会load成python中对应的bool值</li>
<li>在键值对中如果值中有冒号或者以两个大括号开头的变量定义,则必须用引号引起来</li>
</ul>
<p>Playbook由若干Play组成,每一个Play是对一个或一组主机进行一系列动作,Play从上到下依次执行,从而完成部署、配置和编排。每个Play大致结构如下:</p>
<ul>
<li>Host and Users – 指定操作的主机及使用的用户</li>
<li>Tasks – 每个Task有Name用于在执行时显示,及具体的Action调用module执行实际任务。</li>
<li>Handlers – 何时触发或notify触发别的动作,从而建立依赖关系一个Playbook文件可以通过include引入其他的yml文件,实现复用。</li>
</ul>
<h4 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h4><p>Ansible自1.2版本引入的新特性,用于层次性、结构化地组织Playbook。<br>Roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。而要使用Roles只需要在Playbook中使用roles指令即可。<br>简单来讲,Roles就是通过分别将变量、文件、任务、模块及处理器放置于单独的目录中,并可以便捷地引用它们的一种机制。</p>
<h4 id="Best-Practise"><a href="#Best-Practise" class="headerlink" title="Best Practise"></a>Best Practise</h4><p>一个标准的目录结构如下图。<br><img src="/img/ansible-best-practise.png" alt="Ansible标准目录结构"></p>
<h2 id="Kolla"><a href="#Kolla" class="headerlink" title="Kolla"></a>Kolla</h2><p>基于上面的因素，结合容器技术近几年的快速发展，Openstack社区诞生了Kolla项目。<br>Kolla的使命如下：</p>
<blockquote>
<p>Kolla provides <strong>production-ready</strong> containers and deployment tools for operating OpenStack clouds.</p>
</blockquote>
<p>Kolla通过提供容器和Ansible的playbook来完成使命。Kolla被尽力设计为开箱即用，但又支持深度的自定义。这使得具有很少OpenStack经验的人员也可以轻易的部署并使用OpenStack，并随着经验的增长进行个性化定义以满足更高的需求。<br>Kolla不只简化了部署，也简化了操作。</p>
<h3 id="Kolla安装"><a href="#Kolla安装" class="headerlink" title="Kolla安装"></a>Kolla安装</h3><p>建议使用Mitaka之后的版本，因为M版本相对之前版本变动较大，之前基本相当于演示版本。<br>因项目变化很快，不做详述，请参考官方文档：<a href="http://docs.openstack.org/developer/kolla/quickstart.html" target="_blank" rel="noopener">kolla quickstart</a></p>
<h3 id="Kolla架构"><a href="#Kolla架构" class="headerlink" title="Kolla架构"></a>Kolla架构</h3><p><img src="/img/kolla-arch.png" alt="Kolla architecture"></p>
<p>其中绿色的组件是kolla提供的，蓝色组件由其它开源软件提供。<br>基本工作流如下：</p>
<ol>
<li>开发人员提交代码到gerrit，被review通过后merge至git</li>
<li>CD系统build出软件包（如RPM、DEB等）</li>
<li>CD系统使用软件包生成docker镜像</li>
<li>CD提交镜像到私有docker registry</li>
<li>CD系统触发节点上的镜像升级</li>
<li>Ansible下载最新镜像并更新容器，完成升级</li>
</ol>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>比较重要的目录如下。</p>
<ul>
<li>ansible – ansible相关文件,包括资产配置文件、变量文件、扩展库、Roles、Playbooks</li>
<li>docker – docker 相关文件,主要包括 Dockerfile 和其它需要在 build 镜像时添加的文<br>件</li>
<li>etc – kolla 自己的配置文件</li>
<li>kolla – kolla 封装的工具,如 build.py 用于 build 镜像等</li>
<li>tools – 其它一些工具,部分已迁移至 kolla 目录,目前主要是一些开发测试用工具</li>
</ul>
<p>以下详细介绍。</p>
<h3 id="ansible"><a href="#ansible" class="headerlink" title="ansible"></a>ansible</h3><p>此目录下是一个标准的 ansible 项目,主要包含如下目录及文件。</p>
<ul>
<li>action_plugins – action 扩展插件</li>
<li>group_vars – 全局变量</li>
<li>inventory – 资产配置文件,主要包含 all-in-one 和 multinode 两个,实际环境中使用时需要保证主机名的正确对应。</li>
<li>library – 扩展 ansible module</li>
<li>roles – 每个模块对应的 role</li>
<li>*.yml - 若干 Playbook,其中针对 zeus,编写了单独的 Playbook,执行需要通过-p 指</li>
</ul>
<p>我们需要在 roles 目录下添加对应的 role,使用了官方推荐的目录结构,其中一个 role 的结构如 下:</p>
<ul>
<li>defaults – 变量默认值</li>
<li>meta – 依赖</li>
<li>tasks–task列表,入口在main.yml,目前支持的action包括deploy、pull、upgrade、reconfigure,每个 action 对应一个 task 文件。</li>
<li>templates – 使用到的配置文件模板,及生成 config.json 需要的模板文件。</li>
</ul>
<p>需要注意一个叫做 common 的 role,其它的 role 大多依赖它,其中包含的内容有:</p>
<ul>
<li>kolla-toolbox – 其中装有所有 client,主要用来注册 endpoint 和操作数据库</li>
<li>heka – 用来收集日志,Docker 镜像 build 时需要去 s3 下载 rpm 包,已被墙</li>
<li>cron – 用来执行定时任务<br>设置配置项 common_run: True,可以指定不执行 common 相关的任务,但没找到有选项去具体控制使用哪个组件。<br>kolla-toolbox是我们必须的。所以只能使用代码注释的办法,注释掉 heka 和 cron 相关代码。</li>
</ul>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>此目录下主要为各模块对应的Dockerfile模板及其它build镜像时需要的文件。<br>Dockerfile模板使用的是Jinja2 模板,其中包含变量,用于根据参数判断,在部署时由ansible 根据参数及配置动态生成。<br>基础镜像在 base 目录下,其中主要是基本配置及安装基本软件包。其余镜像基本集成自base。<br>如果具体组件依赖不同,可自定义base镜像使用。<br>Docker镜像中用到两个比较重要的脚本:start.sh(base)和 extend_start.sh(具体镜像),其作用及实现原理见第 5 节。</p>
<h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><p>使用 kolla 时,我们一般不直接使用 docker 及 ansible,而是使用封装后的命令:</p>
<ul>
<li>kolla/cmd/build.py – 用于 build 镜像,对 <code>docker build</code> 进行了封装</li>
<li>tools/kolla-ansible – 对 ansible 的封装</li>
</ul>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>推荐使用的依赖版本,其它版本可能会有各种问题。 </p>
<ul>
<li>操作系统 – 推荐宿主机器使用centos7。centos6下经过一番折腾也能安装成功，但是各种问题真心不建议使用，或者升级内核。如果有需要可以在容器内运行centos6。</li>
<li>Docker版本 – 推荐从docker官网安装新版本。 </li>
<li>Ansible – 1.9.4</li>
<li>Docker Python – 1.6.0</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="添加配置项"><a href="#添加配置项" class="headerlink" title="添加配置项"></a>添加配置项</h3><ul>
<li><code>roles/templates/*.j2</code> – 一般是在配置文件中使用,配置文件一般为Jinja模板,使用类似Django模板的语法</li>
<li><code>roles/defaults/main.yml</code> – 配置默认值</li>
<li><code>group_vars/all.yml</code> – 全局默认值</li>
<li><code>globals.yml</code>或<code>passwords.yml</code>中。</li>
</ul>
<p>另外,在config.yml的对应任务中也可以看到,在实际生成配置文件时,还用到了其它一些文件,<br>如Nova下:</p>
<ul>
<li><code>/etc/kolla/config/global.conf</code></li>
<li><code>/etc/kolla/config/database.conf</code></li>
<li><code>/etc/kolla/config/messaging.conf</code></li>
<li><code>/etc/kolla/config/nova.conf</code></li>
<li><code>/etc/kolla/config/nova/.conf</code></li>
</ul>
<p>也可以在这些文件中添加配置,而覆盖ansible生成的配置,或添加缺少的配置。</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>以cinder-api为例：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &#123;&#123; namespace &#125;&#125;/&#123;&#123; image_prefix &#125;&#125;cinder-base:&#123;&#123; tag &#125;&#125;</span><br><span class="line"><span class="keyword">MAINTAINER</span> &#123;&#123; <span class="keyword">maintainer</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if install_type == <span class="string">'binary'</span> %&#125;</span><br><span class="line">    &#123;% if base_distro in [<span class="string">'centos'</span>, <span class="string">'fedora'</span>, <span class="string">'oraclelinux'</span>, <span class="string">'rhel'</span>] %&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install -y python-keystone \</span></span><br><span class="line"><span class="bash">  &amp;&amp; yum clean all</span></span><br><span class="line"></span><br><span class="line">    &#123;% elif base_distro in [<span class="string">'ubuntu'</span>] %&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y --no-install-recommends \</span></span><br><span class="line"><span class="bash">        cinder-api \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get clean</span></span><br><span class="line"></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> extend_start.sh /usr/<span class="built_in">local</span>/bin/kolla_cinder_extend_start</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod 755 /usr/<span class="built_in">local</span>/bin/kolla_cinder_extend_start</span></span><br><span class="line"></span><br><span class="line">&#123;&#123; include_footer &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> cinder</span><br></pre></td></tr></table></figure></p>
<p>其中除了设置相关信息外，还做了这些事：</p>
<ol>
<li>继承cinder-base<br>cinder-base位于kolla/docker/cinder/cinder-base目录下。<br>cinder-base继承自openstack-base，openstack-base继承自base。<br>base中主要安装基础包（如python）、设置源、执行set_configs.py（验证并通过config.json生成配置文件）、执行start.sh。<br>openstack-base中主要做大多数服务通用的动作，如安装openstack的基础依赖包等。<br>cinder-base中主要做cinder服务通用的动作，如安装cinder-common、设置sudoer文件等。<br>同时我们看到对docker的tag的支持。</li>
<li>安装软件包<br>通过识别操作系统类型，安装对应的包。<br>如果研究下cinder-base的内容，可看到对源码安装的支持。</li>
<li>执行需要的命令<br>base中设置了通过CMD执行start.sh。cinder-base中通过CMD执行extend_start.sh。<br>其中服务的启动主要在start.sh中，而需要的其它工作如db_sync主要在extend_start中执行。</li>
</ol>
<h3 id="Playbook-Role"><a href="#Playbook-Role" class="headerlink" title="Playbook/Role"></a>Playbook/Role</h3><p>TODO</p>
<h2 id="配置及部署"><a href="#配置及部署" class="headerlink" title="配置及部署"></a>配置及部署</h2><p>在部署时，我们主要配置哪些文件呢？</p>
<ul>
<li>globals.yml<br>其中配置必须的变量,但一般不包含密码。</li>
<li>passwords.yml<br>其中配置需要的密码。</li>
<li><p>资产配置文件<br>ansible/inventory目录下，使用主机名指定，在实际使用时需要保证主机名的对应。也可根据实际需要进行主机、分组等的调整。另一个可能使用到的是禁用某个组件，如禁用ceilometer-compute: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># disable by default</span><br><span class="line">[ceilometer-compute:children]</span><br><span class="line">#ceilometer</span><br></pre></td></tr></table></figure>
</li>
<li><p>kolla-build.conf<br>指定 build 使用的源,可以使用 rpm 包或 repo 文件。<br>如不知道会使用 delorean 源,其内容为社区最近 build 出的 master 分支的 RPM 包: Delorean is a tool to build rpm packages on each commit of a set of git repositories. 建议根据需要指定使用rdo的源。<br>在 build 时通过–config-file=参数指定使用的 kolla-build.conf。</p>
</li>
</ul>
<h2 id="项目现状"><a href="#项目现状" class="headerlink" title="项目现状"></a>项目现状</h2><p>TODO</p>
<h2 id="参考索引"><a href="#参考索引" class="headerlink" title="参考索引"></a>参考索引</h2><ul>
<li><a href="https://github.com/openstack/kolla" target="_blank" rel="noopener">Kolla项目github地址</a></li>
<li><a href="http://docs.openstack.org/developer/kolla/index.html" target="_blank" rel="noopener">Openstack Kolla Docs</a></li>
<li><a href="http://www.slideshare.net/daneyonhansen/openstack-kolla-introduction" target="_blank" rel="noopener">Kolla Introduction PPT</a></li>
<li><a href="https://www.ansible.com/blog/openstack-kolla" target="_blank" rel="noopener">Openstack Kolla: Dependency Management Done Right With Docker And Ansible</a></li>
<li><a href="https://allthingsopen.com/2014/10/22/a-demonstration-of-kolla-docker-and-kubernetes-based-deployment-of-openstack-services-on-atomic/" target="_blank" rel="noopener">A Demonstration of Kolla: Docker and Kubernetes based Deployment</a></li>
<li><a href="http://www.chenshake.com/openstack-project-series-2-kolla/" target="_blank" rel="noopener">陈沙克日志对Kolla介绍</a></li>
</ul>
]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>openstack</tag>
        <tag>kolla</tag>
        <tag>docker</tag>
        <tag>容器化</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLAlchemy简介及在OpenStack中的使用</title>
    <url>/2015/07/sqlalchemy-intro/</url>
    <content><![CDATA[<p>SQLAlchemy是Python编程语言下的一款开源软件，提供了SQL工具包及对象关系映射(ORM)工具。</p>
<h2 id="web编程之orm"><a href="#web编程之orm" class="headerlink" title="web编程之orm"></a>web编程之orm</h2><p>在编写web服务时，我们通常使用orm，而不是直接使用SQL与数据库进行交互。<br>如果使用Django等比较全面的框架，可以选择默认的ORM。但如果选择flask等轻量级框架，则需要自己选择ORM。同时，自己选择使用ORM也带来了更大的灵活性。<br><a id="more"></a></p>
<h3 id="orm是什么"><a href="#orm是什么" class="headerlink" title="orm是什么"></a>orm是什么</h3><p>以下节选自wikipeida：</p>
<blockquote>
<p>Object-relational mapping (ORM, O/RM, and O/R mapping tool) in computer science is a programming technique for converting data between incompatible type systems in object-oriented programming languages.</p>
</blockquote>
<p>以下节选自百度百科：</p>
<blockquote>
<p>对象关系映射（英语：Object Relation Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。</p>
</blockquote>
<p>实际项目中，我们主要使用orm作为与数据库等进行实际交互的工具。</p>
<h3 id="为什么使用orm"><a href="#为什么使用orm" class="headerlink" title="为什么使用orm"></a>为什么使用orm</h3><p>与直接使用sql访问数据库相比，其有以下好处：</p>
<ul>
<li>代码的简洁性，对存储层的通用封装<br>使用orm，操作数据库往往仅需要简单的几条语句，使代码变得简洁。</li>
<li>数据源的兼容性<br>orm往往对多种数据库、数据源进行通用的封装，从而使得编写一套代码，适用于不同的数据源变得可能。</li>
<li>操作的安全性<br>直接使用sql操作数据库，往往会因为开发人员疏忽引入sql注入等安全问题。而使用orm，能避免此问题。</li>
<li>操作语句的高效性<br>orm的封装是众多开发人员智慧的结晶，其中往往已经对生成的sql语句进行了优化，使得一般语句的性能比较高效，而开发人员不需要再去考虑性能问题。但orm一般是通用的解决方案，无法针对所有场景进行优化，特殊场景下其生成的sql语句可能会非常低效，因此需要在实际使用时进行监控并酌情优化。</li>
</ul>
<h2 id="简介及特性"><a href="#简介及特性" class="headerlink" title="简介及特性"></a>简介及特性</h2><p>SQLAlchemy的特性主要如下：</p>
<ul>
<li>Mature, High Performing Architecture DBA Approved</li>
<li>Non-Opinionated</li>
<li>Unit Of Work</li>
<li>Function-based query construction Modular and Extensible</li>
<li>Separate mapping and class design …</li>
</ul>
<p>See: <a href="http://www.sqlalchemy.org/features.html" target="_blank" rel="noopener">http://www.sqlalchemy.org/features.html</a></p>
<h2 id="安装及使用"><a href="#安装及使用" class="headerlink" title="安装及使用"></a>安装及使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>开发环境推荐使用pip安装，同时注意版本问题。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install sqlalchemy</span><br></pre></td></tr></table></figure></p>
<p>生产环境推荐使用rpm/deb安装，同时注意版本问题。<br>rpm - 版本兼容问题<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install SQLAlchemy</span><br><span class="line">apt-get install SQLAlchemy</span><br></pre></td></tr></table></figure></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>支持的2种方式:</p>
<ul>
<li>SQL Expression Language (core)</li>
<li>Object Relational Mapper (orm)</li>
</ul>
<h2 id="Core方式"><a href="#Core方式" class="headerlink" title="Core方式"></a>Core方式</h2><p>(raw sql、sql expression)<br>对于绝大多数应用, 推荐使用SqlAlchemy. 即使是使用raw sql,<br>SqlAlchemy 也可以带来如下好处:</p>
<ul>
<li>内建数据库连接池</li>
<li>强大的log功能</li>
</ul>
<p>SqlAlchemy的sql expression和raw sql的比较:</p>
<ul>
<li>sql expression 写法是纯python代码, 阅读性更好</li>
<li>raw sql 比 sql expression 更灵活, 如果SQL很复杂, 更有优势了</li>
</ul>
<h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">engine_str = <span class="string">"mysql:mysql://root:root@localhost/django_sqla"</span></span><br><span class="line">engine = create_engine(engine_str, echo=<span class="literal">True</span>)</span><br><span class="line">conn = engine.connect()</span><br></pre></td></tr></table></figure>
<h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Table objects <span class="keyword">and</span> its children <span class="keyword">as</span> metadata Table Column(String, Integer…)</span><br><span class="line">Create tables within the engine</span><br></pre></td></tr></table></figure>
<h3 id="Insert-expression"><a href="#Insert-expression" class="headerlink" title="Insert expression"></a>Insert expression</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ins2=users.insert() <span class="comment">#anexpression</span></span><br><span class="line">result2 = conn.execute(ins2, id=<span class="number">2</span>, name=’wendy’, fullname=’Wendy Williams’) <span class="comment"># execute</span></span><br><span class="line">Multiple inserts: conn.execute(ins2, a_list)</span><br></pre></td></tr></table></figure>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">users.update().values(&#123;…&#125;).where(…)</span><br></pre></td></tr></table></figure>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>同上</p>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = select([users]) <span class="keyword">or</span> s = users.select()</span><br><span class="line">result = conn.execute(s)</span><br><span class="line">result.fetchone()</span><br><span class="line">result.close()</span><br></pre></td></tr></table></figure>
<h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sqlalchemy allows using string</span><br><span class="line">s = text(“””Hello”””)</span><br></pre></td></tr></table></figure>
<h2 id="orm方式"><a href="#orm方式" class="headerlink" title="orm方式"></a>orm方式</h2><h3 id="Declare-a-Mapping"><a href="#Declare-a-Mapping" class="headerlink" title="Declare a Mapping"></a>Declare a Mapping</h3><p>declarative_base: define classes and mapping to tables<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Base = declarative_base()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = ‘users’</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<h3 id="MetaData"><a href="#MetaData" class="headerlink" title="MetaData"></a>MetaData</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Base.metadata.create_all(engine)</span><br></pre></td></tr></table></figure>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>事务<br>using session to handle orm’s action<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Session = sessionmaker(bind=engine)</span><br><span class="line">session = Session()</span><br></pre></td></tr></table></figure></p>
<h3 id="Connection-pool"><a href="#Connection-pool" class="headerlink" title="Connection pool"></a>Connection pool</h3><h3 id="Add-insert"><a href="#Add-insert" class="headerlink" title="Add(insert)"></a>Add(insert)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ed_user = User(<span class="string">'ed'</span>, <span class="string">'Ed Jones'</span>, <span class="string">'edspassword'</span>)</span><br><span class="line">session.add(ed_user)</span><br><span class="line">session.add_all([...])</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>
<h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = session.query(User).filter(User.name==‘ed<span class="string">')</span></span><br><span class="line"><span class="string">result[0].name, result[0][0]</span></span><br></pre></td></tr></table></figure>
<h3 id="Relationship"><a href="#Relationship" class="headerlink" title="Relationship"></a>Relationship</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span><span class="params">(Base)</span></span></span><br><span class="line">__tablename__ = ‘addresses’</span><br><span class="line">...</span><br><span class="line">user_id = Column(Integer, ForeignKey(<span class="string">'users.id'</span>)) user = relationship(<span class="string">"User"</span>,</span><br><span class="line">backref=backref(<span class="string">'addresses'</span>, order_by=id))</span><br></pre></td></tr></table></figure>
<h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>Alembic<br><a href="http://blog.csdn.net/ying_593254979/article/details/10189799" target="_blank" rel="noopener">参考</a></p>
<h2 id="OpenStack中的使用"><a href="#OpenStack中的使用" class="headerlink" title="OpenStack中的使用"></a>OpenStack中的使用</h2><p>wsgi框架+SQLAlchemy</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>版本兼容问题<br>rpmbuild</p>
<h2 id="参考索引"><a href="#参考索引" class="headerlink" title="参考索引"></a>参考索引</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Object-relational_mapping" target="_blank" rel="noopener">orm in wiki</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>web</tag>
        <tag>orm</tag>
        <tag>sqlalchemy</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的KeepAlive使用简介</title>
    <url>/2018/04/tcp-keepalive/</url>
    <content><![CDATA[<p>在现代应用系统实现中，我们一般使用长连接与服务端进行交互，以减少建立连接的开销。<br>同时使用连接池，维护特定数量的连接以备随时使用。<br>但是在NAT等有中间设备的情况下，长连接很可能因为某些原因被断开。<br>从而导致连接池失去应有的作用。</p>
<p>基于这些需求，就需要使用TCP的keepalive功能。<br>它能提供一种自动、高效、可灵活配置，相比应用层心跳包更轻量的连接保活方式。</p>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>当我们需要对外提供服务的时候，尤其是KV存储这种对稳定性更高的中间件服务，一般会使用VIP, 而不是让用户直连：</p>
<ul>
<li>减少变更时对用户的影响：如proxy替换、扩容、维护</li>
<li>高可用：更方便的高可用，用户无需探活健康检查等</li>
<li>隐藏拓扑细节：更高的安全性</li>
</ul>
<p>使用VIP时需要注意的是，长时间idle的连接会被reset。<br>原因是LVS一般配置为保持连接有时间限制，如果超过此时间后连接上一直没有报文，LVS就会发送RST报文断开链接。<br>这么做的原因是为了节省连接资源，也避免攻击。</p>
<p>但是在实际使用场景中，用户一般使用资源池维护长连接。<br>在连接池中预留部分多余连接是合理的，此部分连接应该保证长期有效。</p>
<p>这就需要用到<strong>TCP的keepalive功能</strong>。<br><a id="more"></a></p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3><p>具体可以通过man 7 tcp查看。</p>
<p>Linux中有三相关配置项，可使用<code>sysctl -a</code>查看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以下单位都为秒</span><br><span class="line">net.ipv4.tcp_keepalive_time = 7200 # 表示在这个时间之后没有数据时启动探测报文</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 75  # 前一个探测报文和后一个探测报文之间的时间间隔</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 9  # 探测的最大次数</span><br></pre></td></tr></table></figure></p>
<p>使用上述配置，表现大概如下：</p>
<p>连接空闲7200s后触发keepalive，发送第一次ACK</p>
<ul>
<li>连接如果正常，对端会回应ACK</li>
<li>连接如果一直正常，会再次等待空闲7200s后发送ACK</li>
<li>如果连接异常，对端未回应ACK，会等待75s后发送第二个ack</li>
<li>如果一直未成功，第9次发送ACK未回应后，发送RST包关闭连接</li>
</ul>
<p>（注意：以上参数在不同系统下表现可能不一致，我们只说linux下的表现。）<br>系统的配置只是默认值。关闭一个连接需要的时间计算公式为：<code>tcp_keepalive_time + tcp_keepalive_probes* tcp_keepalive_intvl</code><br>默认为<code>7200s+9*75s = 2h 11min 15s</code>。</p>
<p>这其中存在两个问题：</p>
<ul>
<li>默认idle时间为2小时超过2个小时才开始keepalive，时间太长了，这个时间内一般应用早已经超时</li>
<li>没有提供全局开启keepalive的选项</li>
</ul>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>如上，Linux中没有提供全局开启keepalive的选项，必须通过setsockopt系统调用针对单独的socket进行设置。<br>TCP socket 中有三个选项和内核对应：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCPKEEPIDLE: 覆盖 tcp_keepalive_time</span><br><span class="line">TCPKEEPINTVL: 覆盖 tcp_keepalive_intvl</span><br><span class="line">TCPKEEPCNT: 覆盖 tcp_keepalive_probes</span><br></pre></td></tr></table></figure></p>
<h3 id="python-demo"><a href="#python-demo" class="headerlink" title="python demo"></a>python demo</h3><p>服务端启动：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -l 9999</span><br></pre></td></tr></table></figure></p>
<p>客户端代码：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">host=<span class="string">'localhost'</span></span><br><span class="line">port=<span class="number">9999</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, <span class="number">1</span>) <span class="comment"># 开启keepalive</span></span><br><span class="line">s.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, <span class="number">5</span>) <span class="comment"># 5s后开始探活</span></span><br><span class="line">s.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, <span class="number">2</span>) <span class="comment"># 探活间隔2s</span></span><br><span class="line">s.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPCNT, <span class="number">10</span>) <span class="comment">#最大次数</span></span><br><span class="line">s.connect((host, port))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"connected to %s:%d"</span> % (host, port)</span><br><span class="line">s.sendall(<span class="string">"hello world!"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">300</span>):</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"sleep for %ds"</span> % i</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">s.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"finish!"</span></span><br></pre></td></tr></table></figure></p>
<p>在运行一段时间后通过iptables阻断通信：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --destination-port 9999 -j DROP</span><br></pre></td></tr></table></figure></p>
<h3 id="抓包查看"><a href="#抓包查看" class="headerlink" title="抓包查看"></a>抓包查看</h3><p>使用tcpdump抓包可看到以下包的交互：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15:23:12.110546 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [S], seq 4140259582, win 65495, options [mss 65495,sackOK,TS val 2989652584 ecr 0,nop,wscale 7], length 0</span><br><span class="line">15:23:12.110564 IP 127.0.0.1.9999 &gt; 127.0.0.1.39455: Flags [S.], seq 1045216537, ack 4140259583, win 65483, options [mss 65495,sackOK,TS val 2989652584 ecr 2989652584,nop,wscale 7], length 0</span><br><span class="line">15:23:12.110576 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989652584 ecr 2989652584], length 0</span><br><span class="line">15:23:12.110634 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [P.], seq 1:13, ack 1, win 512, options [nop,nop,TS val 2989652584 ecr 2989652584], length 12</span><br><span class="line">15:23:12.110642 IP 127.0.0.1.9999 &gt; 127.0.0.1.39455: Flags [.], ack 13, win 512, options [nop,nop,TS val 2989652584 ecr 2989652584], length 0</span><br><span class="line">15:23:17.110179 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989657584 ecr 2989652584], length 0</span><br><span class="line">15:23:17.110193 IP 127.0.0.1.9999 &gt; 127.0.0.1.39455: Flags [.], ack 13, win 512, options [nop,nop,TS val 2989657584 ecr 2989652584], length 0</span><br><span class="line">15:23:22.110187 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989662584 ecr 2989657584], length 0</span><br><span class="line">15:23:22.110200 IP 127.0.0.1.9999 &gt; 127.0.0.1.39455: Flags [.], ack 13, win 512, options [nop,nop,TS val 2989662584 ecr 2989652584], length 0</span><br><span class="line">15:23:27.110191 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989667584 ecr 2989662584], length 0</span><br><span class="line">15:23:29.110457 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989669584 ecr 2989662584], length 0</span><br><span class="line">15:23:31.110451 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989671584 ecr 2989662584], length 0</span><br><span class="line">15:23:33.110178 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989673584 ecr 2989662584], length 0</span><br><span class="line">15:23:35.110429 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989675584 ecr 2989662584], length 0</span><br><span class="line">15:23:37.110459 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989677584 ecr 2989662584], length 0</span><br><span class="line">15:23:39.110433 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989679584 ecr 2989662584], length 0</span><br><span class="line">15:23:41.110452 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989681584 ecr 2989662584], length 0</span><br><span class="line">15:23:43.110428 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989683584 ecr 2989662584], length 0</span><br><span class="line">15:23:45.110449 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 512, options [nop,nop,TS val 2989685584 ecr 2989662584], length 0</span><br><span class="line">15:23:47.110448 IP 127.0.0.1.39455 &gt; 127.0.0.1.9999: Flags [R.], seq 13, ack 1, win 512, options [nop,nop,TS val 2989687584 ecr 2989662584], length 0</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>15:23:12.110546 - 15:23:12.110576为三次握手建立连接</li>
<li>15:23:12.110634 - 15:23:12.110642为数据发送接收ACK</li>
<li>15:23:17.110179 - 15:23:22.110200为5s探活一次，并接收到9999返回的ACK</li>
<li>15:23:26通过iptables阻断掉9999端口</li>
<li>15:23:27.110191 - 15:23:45.110449每隔2s发送一次探活包，但并无应答</li>
<li>15:23:47.110448发送RST包关闭连接</li>
</ul>
<p>抓包分析结果基本与我们预期一致。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="KeepAlive-in-C"><a href="#KeepAlive-in-C" class="headerlink" title="KeepAlive in C"></a>KeepAlive in C</h3><p>C中可以非常简单的通过系统调用对是否开启及3个参数进行配置。<br>C语言实现代码示例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> s;</span><br><span class="line">   <span class="keyword">int</span> optval;</span><br><span class="line">   <span class="keyword">socklen_t</span> optlen = <span class="keyword">sizeof</span>(optval);</span><br><span class="line">   <span class="keyword">int</span> keepAlive = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> keepIdle = <span class="number">5</span>;        <span class="comment">// idle</span></span><br><span class="line">   <span class="keyword">int</span> keepInterval = <span class="number">5</span>;    <span class="comment">// interval</span></span><br><span class="line">   <span class="keyword">int</span> keepCount = <span class="number">3</span>;       <span class="comment">// count</span></span><br><span class="line">   <span class="comment">/* Create the socket */</span></span><br><span class="line">   <span class="keyword">if</span>((s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">"socket()"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Check the status for the keepalive option */</span></span><br><span class="line">   <span class="keyword">if</span>(getsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, &amp;optlen) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">"getsockopt()"</span>);</span><br><span class="line">      close(s);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"SO_KEEPALIVE is %s\n"</span>, (optval ? <span class="string">"ON"</span> : <span class="string">"OFF"</span>));</span><br><span class="line">   <span class="comment">/* 设置开启keepalive */</span></span><br><span class="line">   <span class="keyword">if</span>(setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span>*)&amp;keepAlive,<span class="keyword">sizeof</span>(keepAlive)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">      close(s);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"SO_KEEPALIVE set on socket\n"</span>);</span><br><span class="line">   <span class="comment">/* 设置IDLE */</span></span><br><span class="line">   <span class="keyword">if</span>(setsockopt(s, SOL_TCP, TCP_KEEPIDLE, (<span class="keyword">void</span> *)&amp;keepIdle, <span class="keyword">sizeof</span>(keepIdle)) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">      close(s);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 设置INTVL */</span></span><br><span class="line">   <span class="keyword">if</span>(setsockopt(s, SOL_TCP, TCP_KEEPINTVL, (<span class="keyword">void</span> *)&amp;keepInterval, <span class="keyword">sizeof</span>(keepInterval)) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">      close(s);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 设置CNT */</span></span><br><span class="line">   <span class="keyword">if</span>(setsockopt(s, SOL_TCP, TCP_KEEPCNT, (<span class="keyword">void</span> *)&amp;keepCount, <span class="keyword">sizeof</span>(keepCount)) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">      close(s);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Check the status again */</span></span><br><span class="line">   <span class="keyword">if</span>(getsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, &amp;optlen) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">"getsockopt()"</span>);</span><br><span class="line">      close(s);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"SO_KEEPALIVE is %s\n"</span>, (optval ? <span class="string">"ON"</span> : <span class="string">"OFF"</span>));</span><br><span class="line">   close(s);</span><br><span class="line">   <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="KeepAlive-in-Go"><a href="#KeepAlive-in-Go" class="headerlink" title="KeepAlive in Go"></a>KeepAlive in Go</h3><p>Go中net.TCPConn结构提供以下两个参数：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span> <span class="title">SetKeepAlive</span><span class="params">(keepalive <span class="keyword">bool</span>)</span> <span class="title">error</span> // 开启关闭<span class="title">keepalive</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span> <span class="title">SetKeepAlivePeriod</span><span class="params">(d time.Duration)</span> <span class="title">error</span> // 使用相同的值设置<span class="title">IDLE</span>和<span class="title">INTVL</span></span></span><br></pre></td></tr></table></figure></p>
<p>目前不支持设置TCP_KEEPCNT的，其它选项可以方便的配置，代码示例如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetKeepAlivePeriod</span><span class="params">(c *net.Conn, d time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t, ok := c.Sock.(*net.TCPConn); ok &#123; <span class="comment">// 只有TCPConn支持</span></span><br><span class="line">        <span class="keyword">if</span> err := t.SetKeepAlive(d != <span class="number">0</span>); err != <span class="literal">nil</span> &#123; <span class="comment">// 设置开启</span></span><br><span class="line">            <span class="keyword">return</span> errors.Trace(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> d != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := t.SetKeepAlivePeriod(d); err != <span class="literal">nil</span> &#123; <span class="comment">// 设置参数</span></span><br><span class="line">                <span class="keyword">return</span> errors.Trace(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><ul>
<li>合理配置，不要探测太频繁，太频繁是对网络资源的浪费</li>
<li>不要滥用，是对连接资源的浪费，资源池中还是应该使用合理的连接数</li>
<li>还是需要对连接的异常进程处理，不能完全保证连接的可用</li>
</ul>
<h3 id="与HTTP-keepalive"><a href="#与HTTP-keepalive" class="headerlink" title="与HTTP keepalive"></a>与HTTP keepalive</h3><p>TCP的keep alive与HTTP的keep alive不是一个概念。<br>HTTP的keep alive功能指的是HTTP 1.1后,请求默认是使用持久连接，即服务器在响应后保持连接，后续的请求通过该连接继续传输，减少建立连接的开销。</p>
<h3 id="与重传"><a href="#与重传" class="headerlink" title="与重传"></a>与重传</h3><p>如果发送方发送的数据包没有收到接收方回复的ACK数据包，此时TCP keepalive机制并不会被启动，而是启动超时重传机制。而因为重传也算作网络传输，因此就使得TCP Keep-alive机制在未收到ACK包时失效。</p>
<h3 id="与应用层心跳"><a href="#与应用层心跳" class="headerlink" title="与应用层心跳"></a>与应用层心跳</h3><p>不能取代应用层心跳。因为：</p>
<ul>
<li>keepalive某些场景下会失效</li>
<li>应用层心跳更有效，keepalive只能保证连接层的有效，而实际场景中连接可能有效，但服务已经无法响应</li>
<li>应用层心跳可用实现更个性化的功能</li>
</ul>
<p>连接测试<br>既然连接池中的连接不能保证一定有些，那可不可以在每次使用前增加检测呢？例如jedispool就提供了TestOnBorrow、TestOnBorrow、TestWhileIdle三个选项，提供在特定场景下对连接测试的功能。<br>但是不建议使用。<br>原因是：</p>
<ul>
<li>连接正常的场景下，相当于浪费一次RTT，增加了延迟</li>
<li>检测过后，也不能保证连接一定有效<br>因此还是建议开启keepalive配合完善的异常处理、重试的方式实现。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TCP keepalive通过在空闲时发送ACK数据包，然后对方回应ACK来实现连接的包含。尤其适用于有中间设备的长连接通信。<br>使用方便，除设置选项后应用无需做出任何改变，也更轻量。但是不能完全取代应用层心跳。<br>适合用来做连接保活，很难用于做探活。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html" target="_blank" rel="noopener">Using TCP keep alive under Linux</a></p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>keepalive</tag>
        <tag>vip</tag>
        <tag>LVS</tag>
      </tags>
  </entry>
</search>
