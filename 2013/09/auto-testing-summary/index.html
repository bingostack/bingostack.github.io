<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="自动化测试,"><meta name="description" content="目前所在的团队一直主要负责部门产品的自动化测试方案。团队在自动化测试方面已经有了几年的探索，但直到最近才真正发挥作用大大提升了产品的测试效率，在这个过程中走了很多的弯路。以下是我这一个阶段以来做自动化测试的思考及总结，有一些大的方向上的讨论，也有一些细节的探讨，希望给大家参考。 关于要不要做相信还有很多人对自动化测试有疑问，或者因为种种原因不愿意引入自动化测试。以下总结了一些反对自动化测试的论点："><meta name="keywords" content="自动化测试"><meta property="og:type" content="article"><meta property="og:title" content="自动化测试实践：自动化测试的思考总结"><meta property="og:url" content="http://bingostack.com/2013/09/auto-testing-summary/index.html"><meta property="og:site_name" content="BingoStack"><meta property="og:description" content="目前所在的团队一直主要负责部门产品的自动化测试方案。团队在自动化测试方面已经有了几年的探索，但直到最近才真正发挥作用大大提升了产品的测试效率，在这个过程中走了很多的弯路。以下是我这一个阶段以来做自动化测试的思考及总结，有一些大的方向上的讨论，也有一些细节的探讨，希望给大家参考。 关于要不要做相信还有很多人对自动化测试有疑问，或者因为种种原因不愿意引入自动化测试。以下总结了一些反对自动化测试的论点："><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2020-11-03T02:23:40.867Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="自动化测试实践：自动化测试的思考总结"><meta name="twitter:description" content="目前所在的团队一直主要负责部门产品的自动化测试方案。团队在自动化测试方面已经有了几年的探索，但直到最近才真正发挥作用大大提升了产品的测试效率，在这个过程中走了很多的弯路。以下是我这一个阶段以来做自动化测试的思考及总结，有一些大的方向上的讨论，也有一些细节的探讨，希望给大家参考。 关于要不要做相信还有很多人对自动化测试有疑问，或者因为种种原因不愿意引入自动化测试。以下总结了一些反对自动化测试的论点："><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://bingostack.com/2013/09/auto-testing-summary/"><title>自动化测试实践：自动化测试的思考总结 | BingoStack</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?9c95a77f4ec2c33edff8095251aef97d";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">BingoStack</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Long way to full stack!</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://bingostack.com/2013/09/auto-testing-summary/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="bingostack"><meta itemprop="description" content><meta itemprop="image" content="/img/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="BingoStack"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">自动化测试实践：自动化测试的思考总结</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2013-09-24T15:41:37+08:00">2013-09-24</time> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2020-11-03T10:23:40+08:00">2020-11-03</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Testing/" itemprop="url" rel="index"><span itemprop="name">Testing</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">4.7k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">15</span></div></div></header><div class="post-body" itemprop="articleBody"><p>目前所在的团队一直主要负责部门产品的自动化测试方案。团队在自动化测试方面已经有了几年的探索，但直到最近才真正发挥作用大大提升了产品的测试效率，在这个过程中走了很多的弯路。<br>以下是我这一个阶段以来做自动化测试的思考及总结，有一些大的方向上的讨论，也有一些细节的探讨，希望给大家参考。</p><h2 id="关于要不要做"><a href="#关于要不要做" class="headerlink" title="关于要不要做"></a>关于要不要做</h2><p>相信还有很多人对自动化测试有疑问，或者因为种种原因不愿意引入自动化测试。以下总结了一些反对自动化测试的论点：</p><ul><li>自动化实现较难<br>一般领域内都有可用的自动化测试框架，是这个领域内大家在自动化测试领域探索后的经验总结。在使用正确框架的基础上，自动化测试的实现并不复杂。</li><li>自动化成本太高<br>下文中将会详细解释，如果设计合理，并有正确的预期，自动化的收益远大于成本。</li><li>项目规模较小，没必要做自动化测试<br>以我们自动化项目的经验，越早做自动化测试，越容易实现，成功率越高。因此可以说成本越低，受益越高。</li><li>会限制产品的灵活性<br>需求的频繁变更确实是自动化的灾难。但一般如果需求需要频繁变更，往往预示着其它问题。</li></ul><a id="more"></a><h3 id="手工测试的局限"><a href="#手工测试的局限" class="headerlink" title="手工测试的局限"></a>手工测试的局限</h3><ul><li>大量机械、重复性的工作效率较低、测试结果可能不准确<br>总结一个词：boring</li><li>很难满足需要模拟大量数据、大量并发量的测试场景<br>比如无法实现系统可靠性测试，如对关键业务进行持续数十天的7*24小时测试</li><li>很难适合敏捷开发过程,无法在短时间内完成大量的测试用例的回归<br>对于测试标准严格的大型软件产品，测试用例的数量可能是以“万”为单位的，全部手工回归一遍需要几人月的工作量！</li></ul><h3 id="自动化测试的引入"><a href="#自动化测试的引入" class="headerlink" title="自动化测试的引入"></a>自动化测试的引入</h3><p>自动化测试就是使用软件来控制测试用例的执行,将实际测试结果与预期结果进行比较,并提供测试预置条件设置、测试逻辑控制以及测试报告生成等重要功能。<br>软件甚至计算机、机器的出现，是为提高人的效率。既然机械、重复性的劳动较多，为何不将这部分工作软件化、自动化？<br>自动化测试可以极大的提升回归测试的工作效率，并简化稳定性测试、兼容性测试等负载类测试的难度,在保障产品质量和持续构建等方面起到举足轻重的作用。</p><h3 id="自动化测试的好处"><a href="#自动化测试的好处" class="headerlink" title="自动化测试的好处"></a>自动化测试的好处</h3><p>简单说几点自动化能带来的好处：</p><ul><li>快速接收；</li><li>持续回归；</li><li>节约人力成本；</li><li>完成人力难以实现的测试，如扩展到性能及稳定性测试。</li></ul><p>当然有些场景下自动化测试是不适合的。</p><h3 id="自动化测试的代价"><a href="#自动化测试的代价" class="headerlink" title="自动化测试的代价"></a>自动化测试的代价</h3><ul><li>开发维护成本<br>特别是从零开始的阶段，自动化会有些挑战。其次是提高测试代码的稳定性，需要付出很大经历。</li><li>对开发流程的挑战、对开发规范的检验<br>自动化测试非常依赖标准的流程，如果没有较好的开发规范，开发人员随意变更代码、测试用例维护不完善，都会导致自动化的推动困难重重。</li></ul><h3 id="对自动化测试的正确预期"><a href="#对自动化测试的正确预期" class="headerlink" title="对自动化测试的正确预期"></a>对自动化测试的正确预期</h3><p>很多自动化项目失败的原因是对于自动化没有合理的预期，大多期望太高。</p><ul><li>自动化测试无法取代手工测试<br>只能取代其中机械重复的部分，“无脑工作量”，越高的智能需要越大的投入。单为测试来说，难以实现且不太值得。</li><li>自动化代码需要持续的维护<br>提高自动化的覆盖度、提高稳定性、与需求变更保持同步，所有这些都需要持续投入进行开发维护。</li><li>但自动化测试确实会带来很大的好处<br>成功的自动化项目能为项目节省至少50%的人力成本，且可以实现一些手工难以实现的功能。</li></ul><h2 id="关于如何做"><a href="#关于如何做" class="headerlink" title="关于如何做"></a>关于如何做</h2><p>接下来探讨一下如何做的一些问题。</p><h3 id="自动化测试的前提"><a href="#自动化测试的前提" class="headerlink" title="自动化测试的前提"></a>自动化测试的前提</h3><p>一个项目、产品，可不可以、值不值得做自动化测试，主要有一下几个前提需要考虑：</p><ul><li><p>需求变动不频繁<br>如果需求，特别是测试的接口（如界面、输出的结果展现）变化频繁，自动化代码的维护无法赶上产品迭代的速度，这种情况下不建议引入自动化测试，而应该等产品稳定、需求收敛后再考虑自动化。否则会导致自动化成本过高，而实际未来得及使用就已经失效了。<br>但同时需要注意的是，如果在项目开始后还频繁变更需求，那往往是项目遇到了比较大的问题。此时应该慎重的考虑整个项目，而不只是仅考虑自动化是否该引入了。</p></li><li><p>项目周期长，并且有迭代<br>项目周期长，才有足够的时间开发自动化测试代码，并确保能真正用上。如果自动化未完成，项目已经结束，那自动化就多余了。<br>而且最好项目有持续迭代。否则如果只需要测试一次或几次，自动化带来的收益太小了。</p></li><li><p>模拟可以实现并且是有效的<br>自动化的过程就是模拟人使用软件的过程。对于无法用软件模拟的动作（如验证码的测试），是无法自动化的。<br>并且模拟必须是有效有价值的。朋友分享的案例是app测试时的定位问题：app中用到了定位，为了方便测试，编写了修改定位的脚本对app进行测试。但实际测试后发现无法测试全面，很多问题只有在实际场景中才会出现。</p></li></ul><h3 id="从简单做起"><a href="#从简单做起" class="headerlink" title="从简单做起"></a>从简单做起</h3><p>二八定律同样适合于自动化测试：提高自动化覆盖度的过程中你会发现80%的工作量集中在20%的测试用例上。然而这也意味着，我们往往只需要投入20%的工作量，即可实现80%的自动化。<br>因此自动化的过程要从实现的简单到困难，开始阶段往往收益比例是最大的。举例我接手的一个自动化项目，测试输入是5000+网站，其中80%只有打开首页这一个动作，10%还需要一个登陆动作，剩下只有不到10%才涉及发帖子等其它复杂的、个性化操作。如果按照从易到难的顺序实现，很容易就可以自动化80%，甚至90%，剩下的10%仍然采用手工测试都会大大减少人工测试的成本。</p><h3 id="按照标准项目来做"><a href="#按照标准项目来做" class="headerlink" title="按照标准项目来做"></a>按照标准项目来做</h3><p>绝大多数自动化项目最终失败的原因是没有把自动化作为一个正式的产品项目来看。<br>自动化测试的项目也是一个标准的软件项目，也应该遵循一些标准的开发流程。如前期也需要确定需求，也需要考虑敏捷、持续迭代，也需要做好自己的测试。<br>实现中容易陷入一些困惑，其实是因为我们忽略了某些流程。典型的如没有做好前期需求收集的识别，完全按使用者说的去做，结果做出来一个并不实用的傻瓜式的自动化方案。再比如没有做好测试，导致测试脚本不稳定。这些都可能导致项目流产。</p><h3 id="要不要做成傻瓜式"><a href="#要不要做成傻瓜式" class="headerlink" title="要不要做成傻瓜式"></a>要不要做成傻瓜式</h3><p>自动化的一个比较大的陷阱就是试图做成傻瓜式，特别是没有专业的产品经理为自动化提取需求的情况下。以下是一个典型的傻瓜式自动化测试需求：测试人员只做测试设计，再做一些配置或工具录制，自动化的测试用例就生成了。之后所有的测试工作交由自动化测试完成。<br>事实证明，这种方案的代价远远大于收益，缺点如下：</p><ul><li>傻瓜化往往需要开发额外的工具<br>越智能的工具，带来越高的开发成本。而且这些工具往往不通用。</li><li><p>自动化脚本质量不高，且维护成本太高<br>比如以录制来说，自动生成的脚本往往有各种问题，效率不高，需要手动调整；而且一旦交互或需求变化，可能很多用例都需要重新录制。而且可能会生成一些复杂难以被人理解的代码，遇见问题时调试困难。</p></li><li><p>所需的培训成本并不低<br>这些工具往往需要使用特定的规则。比如之前看到一个自动化方案，通过一些规定的词汇指定各步骤，然后解析自动生成测试脚本。任何一个词汇不满足要求就生成失败，还要智能的去解析变量，几乎就是重造了一个编译器。<br>但其实回头想一下有没有必要创建一套特定的不通用的规则、重造一门语言？为什么不简单的去要求使用人员去学习一套通用的规则、学习一门语言，如python、tcl？只需要最简单的入门即可。</p></li></ul><h3 id="关于UI测试"><a href="#关于UI测试" class="headerlink" title="关于UI测试"></a>关于UI测试</h3><p>如前所讲，自动化要从易到难，UI测试相比其它自动化测试（典型的如CLI测试），就属于比较难的阶段。<br>但若使用类似于selenium的UI自动化框架，实现并不是很复杂。但UI测试的表现不太稳定，需要付出很多的努力使得用例稳定。典型的如打开网页点击按钮这个简单的动作，实际测试发现总会有一定概率下，这个按钮不出现，而且重现调查也很难找到原因。<br>在这种情况下，建议先demo实验下，可行后从易到难实现。</p><h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><p>哪些测试阶段应该自动化测试？严格说起来，只分为三个阶段：</p><ul><li>单元测试应该做，但更多应该开发人员，或者更详细一些，代码的编写者维护单元测试用例。</li><li>集成测试和系统测试等开发迭代过程中的测试，应该自动化，并且是自动化的主要使用场景。</li><li>发散测试/探索性测试，不应该自动化，因为要发挥人的灵活性，弥补自动化测试的不足。</li></ul><h2 id="关于实现细节"><a href="#关于实现细节" class="headerlink" title="关于实现细节"></a>关于实现细节</h2><p>让我们深入细节，探讨一些深入的点。</p><h3 id="工具或框架的选择"><a href="#工具或框架的选择" class="headerlink" title="工具或框架的选择"></a>工具或框架的选择</h3><p>尽量选择开源的工具或框架：</p><ul><li>方便定制化开发</li><li>非开源软件很多内部逻辑不透明，可能难以大规模扩展</li><li>技术积累、沉淀，使用开源软件能使团队得到更多的技术积累</li><li>节省费用，很多收费的自动化测试工具很贵，使用开源软件可积累一大笔费用</li></ul><p>UI的自动化测试，推荐使用开源的selenium。在我们的项目中，使用selenium实现了绝大多数UI测试需要的功能，而且很容易扩展。<br>CLI的自动化测试选择要多一些，可以简单的使用shell脚本，或python、tcl等更加高级、功能更强大的语言。<br>针对某些特定框架、语言，如js，框架本身可能提供了一些自动化测试框架，因为它可能会用到语言或框架的一些特性，推荐优先使用。</p><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>测试环境的自动部署也是很重要的。虽然不是必须，比如可以在手工搭建好的环境上进行测试。但是对于复杂的环境，或者测试的扩展是很重要的。<br>基础设施部分建议使用虚拟机+pxe实现，软件建议使用配置管理工具实现。</p><h3 id="函数库封装"><a href="#函数库封装" class="headerlink" title="函数库封装"></a>函数库封装</h3><p>如前文所说，我们应该将自动化测试作为一个标准项目来开发。因此也应该进行分层设计，核心的库与具体业务解耦。</p><ul><li>核心库封装各基础功能，建议由自动化团队负责维护；</li><li>具体用例通过调用核心库实现，由测试人员维护。</li></ul><p>这样如果产品接口发生的变更（如登录发生了变化），只需要简单的更新核心库及部分用例即可。如果每个脚本单独实现，此时就需要更新所有依赖此接口的用例。<br>不要单独编写每个测试用例，简单到容易的过程中容易犯这个错误。<br>并且用例之间尽量保持独立，否则不容易扩展，逻辑太复杂。如果一个用例的过程被多次使用，那说明应该封装了。</p><h3 id="sleep的使用"><a href="#sleep的使用" class="headerlink" title="sleep的使用"></a>sleep的使用</h3><p>等待某些条件达成时，最简单的方式就是使用sleep。<br>但sleep的时间设置多少？如果过少，可能条件还未达成；如果过多，会导致执行变慢。而且不同的环境，需要的等待时间不同。<br>所有这些会导致测试的不稳定。因此因减少sleep的使用，而应该实时的去检测条件。这样会增加代码量，但会减少不稳定导致的错误。</p><h2 id="关于弥补不足"><a href="#关于弥补不足" class="headerlink" title="关于弥补不足"></a>关于弥补不足</h2><p>自动化是通过代码模拟人的动作，存在天然的不足。如果能做到足够的精确和高效，那它所具有的人工智能的价值已经超越被测试软件的价值了。<br>幸运的是，我们可以通过一些不太高成本的方式弥补其不足。</p><h3 id="不稳定如何解决"><a href="#不稳定如何解决" class="headerlink" title="不稳定如何解决"></a>不稳定如何解决</h3><p>因为代码的实现及环境因素等，自动化代码难免会出现不稳定的情况，可采取如下方式：</p><ul><li>多次测试，多次测试一排除偶然性的影响，但也不能忽略偶然性bug出现的可能</li><li>专人排查，对所有出错的用例进行排查，定位是产品问题、测试代码问题，还是环境问题。这就要求自动化测试过程中记录足够的日志信息</li><li>持续维护，持续维护代码，保持与主干项目同步，并增强稳定性</li><li>代码自测，做好测试代码的自测，提高测试代码的质量</li></ul><h3 id="加强探测性测试"><a href="#加强探测性测试" class="headerlink" title="加强探测性测试"></a>加强探测性测试</h3><p>自动化尽可能的模仿人，但相似度越高，代价越大；<br>探测性测试可以用较小的成本获得大的受益，同时可检测自动化测试是否有效。</p><h3 id="如何跟踪软件迭代的进度"><a href="#如何跟踪软件迭代的进度" class="headerlink" title="如何跟踪软件迭代的进度"></a>如何跟踪软件迭代的进度</h3><p>自动化的价值就是能及时的对产品进行测试，因此对开发进度有比较高的要求，特别是在项目持续迭代时：</p><ul><li>尽早介入，最好能在详细设计阶段开始自动化开发，但这需要与产品开发人员约定好接口</li><li>模块化的封装，封装后可减少修改</li><li>变更太快的项目，会导致自动化测试无法维护，只能等版本稳定</li></ul><h2 id="团队实际经验"><a href="#团队实际经验" class="headerlink" title="团队实际经验"></a>团队实际经验</h2><p>最后说下团队实际的经验，大体分为3个阶段：</p><ol><li>录制阶段<br>此阶段团队的大部分精力用来开发一个录制的工具：开启录制后，只需要测试人员执行一遍测试，工具即可记录并自动生成自动化代码。同上所述，这个工具的开发本身是不太容易的，而且实际也很难用于别的项目，录制出的脚本也需要再去修改。遇到需求变更，一般都需要重新录制。<br>开始的两年团队一直在重复这个困局：项目开始，团队开始开发维护录制工具；项目集成测试，团队开始录制维护脚本；项目接近释放，录制勉强完成，用来做一次验收测试；开始下一轮循环。<br>此阶段自动化几乎无法实际使用。此阶段的成果在于通过虚拟机+PXE的方式，产品的自动部署流程基本打通。</li><li>脚本阶段<br>经过2年的开发，团队发现录制工具并不实用，而且开发维护的成本较大，自动化进度很慢。因此决定同时采用录制、脚本编写两种方式，开始从易到难的自动化测试用例，并编写模板培训测试人员使用。<br>因为很多用例步骤都是重复的，通过复制粘贴的形式，自动化了很多测试用例，自动化进度大大加快。<br>这个阶段自动化覆盖度大大提高，但是代码质量不高，维护成本很高。</li><li>封装自动化库阶段<br>最终终于将自动化作为一个标准的项目进行开发：产品经理协助提取分析需求；代码解耦，封装核心库，并持续维护提高稳定性，逐渐扩展到UI测试；持续培训测试人员实现自动化，并review其代码。<br>到这个阶段，前期花费巨大精力的录制工具几乎已经被抛弃。<br>经过这个阶段，自动化覆盖度达到90%，因不稳定原因导致的用例失败率降低到10%。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，自动化测试绝大多数情况下是很有价值的。<br>但是需要遵循一些规则，建议将自动化测试项目规范的作为一个产品去开发，并尽可能将敏捷的思想应用其中。</p></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> bingostack</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="http://bingostack.com/2013/09/auto-testing-summary/" title="自动化测试实践：自动化测试的思考总结">http://bingostack.com/2013/09/auto-testing-summary/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/自动化测试/" rel="tag"># 自动化测试</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2013/04/gateway-performance-test-summary/" rel="next" title="网关类产品的性能测试之四：测试工具、注意事项及经验总结"><i class="fa fa-chevron-left"></i> 网关类产品的性能测试之四：测试工具、注意事项及经验总结</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2014/06/openstack-ci/" rel="prev" title="Openstack CI持续集成测试简介">Openstack CI持续集成测试简介<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="jiathis_style"> <span class="jiathis_txt">分享到：</span> <a class="jiathis_button_fav">收藏夹</a> <a class="jiathis_button_copy">复制网址</a> <a class="jiathis_button_email">邮件</a> <a class="jiathis_button_weixin">微信</a> <a class="jiathis_button_qzone">QQ空间</a> <a class="jiathis_button_tqq">腾讯微博</a> <a class="jiathis_button_douban">豆瓣</a> <a class="jiathis_button_share">一键分享</a> <a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a><a class="jiathis_counter_style"></a></div><script type="text/javascript">var jiathis_config={data_track_clickback:!0,summary:"",shortUrl:!1,hideMore:!1}</script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/img/avatar.jpg" alt="bingostack"><p class="site-author-name" itemprop="name">bingostack</p><p class="site-description motion-element" itemprop="description">软件工程师的自我修养</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">34</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">14</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">55</span> <span class="site-state-item-name">标签</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于要不要做"><span class="nav-number">1.</span> <span class="nav-text">关于要不要做</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#手工测试的局限"><span class="nav-number">1.1.</span> <span class="nav-text">手工测试的局限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动化测试的引入"><span class="nav-number">1.2.</span> <span class="nav-text">自动化测试的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动化测试的好处"><span class="nav-number">1.3.</span> <span class="nav-text">自动化测试的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动化测试的代价"><span class="nav-number">1.4.</span> <span class="nav-text">自动化测试的代价</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对自动化测试的正确预期"><span class="nav-number">1.5.</span> <span class="nav-text">对自动化测试的正确预期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于如何做"><span class="nav-number">2.</span> <span class="nav-text">关于如何做</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自动化测试的前提"><span class="nav-number">2.1.</span> <span class="nav-text">自动化测试的前提</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从简单做起"><span class="nav-number">2.2.</span> <span class="nav-text">从简单做起</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按照标准项目来做"><span class="nav-number">2.3.</span> <span class="nav-text">按照标准项目来做</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#要不要做成傻瓜式"><span class="nav-number">2.4.</span> <span class="nav-text">要不要做成傻瓜式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于UI测试"><span class="nav-number">2.5.</span> <span class="nav-text">关于UI测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试阶段"><span class="nav-number">2.6.</span> <span class="nav-text">测试阶段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于实现细节"><span class="nav-number">3.</span> <span class="nav-text">关于实现细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工具或框架的选择"><span class="nav-number">3.1.</span> <span class="nav-text">工具或框架的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试环境"><span class="nav-number">3.2.</span> <span class="nav-text">测试环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数库封装"><span class="nav-number">3.3.</span> <span class="nav-text">函数库封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep的使用"><span class="nav-number">3.4.</span> <span class="nav-text">sleep的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于弥补不足"><span class="nav-number">4.</span> <span class="nav-text">关于弥补不足</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不稳定如何解决"><span class="nav-number">4.1.</span> <span class="nav-text">不稳定如何解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加强探测性测试"><span class="nav-number">4.2.</span> <span class="nav-text">加强探测性测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何跟踪软件迭代的进度"><span class="nav-number">4.3.</span> <span class="nav-text">如何跟踪软件迭代的进度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#团队实际经验"><span class="nav-number">5.</span> <span class="nav-text">团队实际经验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">bingostack</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">62.1k</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html>